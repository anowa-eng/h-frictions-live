{"version":3,"file":"index.esm.js","sources":["../src/Trigger.js","../src/renderer/Matrix.js","../src/renderer/Rectangle.js","../src/renderer/effectInfo.js","../src/renderer/effectTransformPoint.js","../src/Color.js","../src/lib/decode-adpcm-audio.js","../src/Sound.js","../src/Sprite.js","../src/renderer/Drawable.js","../src/renderer/Skin.js","../src/renderer/BitmapSkin.js","../src/renderer/Shaders.js","../src/renderer/ShaderManager.js","../src/renderer/PenSkin.js","../src/renderer/SpeechBubbleSkin.js","../src/renderer/VectorSkin.js","../src/Costume.js","../src/Renderer.js","../src/Input.js","../src/Loudness.js","../src/Project.js","../src/Watcher.js"],"sourcesContent":["const GREEN_FLAG = Symbol(\"GREEN_FLAG\");\nconst KEY_PRESSED = Symbol(\"KEY_PRESSED\");\nconst BROADCAST = Symbol(\"BROADCAST\");\nconst CLICKED = Symbol(\"CLICKED\");\nconst CLONE_START = Symbol(\"CLONE_START\");\nconst LOUDNESS_GREATER_THAN = Symbol(\"LOUDNESS_GREATER_THAN\");\nconst TIMER_GREATER_THAN = Symbol(\"TIMER_GREATER_THAN\");\nconst BACKDROP_CHANGED = Symbol(\"BACKDROP_CHANGED\");\n\nexport default class Trigger {\n  constructor(trigger, options, script) {\n    this.trigger = trigger;\n\n    if (typeof script === \"undefined\") {\n      this.options = {};\n      this._script = options;\n    } else {\n      this.options = options;\n      this._script = script;\n    }\n\n    this.done = false;\n    this.stop = () => {};\n  }\n\n  get isEdgeActivated() {\n    return (\n      this.trigger === TIMER_GREATER_THAN ||\n      this.trigger === LOUDNESS_GREATER_THAN\n    );\n  }\n\n  // Evaluate the given trigger option, whether it's a value or a function that\n  // returns a value given a target\n  option(option, target) {\n    let triggerOption = this.options[option];\n    // If the given option is a function, evaluate that function, passing in\n    // the target that we're evaluating the trigger for\n    if (typeof triggerOption === \"function\") {\n      return triggerOption(target);\n    }\n    return triggerOption;\n  }\n\n  matches(trigger, options, target) {\n    if (this.trigger !== trigger) return false;\n    for (let option in options) {\n      if (this.option(option, target) !== options[option]) return false;\n    }\n\n    return true;\n  }\n\n  start(target) {\n    this.stop();\n\n    const boundScript = this._script.bind(target);\n\n    this.done = false;\n    this._runningScript = boundScript();\n\n    return new Promise(resolve => {\n      this.stop = () => {\n        this.done = true;\n        resolve();\n      };\n    });\n  }\n\n  step() {\n    this.done = this._runningScript.next().done;\n    if (this.done) this.stop();\n  }\n\n  static get GREEN_FLAG() {\n    return GREEN_FLAG;\n  }\n  static get KEY_PRESSED() {\n    return KEY_PRESSED;\n  }\n  static get BROADCAST() {\n    return BROADCAST;\n  }\n  static get CLICKED() {\n    return CLICKED;\n  }\n  static get CLONE_START() {\n    return CLONE_START;\n  }\n  static get LOUDNESS_GREATER_THAN() {\n    return LOUDNESS_GREATER_THAN;\n  }\n  static get TIMER_GREATER_THAN() {\n    return TIMER_GREATER_THAN;\n  }\n  static get BACKDROP_CHANGED() {\n    return BACKDROP_CHANGED;\n  }\n}\n","/* Adapted from gl-matrix\n * https://github.com/toji/gl-matrix\n */\n\n// 3x3 transform matrix operations, unrolled 4 da speedz.\nexport default class Matrix {\n  // Create a new 3x3 transform matrix, initialized to the identity matrix.\n  static create() {\n    const matrix = new Float32Array(9);\n    Matrix.identity(matrix);\n    return matrix;\n  }\n\n  // Reset a matrix to the identity matrix\n  static identity(dst) {\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 1;\n    dst[5] = 0;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 1;\n    return dst;\n  }\n\n  // Translate a matrix by the given X and Y values\n  static translate(dst, src, x, y) {\n    const a00 = src[0],\n      a01 = src[1],\n      a02 = src[2],\n      a10 = src[3],\n      a11 = src[4],\n      a12 = src[5],\n      a20 = src[6],\n      a21 = src[7],\n      a22 = src[8];\n\n    dst[0] = a00;\n    dst[1] = a01;\n    dst[2] = a02;\n\n    dst[3] = a10;\n    dst[4] = a11;\n    dst[5] = a12;\n\n    dst[6] = x * a00 + y * a10 + a20;\n    dst[7] = x * a01 + y * a11 + a21;\n    dst[8] = x * a02 + y * a12 + a22;\n    return dst;\n  }\n\n  // Rotate a matrix, in radians\n  static rotate(dst, src, rad) {\n    const a00 = src[0],\n      a01 = src[1],\n      a02 = src[2],\n      a10 = src[3],\n      a11 = src[4],\n      a12 = src[5],\n      a20 = src[6],\n      a21 = src[7],\n      a22 = src[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n\n    dst[0] = c * a00 + s * a10;\n    dst[1] = c * a01 + s * a11;\n    dst[2] = c * a02 + s * a12;\n\n    dst[3] = c * a10 - s * a00;\n    dst[4] = c * a11 - s * a01;\n    dst[5] = c * a12 - s * a02;\n\n    dst[6] = a20;\n    dst[7] = a21;\n    dst[8] = a22;\n    return dst;\n  }\n\n  // Scale a matrix by the given X and Y values\n  static scale(dst, src, x, y) {\n    dst[0] = x * src[0];\n    dst[1] = x * src[1];\n    dst[2] = x * src[2];\n\n    dst[3] = y * src[3];\n    dst[4] = y * src[4];\n    dst[5] = y * src[5];\n\n    dst[6] = src[6];\n    dst[7] = src[7];\n    dst[8] = src[8];\n    return dst;\n  }\n\n  // Transform a 2D point by the given matrix\n  static transformPoint(m, dst, src) {\n    const x = src[0];\n    const y = src[1];\n    dst[0] = m[0] * x + m[3] * y + m[6];\n    dst[1] = m[1] * x + m[4] * y + m[7];\n    return dst;\n  }\n}\n","export default class Rectangle {\n  constructor() {\n    this.left = -Infinity;\n    this.right = Infinity;\n    this.bottom = -Infinity;\n    this.top = Infinity;\n\n    return this;\n  }\n\n  static fromBounds(left, right, bottom, top, result) {\n    if (!result) result = new Rectangle();\n    result.left = left;\n    result.right = right;\n    result.bottom = bottom;\n    result.top = top;\n\n    return result;\n  }\n\n  // Initialize a bounding box around a sprite given the sprite's transform matrix.\n  static fromMatrix(matrix, result) {\n    if (!result) result = new Rectangle();\n\n    // Adapted somewhat from https://github.com/LLK/scratch-render/blob/develop/docs/Rectangle-AABB-Matrix.md\n    const xa = matrix[0] / 2;\n    const xb = matrix[3] / 2;\n    const absx = Math.abs(xa) + Math.abs(xb);\n    const sumx = xa + xb + matrix[6];\n\n    const ya = matrix[1] / 2;\n    const yb = matrix[4] / 2;\n    const absy = Math.abs(ya) + Math.abs(yb);\n    const sumy = ya + yb + matrix[7];\n\n    result.left = sumx - absx;\n    result.right = sumx + absx;\n    result.bottom = sumy - absy;\n    result.top = sumy + absy;\n\n    return result;\n  }\n\n  // Initialize from another rectangle.\n  static copy(src, dst) {\n    dst.left = src.left;\n    dst.right = src.right;\n    dst.bottom = src.bottom;\n    dst.top = src.top;\n    return dst;\n  }\n\n  // Push this rectangle out to integer bounds.\n  // This takes a conservative approach and will always expand the rectangle outwards.\n  snapToInt() {\n    this.left = Math.floor(this.left);\n    this.right = Math.ceil(this.right);\n    this.bottom = Math.floor(this.bottom);\n    this.top = Math.ceil(this.top);\n\n    return this;\n  }\n\n  // Check whether any part of this rectangle touches another rectangle.\n  intersects(rect) {\n    return (\n      this.left <= rect.right &&\n      rect.left <= this.right &&\n      this.top >= rect.bottom &&\n      rect.top >= this.bottom\n    );\n  }\n\n  // Check whether a given point is inside this rectangle.\n  containsPoint(x, y) {\n    return (\n      x >= this.left && x <= this.right && y >= this.bottom && y <= this.top\n    );\n  }\n\n  // Clamp this rectangle within bounds.\n  clamp(left, right, bottom, top) {\n    this.left = Math.min(Math.max(this.left, left), right);\n    this.right = Math.max(Math.min(this.right, right), left);\n    this.bottom = Math.min(Math.max(this.bottom, bottom), top);\n    this.top = Math.max(Math.min(this.top, top), bottom);\n\n    return this;\n  }\n\n  // Compute the union of two rectangles.\n  static union(rect1, rect2, result = new Rectangle()) {\n    result.left = Math.min(rect1.left, rect2.left);\n    result.right = Math.max(rect1.right, rect2.right);\n    result.bottom = Math.min(rect1.bottom, rect2.bottom);\n    result.top = Math.max(rect1.top, rect2.top);\n\n    return result;\n  }\n\n  // Compute the intersection of two rectangles.\n  static intersection(rect1, rect2, result = new Rectangle()) {\n    result.left = Math.max(rect1.left, rect2.left);\n    result.right = Math.min(rect1.right, rect2.right);\n    result.bottom = Math.max(rect1.bottom, rect2.bottom);\n    result.top = Math.min(rect1.top, rect2.top);\n\n    return result;\n  }\n\n  get width() {\n    return this.right - this.left;\n  }\n\n  get height() {\n    return this.top - this.bottom;\n  }\n}\n","// This file exists to specify a mapping from numeric indices to effect names in all places that require it.\nconst effectNames = [\n  \"color\",\n  \"fisheye\",\n  \"whirl\",\n  \"pixelate\",\n  \"mosaic\",\n  \"brightness\",\n  \"ghost\"\n];\n\nconst effectBitmasks = {};\nfor (let i = 0; i < effectNames.length; i++) {\n  effectBitmasks[effectNames[i]] = 1 << i;\n}\n\nexport { effectNames, effectBitmasks };\n","import { effectBitmasks } from \"./effectInfo.js\";\n\nconst CENTER = 0.5;\nconst EPSILON = 1e-3;\n\n// Transform a texture-space point using the effects defined on the given drawable.\nconst effectTransformPoint = (drawable, src, dst) => {\n  const { effects } = drawable._sprite;\n  const effectBitmask = effects._bitmask;\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n\n  if ((effectBitmask & effectBitmasks.mosaic) !== 0) {\n    // float mosaicFactor = clamp(floor(abs(u_mosaic + 10.0) / 10.0 + 0.5), 1.0, 512.0);\n    const mosaicFactor = Math.max(\n      1,\n      Math.min(Math.floor(Math.abs(effects.mosaic + 10) / 10 + 0.5), 512)\n    );\n    // coord = fract(coord * mosaicFactor);\n    dst[0] = (mosaicFactor * dst[0]) % 1;\n    dst[1] = (mosaicFactor * dst[1]) % 1;\n  }\n\n  if ((effectBitmask & effectBitmasks.pixelate) !== 0) {\n    // vec2 pixSize = u_skinSize / (abs(u_pixelate) * 0.1);\n    const skin = drawable.getCurrentSkin();\n    const pixSizeX = skin.width / (Math.abs(effects.pixelate) * 0.1);\n    const pixSizeY = skin.height / (Math.abs(effects.pixelate) * 0.1);\n    // coord = (floor(coord * pixSize) + CENTER) / pixSize;\n    dst[0] = (Math.floor(dst[0] * pixSizeX) + CENTER) / pixSizeX;\n    dst[1] = (Math.floor(dst[1] * pixSizeY) + CENTER) / pixSizeY;\n  }\n\n  if ((effectBitmask & effectBitmasks.whirl) !== 0) {\n    // const float PI_OVER_180 = 0.017453292519943295;\n    const PI_OVER_180 = 0.017453292519943295;\n    // vec2 offset = coord - CENTER;\n    const offsetX = dst[0] - CENTER;\n    const offsetY = dst[1] - CENTER;\n    // float whirlFactor = max(1.0 - (length(offset) * 2.0), 0.0);\n    const offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n    const whirlFactor = Math.max(1 - offsetLength * 2, 0);\n    // float whirl = (-u_whirl * PI_OVER_180) * whirlFactor * whirlFactor;\n    const whirl = -effects.whirl * PI_OVER_180 * whirlFactor * whirlFactor;\n    // float s = sin(whirl);\n    // float c = cos(whirl);\n    const s = Math.sin(whirl);\n    const c = Math.cos(whirl);\n    // mat2 rotationMatrix = mat2(c, -s, s, c);\n    // coord = rotationMatrix * offset + CENTER;\n    dst[0] = c * offsetX + s * offsetY + CENTER;\n    dst[1] = -s * offsetX + c * offsetY + CENTER;\n  }\n\n  if ((effectBitmask & effectBitmasks.fisheye) !== 0) {\n    // vec2 vec = (coord - CENTER) / CENTER;\n    const vecX = (dst[0] - CENTER) / CENTER;\n    const vecY = (dst[1] - CENTER) / CENTER;\n    // float len = length(vec) + epsilon;\n    const len = Math.sqrt(vecX * vecX + vecY * vecY) + EPSILON;\n    // float factor = max(0.0, (u_fisheye + 100.0) / 100.0);\n    const factor = Math.max(0, (effects.fisheye + 100) / 100);\n    // float r = pow(min(len, 1.0), factor) * max(1.0, len);\n    const r = Math.pow(Math.min(len, 1), factor) * Math.max(1, len);\n    // vec2 unit = vec / len;\n    const unitX = vecX / len;\n    const unitY = vecY / len;\n    // coord = CENTER + (r * unit * CENTER);\n    dst[0] = CENTER + r * unitX * CENTER;\n    dst[1] = CENTER + r * unitY * CENTER;\n  }\n\n  return dst;\n};\n\nexport default effectTransformPoint;\n","const clamp = (n, min, max) => Math.max(min, Math.min(max, n));\n\n// https://www.rapidtables.com/convert/color/rgb-to-hsv.html\nfunction rgbToHSV(r, g, b) {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const delta = max - min;\n\n  let h = 0;\n  if (delta === 0) {\n    // Grey. Leave at 0.\n  } else if (max === r) {\n    h = (((g - b) / delta + 6) % 6) / 6;\n  } else if (max === g) {\n    h = (((b - r) / delta + 2) % 6) / 6;\n  } else if (max === b) {\n    h = (((r - g) / delta + 4) % 6) / 6;\n  }\n\n  let s = 0;\n  if (max !== 0) {\n    s = delta / max;\n  }\n\n  let v = max;\n\n  return {\n    h: h * 100,\n    s: s * 100,\n    v: v * 100\n  };\n}\n\n// https://www.rapidtables.com/convert/color/hsv-to-rgb.html\nfunction hsvToRGB(h, s, v) {\n  h = (h / 100) * 360;\n  s /= 100;\n  v /= 100;\n\n  const c = v * s;\n  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n\n  const min = v - c;\n\n  let r = min;\n  let g = min;\n  let b = min;\n\n  if (h < 60) {\n    r += c;\n    g += x;\n  } else if (h < 120) {\n    g += c;\n    r += x;\n  } else if (h < 180) {\n    g += c;\n    b += x;\n  } else if (h < 240) {\n    b += c;\n    g += x;\n  } else if (h < 300) {\n    b += c;\n    r += x;\n  } else if (h < 360) {\n    r += c;\n    b += x;\n  }\n\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\nexport default class Color {\n  constructor(h = 0, s = 0, v = 0, a = 1) {\n    this.h = h;\n    this.s = s;\n    this.v = v;\n    this.a = a;\n  }\n\n  static rgb(r, g, b, a = 1) {\n    const { h, s, v } = rgbToHSV(r, g, b);\n    return new Color(h, s, v, a);\n  }\n\n  static hsv(h, s, v, a = 1) {\n    return new Color(h, s, v, a);\n  }\n\n  static num(n) {\n    n = Number(n);\n\n    // Match Scratch rgba system\n    // https://github.com/LLK/scratch-vm/blob/0dffc65ce99307d048f6b9a10b1c31b01ab0133d/src/util/color.js#L45\n    const a = (n >> 24) & 0xff;\n    const r = (n >> 16) & 0xff;\n    const g = (n >> 8) & 0xff;\n    const b = n & 0xff;\n    return Color.rgb(r, g, b, a > 0 ? a / 255 : 1);\n  }\n\n  // Red\n  get r() {\n    return hsvToRGB(this.h, this.s, this.v).r;\n  }\n  set r(r) {\n    this._setRGB(r, this.g, this.b);\n  }\n\n  // Green\n  get g() {\n    return hsvToRGB(this.h, this.s, this.v).g;\n  }\n  set g(g) {\n    this._setRGB(this.r, g, this.b);\n  }\n\n  // Blue\n  get b() {\n    return hsvToRGB(this.h, this.s, this.v).b;\n  }\n  set b(b) {\n    this._setRGB(this.r, this.g, b);\n  }\n\n  // Alpha\n  get a() {\n    return this._a;\n  }\n  set a(a) {\n    this._a = clamp(a, 0, 1);\n  }\n\n  // Hue\n  get h() {\n    return this._h;\n  }\n  set h(h) {\n    this._h = ((h % 100) + 100) % 100;\n  }\n\n  // Shade\n  get s() {\n    return this._s;\n  }\n  set s(s) {\n    this._s = clamp(s, 0, 100);\n  }\n\n  // Value\n  get v() {\n    return this._v;\n  }\n  set v(v) {\n    this._v = clamp(v, 0, 100);\n  }\n\n  _setRGB(r, g, b) {\n    r = clamp(r, 0, 255);\n    g = clamp(g, 0, 255);\n    b = clamp(b, 0, 255);\n\n    const { h, s, v } = rgbToHSV(r, g, b);\n\n    this.h = h;\n    this.s = s;\n    this.v = v;\n  }\n\n  toHexString(forceIncludeAlpha = false) {\n    const toHexDigits = n => {\n      n = clamp(Math.round(n), 0, 255);\n\n      let str = n.toString(16);\n      if (str.length === 1) {\n        str = \"0\" + str;\n      }\n\n      return str;\n    };\n\n    let hex = \"#\" + [this.r, this.g, this.b].map(toHexDigits).join(\"\");\n    if (forceIncludeAlpha || this.a !== 1) {\n      hex += toHexDigits(this.a * 255);\n    }\n\n    return hex;\n  }\n\n  toRGBString(forceIncludeAlpha = false) {\n    const rgb = [this.r, this.g, this.b].map(Math.round);\n\n    if (forceIncludeAlpha || this.a !== 1) {\n      return `rgba(${rgb.join(\", \")}, ${this.a})`;\n    }\n    return `rgb(${rgb.join(\", \")})`;\n  }\n\n  toRGBA() {\n    const rgb = hsvToRGB(this._h, this._s, this._v);\n    return [rgb.r, rgb.g, rgb.b, this._a * 255];\n  }\n\n  toRGBANormalized() {\n    const rgb = hsvToRGB(this._h, this._s, this._v);\n    return [rgb.r / 255, rgb.g / 255, rgb.b / 255, this._a];\n  }\n\n  toString() {\n    return this.toRGBString();\n  }\n}\n","/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2013-2019 Truman Kilen, Nathan Dinsmore, and Adroitwhiz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n// prettier-ignore\nconst ADPCM_STEPS = [\n  7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107,\n  118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963,\n  1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894,\n  6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\n  32767\n];\n\nconst ADPCM_INDEX = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];\n\nexport default function decodeADPCMAudio(ab, audioContext) {\n  const dv = new DataView(ab);\n  // WAV magic number\n  if (dv.getUint32(0) !== 0x52494646 || dv.getUint32(8) !== 0x57415645) {\n    return Promise.reject(new Error(\"Unrecognized audio format\"));\n  }\n\n  const blocks = {};\n  const l = dv.byteLength - 8;\n  let i = 12;\n  while (i < l) {\n    blocks[\n      String.fromCharCode(\n        dv.getUint8(i),\n        dv.getUint8(i + 1),\n        dv.getUint8(i + 2),\n        dv.getUint8(i + 3)\n      )\n    ] = i;\n    i += 8 + dv.getUint32(i + 4, true);\n  }\n\n  const format = dv.getUint16(20, true);\n  const sampleRate = dv.getUint32(24, true);\n\n  if (format === 17) {\n    const samplesPerBlock = dv.getUint16(38, true);\n    const blockSize = (samplesPerBlock - 1) / 2 + 4;\n\n    const frameCount = dv.getUint32(blocks.fact + 8, true);\n\n    const buffer = audioContext.createBuffer(1, frameCount, sampleRate);\n    const channel = buffer.getChannelData(0);\n\n    let sample;\n    let index = 0;\n    let step, code, delta;\n    let lastByte = -1;\n\n    const offset = blocks.data + 8;\n    let i = offset;\n    let j = 0;\n    // eslint-disable-next-line\n    while (true) {\n      if ((i - offset) % blockSize === 0 && lastByte < 0) {\n        if (i >= dv.byteLength) break;\n        sample = dv.getInt16(i, true);\n        i += 2;\n        index = dv.getUint8(i);\n        i += 1;\n        i++;\n        if (index > 88) index = 88;\n        channel[j++] = sample / 32767;\n      } else {\n        if (lastByte < 0) {\n          if (i >= dv.byteLength) break;\n          lastByte = dv.getUint8(i);\n          i += 1;\n          code = lastByte & 0xf;\n        } else {\n          code = (lastByte >> 4) & 0xf;\n          lastByte = -1;\n        }\n        step = ADPCM_STEPS[index];\n        delta = 0;\n        if (code & 4) delta += step;\n        if (code & 2) delta += step >> 1;\n        if (code & 1) delta += step >> 2;\n        delta += step >> 3;\n        index += ADPCM_INDEX[code];\n        if (index > 88) index = 88;\n        if (index < 0) index = 0;\n        sample += code & 8 ? -delta : delta;\n        if (sample > 32767) sample = 32767;\n        if (sample < -32768) sample = -32768;\n        channel[j++] = sample / 32768;\n      }\n    }\n    return Promise.resolve(buffer);\n  }\n  return Promise.reject(new Error(`Unrecognized WAV format ${format}`));\n}\n\nexport function isWavData(arrayBuffer) {\n  const dataView = new DataView(arrayBuffer);\n  return (\n    dataView.getUint32(0) === 0x52494646 && dataView.getUint32(8) === 0x57415645\n  );\n}\n\nexport function isADPCMData(arrayBuffer) {\n  const dataView = new DataView(arrayBuffer);\n  const format = dataView.getUint16(20, true);\n  return isWavData(arrayBuffer) && format === 17;\n}\n","import decodeADPCMAudio, { isADPCMData } from \"./lib/decode-adpcm-audio.js\";\n\nexport default class Sound {\n  constructor(name, url) {\n    this.name = name;\n    this.url = url;\n\n    this.audioBuffer = null;\n    this.source = null;\n    this.playbackRate = 1;\n\n    // TODO: Remove this line; initiate downloads from somewhere else instead.\n    this.downloadMyAudioBuffer();\n  }\n\n  get duration() {\n    return this.audioBuffer.duration;\n  }\n\n  *start() {\n    let started = false;\n    let isLatestCallToStart = true;\n\n    if (this._markDone) {\n      this._markDone();\n    }\n\n    if (this.audioBuffer) {\n      this.playMyAudioBuffer();\n      started = true;\n    } else {\n      // It's possible that start() will be called again before this start()\n      // has successfully started the sound (i.e. because it was waiting for\n      // the audio buffer to download). If that's the case, _doneDownloading\n      // will already exist. We never want to return from start() before the\n      // sound has begun playing, but in the case of playUntilDone(), only the\n      // latest call should wait for the sound to finish playing; also, we only\n      // need to run playMyAudioBuffer once. To meet all these conditions, and\n      // also to avoid implementing some kind of addEventListener-esque system,\n      // we implement a simple \"listener chain\" here. Every time we set call\n      // start(), we keep track of the previous value of doneDownloading, and\n      // replace it with a new function. When this function is called directly\n      // as a result of the download finishing, it will call, if existent, the\n      // previous value of doneDownloading with a flag indicating it is being\n      // called from a more recent call to start(). That function will in turn\n      // do the same for its saved previous value, and so on, until all the\n      // previous values of doneDownloading have been called. Thus, all\n      // previous calls of start() will then finish, returning their value of\n      // isLatestCallToStart: false, indicating that if the call came from\n      // playUntilDone(), that playUntilDone should not wait for the sound to\n      // finish playing. Of course, the latest call returns true, and so the\n      // containing playUntilDone() (if present) knows to wait.\n      const oldDoneDownloading = this._doneDownloading;\n      this._doneDownloading = fromMoreRecentCall => {\n        if (fromMoreRecentCall) {\n          isLatestCallToStart = false;\n        } else {\n          this.playMyAudioBuffer();\n          started = true;\n          delete this._doneDownloading;\n        }\n        if (oldDoneDownloading) {\n          oldDoneDownloading(true);\n        }\n      };\n    }\n\n    while (!started && isLatestCallToStart) yield;\n\n    return isLatestCallToStart;\n  }\n\n  *playUntilDone() {\n    let playing = true;\n\n    const isLatestCallToStart = yield* this.start();\n\n    // If we failed to download the audio buffer, just stop here - the sound will\n    // never play, so it doesn't make sense to wait for it.\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    this.source.addEventListener(\"ended\", () => {\n      playing = false;\n      delete this._markDone;\n    });\n\n    // If there was another call to start() since ours, don't wait for the\n    // sound to finish before returning.\n    if (!isLatestCallToStart) {\n      return;\n    }\n\n    // Set _markDone after calling start(), because start() will call the existing\n    // value of _markDone if it's already set. It does this because playUntilDone()\n    // is meant to be interrupted if another start() is ran while it's playing.\n    // Of course, we don't want *this* playUntilDone() to be treated as though it\n    // were interrupted when we call start(), so setting _markDone comes after.\n    this._markDone = () => {\n      playing = false;\n      delete this._markDone;\n    };\n\n    while (playing) yield;\n  }\n\n  stop() {\n    if (this._markDone) {\n      this._markDone();\n    }\n\n    if (this.source) {\n      this.source.disconnect();\n      this.source = null;\n    }\n  }\n\n  downloadMyAudioBuffer() {\n    return fetch(this.url)\n      .then(body => body.arrayBuffer())\n      .then(arrayBuffer => {\n        if (isADPCMData(arrayBuffer)) {\n          return decodeADPCMAudio(arrayBuffer, Sound.audioContext).catch(\n            error => {\n              console.warn(\n                `Failed to load sound \"${this.name}\" - will not play:\\n` + error\n              );\n              return null;\n            }\n          );\n        } else {\n          return new Promise((resolve, reject) => {\n            Sound.audioContext.decodeAudioData(arrayBuffer, resolve, reject);\n          });\n        }\n      })\n      .then(audioBuffer => {\n        this.audioBuffer = audioBuffer;\n        if (this._doneDownloading) {\n          this._doneDownloading();\n        }\n        return audioBuffer;\n      });\n  }\n\n  playMyAudioBuffer() {\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    if (this.source) {\n      this.source.disconnect();\n    }\n\n    this.source = Sound.audioContext.createBufferSource();\n    this.source.buffer = this.audioBuffer;\n    this.source.playbackRate.value = this.playbackRate;\n\n    if (this.target) {\n      this.source.connect(this.target);\n    }\n\n    this.source.start(Sound.audioContext.currentTime);\n  }\n\n  connect(target) {\n    if (target !== this.target) {\n      this.target = target;\n      if (this.source) {\n        this.source.disconnect();\n        this.source.connect(this.target);\n      }\n    }\n  }\n\n  setPlaybackRate(value) {\n    this.playbackRate = value;\n    if (this.source) {\n      this.source.playbackRate.value = value;\n    }\n  }\n\n  isConnectedTo(target) {\n    return this.target === target;\n  }\n\n  // Note: \"this\" refers to the Sound class in static functions.\n\n  static get audioContext() {\n    this._setupAudioContext();\n    return this._audioContext;\n  }\n\n  static _setupAudioContext() {\n    if (!this._audioContext) {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      this._audioContext = new AudioContext();\n    }\n  }\n\n  static decodeADPCMAudio(audioBuffer) {\n    return decodeADPCMAudio(audioBuffer, this.audioContext);\n  }\n}\n\nexport class EffectChain {\n  // The code in this class is functionally comparable to the class of the same\n  // name in the scratch-audio library, but is completely rewritten and follows\n  // somewhat different logic. Still, the class exists on the same principle:\n  // a portable way to store the effect chain, independent of the audio sources\n  // it affects.\n\n  constructor(config) {\n    const { getNonPatchSoundList } = config;\n    this.config = config;\n\n    this.inputNode = Sound.audioContext.createGain();\n\n    // This is a mapping of an effect's name to an object containing all the\n    // nodes which are of use to that effect: always an {input, output} pair,\n    // as well as any other nodes of use to that effect. The values here are\n    // filled in by an effect descriptor's makeNodes() function, and may\n    // contain duplicate copies of the same node within a particular effect's\n    // object, when that's of use to make the logic clearer (e.g. when there's\n    // no distinction between the input and output node, or referring to the\n    // output node by a more specific name).\n    this.effectNodes = {};\n\n    this.resetToInitial();\n\n    this.getNonPatchSoundList = getNonPatchSoundList;\n  }\n\n  resetToInitial() {\n    // Note: some effects won't be reset by this function, except for when they\n    // are set for the first time (i.e. when the EffectChain is instantiated).\n    // Look for the \"reset: false\" flag in the effect descriptor list.\n\n    const initials = EffectChain.getInitialEffectValues();\n    if (this.effectValues) {\n      for (const [name, initialValue] of Object.entries(\n        EffectChain.getInitialEffectValues()\n      )) {\n        if (EffectChain.getEffectDescriptor(name).reset !== false) {\n          this.setEffectValue(name, initialValue);\n        }\n      }\n    } else {\n      this.effectValues = initials;\n    }\n  }\n\n  updateAudioEffect(name) {\n    const descriptor = EffectChain.getEffectDescriptor(name);\n\n    if (!descriptor) {\n      return;\n    }\n\n    // updateAudioEffect doesn't take a value - it only reflects the existing\n    // value in the actual effects applied to nodes and sounds!\n    const value = this.effectValues[name];\n\n    if (descriptor.isPatch) {\n      // Here, we search for the next and previous effects in the chain\n      // who have existent nodes. This means we'll skip non-patch effects as\n      // well as effects are set to their initial value.\n\n      let next = descriptor;\n      do {\n        next = EffectChain.getNextEffectDescriptor(next.name);\n      } while (next && !this.effectNodes[next.name]);\n\n      let previous = descriptor;\n      do {\n        previous = EffectChain.getPreviousEffectDescriptor(previous.name);\n      } while (previous && !this.effectNodes[previous.name]);\n\n      // If we have previous and next values available, they'll currently be\n      // the corresponding descriptors. But we only ever need to access the\n      // nodes which correspond to those descriptor's names, so we replace them\n      // with the actual objects containing the effect's nodes here to simplify\n      // later code.\n\n      if (next) {\n        next = this.effectNodes[next.name];\n      }\n\n      if (previous) {\n        next = this.effectNodes[previous.name];\n      }\n\n      // If there is no preceding or following effect which has existent nodes,\n      // we'll make the variables reference the target input and target nodes\n      // of the EffectChain - i.e, the two ends of the chain, as far as this\n      // class is concerned. (Note that while the input node will always be\n      // present, because it's defined right on the EffectChain, it's possible\n      // that there won't be any target node, leaving the value for \"next\"\n      // still null.)\n      //\n      // We do need to keep to the structure that effectNodes contains, though.\n      // When we access the previous node (or the EffectChain's input node, in\n      // this case), we'll be making a connection with its output; likewise,\n      // when we're accessing the next node (or the EffectChain's target),\n      // we'll be connecting something to its input. That's reflected in the\n      // values here.\n\n      if (!previous) {\n        previous = { output: this.inputNode };\n      }\n\n      if (!next && this.target) {\n        next = { input: this.target };\n      }\n\n      // \"Patch\" effects are applied by sending audio data through an ordered\n      // series - i.e, a chain - of WebAudio nodes. All effects have an input\n      // node and an output node; for simple effects, these may actually be the\n      // same node. (Take a look at the volume effect, which uses a single Gain\n      // node as both its input and output.) Other effects are more complex.\n      // The code in this block controls the actual chaining behavior of\n      // EffectChain, assuring that all effects form a clean chain.\n      let nodes = this.effectNodes[descriptor.name];\n      if (!nodes && value !== descriptor.initial) {\n        nodes = descriptor.makeNodes();\n        this.effectNodes[descriptor.name] = nodes;\n\n        // Connect the previous effect, or, if there is none, the EffectChain\n        // input, to this effect. Also disconnect it from whatever it was\n        // previously connected to, so we aren't sending data more than one\n        // place at a time - that would mess with the chain.\n        previous.output.disconnect();\n        previous.output.connect(nodes.input);\n\n        // Connect this effect to the next effect, or, if there is none,\n        // the EffectChain target.\n        if (next) {\n          nodes.output.connect(next.input);\n        }\n      }\n\n      if (value === descriptor.initial) {\n        // If we're setting to the initial value, disconnect and discard the\n        // effect's nodes. It's not necessary to keep nodes that don't cause\n        // an effect in the chain. (We don't need to run the set() behavior\n        // specified on the effect descriptor, since we're disconnecting and\n        // discarding the nodes - the only values that function has access to.)\n        if (nodes) {\n          // There's no need to define custom disposal behavior per effect,\n          // since it's always a matter of simply disconnecting every node.\n          // The disconnect() method of a WebAudio node won't error if it's\n          // already had all its connections removed, but we avoid redundant\n          // calls here anyway.\n          for (const node of new Set(Object.values(nodes))) {\n            node.disconnect();\n          }\n\n          // We also need to establish a connection between the adjacent nodes\n          // (which may be the EffectChain's input node and target node, if\n          // there aren't any adjacent effect nodes).\n          if (next) {\n            previous.output.connect(next.input);\n          }\n\n          // Finally, we discard the object which holds the effect's nodes.\n          // We aren't going to be using it anymore, and we need it gone so\n          // that we recreate the nodes and correctly position them back in\n          // the chain, if we use this effect again later.\n          delete this.effectNodes[name];\n        }\n      } else {\n        descriptor.set(value, nodes);\n      }\n    } else {\n      // Non-\"patch\" effects operate directly on Sound objects, accessing\n      // APIs provided by that class. The actual sound list is provided by the\n      // caller of EffectChain.\n      for (const sound of this.getNonPatchSoundList()) {\n        descriptor.set(value, sound);\n      }\n    }\n  }\n\n  connect(target) {\n    this.target = target;\n\n    // All the code here is basically the same as what's written in\n    // updateAudioEffect above; specific to this function, we want to\n    // disconnect the final output in the chain - which may be the input\n    // node - and then connect it to the newly specified target.\n\n    let last = EffectChain.getLastEffectDescriptor();\n    do {\n      last = EffectChain.getPreviousEffectDescriptor(last.name);\n    } while (last && !this.effectNodes[last.name]);\n\n    if (last) {\n      last = this.effectNodes[last.name];\n    } else {\n      last = { output: this.inputNode };\n    }\n\n    last.output.disconnect();\n    last.output.connect(target);\n  }\n\n  setEffectValue(name, value) {\n    value = Number(value);\n    if (\n      name in this.effectValues &&\n      !isNaN(value) &&\n      value !== this.effectValues[name]\n    ) {\n      this.effectValues[name] = value;\n      this.clampEffectValue(name);\n      this.updateAudioEffect(name);\n    }\n  }\n\n  changeEffectValue(name, value) {\n    value = Number(value);\n    if (name in this.effectValues && !isNaN(value) && value !== 0) {\n      this.effectValues[name] += value;\n      this.clampEffectValue(name);\n      this.updateAudioEffect(name);\n    }\n  }\n\n  clampEffectValue(name) {\n    // Not all effects are clamped (pitch, for example); it's also possible to\n    // specify only a minimum or maximum bound, instead of both.\n    const descriptor = EffectChain.getEffectDescriptor(name);\n    let value = this.effectValues[name];\n    if (\"minimum\" in descriptor && value < descriptor.minimum) {\n      value = descriptor.minimum;\n    } else if (\"maximum\" in descriptor && value > descriptor.maximum) {\n      value = descriptor.maximum;\n    }\n    this.effectValues[name] = value;\n  }\n\n  getEffectValue(name) {\n    return this.effectValues[name] || 0;\n  }\n\n  clone(newConfig) {\n    const newEffectChain = new EffectChain(\n      Object.assign({}, this.config, newConfig)\n    );\n\n    for (const [name, value] of Object.entries(this.effectValues)) {\n      const descriptor = EffectChain.getEffectDescriptor(name);\n      if (!descriptor.resetOnClone) {\n        newEffectChain.setEffectValue(name, value);\n      }\n    }\n\n    newEffectChain.connect(this.target);\n\n    return newEffectChain;\n  }\n\n  applyToSound(sound) {\n    sound.connect(this.inputNode);\n\n    for (const [name, value] of Object.entries(this.effectValues)) {\n      const descriptor = EffectChain.getEffectDescriptor(name);\n      if (!descriptor.isPatch) {\n        descriptor.set(value, sound);\n      }\n    }\n  }\n\n  isTargetOf(sound) {\n    return sound.isConnectedTo(this.inputNode);\n  }\n\n  static getInitialEffectValues() {\n    // This would be an excellent place to use Object.fromEntries, but that\n    // function has been implemented in only the latest of a few modern\n    // browsers. :P\n    const initials = {};\n    for (const { name, initial } of this.effectDescriptors) {\n      initials[name] = initial;\n    }\n    return initials;\n  }\n\n  static getEffectDescriptor(name) {\n    return this.effectDescriptors.find(descriptor => descriptor.name === name);\n  }\n\n  static getFirstEffectDescriptor() {\n    return this.effectDescriptors[0];\n  }\n\n  static getLastEffectDescriptor() {\n    return this.effectDescriptors[this.effectDescriptors.length - 1];\n  }\n\n  static getNextEffectDescriptor(name) {\n    // .find() provides three values to its passed function: the value of the\n    // current item, that item's index, and the array on which .find() is\n    // operating. In this case, we're only concerned with the index.\n    // For each item in the list, besides the first, we check if the item\n    // before it matches the name we were given. By initially shifting all the\n    // descriptors using slice(1), the index of any item in the shifted list\n    // corresponds to the previous item in the original list. Thus, if that\n    // previous item matches the provided name, by definition, we'll have found\n    // the item which comes after it.\n    return this.effectDescriptors\n      .slice(1)\n      .find((_, i) => this.effectDescriptors[i].name === name);\n  }\n\n  static getPreviousEffectDescriptor(name) {\n    // This function's a little simpler, since it doesn't involve shifting the\n    // list. We still use slice(), but this time simply to cut off the last\n    // item; that item will never come before any other, after all. We search\n    // the list for the item whose following item matches the provided name,\n    // using the more typical [i + 1] way of accessing an adjacent item.\n    // (In getNextEffectDescriptor(), we don't need to offset the index like\n    // that, because the shift already lines up the index as we need it.)\n    return this.effectDescriptors\n      .slice(0, -1)\n      .find((_, i) => this.effectDescriptors[i + 1].name === name);\n  }\n}\n\n// These are constant values which can be affected to tweak the way effects\n// are applied. They match the values used in Scratch 3.0.\nEffectChain.decayDuration = 0.025;\nEffectChain.decayWait = 0.05;\n\n// Instead of creating a basic Effect class and then implementing a subclass\n// for each effect type, we use a simplified object-descriptor style.\n// The makeNodes() function returns an object which is passed on to set(), so\n// that effects are able to access a variety of nodes (or other values, if\n// necessary) required to execute the desired effect.\n//\n// The code in makeNodes as well as the general definition for each effect is\n// all graciously based on LLK's scratch-audio library.\n//\n// The initial value of an effect should always be the value at which the\n// sound is not affected at all - i.e, it would be the same if the effect\n// nodes were completely disconnected from the chain or otherwise had never\n// been applied. This allows for clean discarding of effect nodes when returned\n// to the initial value.\n//\n// The order of this array matches AudioEngine's effects list in scratch-audio.\n// Earlier in the list is closer to the EffectChain input node; later is closer\n// to its target (output). Note that a non-\"patch\" effect's position in the\n// array has no bearing on effect behavior, since it isn't part of the chain\n// system.\n//\n// Note that this descriptor list is fairly easy to build on, if we'd like to\n// add more audio effects in the future. (Scratch used to have more, but they\n// were removed - see commit ff6cd4a - because they depended on an external\n// library and were too processor-intensive to support on some devices.)\nEffectChain.effectDescriptors = [\n  {\n    name: \"pan\",\n    initial: 0,\n    minimum: -100,\n    maximum: 100,\n    isPatch: true,\n    makeNodes() {\n      const aCtx = Sound.audioContext;\n      const input = aCtx.createGain();\n      const leftGain = aCtx.createGain();\n      const rightGain = aCtx.createGain();\n      const channelMerger = aCtx.createChannelMerger(2);\n      const output = channelMerger;\n      input.connect(leftGain);\n      input.connect(rightGain);\n      leftGain.connect(channelMerger, 0, 0);\n      rightGain.connect(channelMerger, 0, 1);\n      return { input, output, leftGain, rightGain, channelMerger };\n    },\n    set(value, { input, output, leftGain, rightGain }) {\n      const p = (value + 100) / 200;\n      const leftVal = Math.cos((p * Math.PI) / 2);\n      const rightVal = Math.sin((p * Math.PI) / 2);\n      const { currentTime } = Sound.audioContext;\n      const { decayWait, decayDuration } = EffectChain;\n      leftGain.gain.setTargetAtTime(\n        leftVal,\n        currentTime + decayWait,\n        decayDuration\n      );\n      rightGain.gain.setTargetAtTime(\n        rightVal,\n        currentTime + decayWait,\n        decayDuration\n      );\n    }\n  },\n  {\n    name: \"pitch\",\n    initial: 0,\n    isPatch: false,\n    set(value, sound) {\n      const interval = value / 10;\n      const ratio = Math.pow(2, interval / 12);\n      sound.setPlaybackRate(ratio);\n    }\n  },\n  {\n    name: \"volume\",\n    initial: 100,\n    minimum: 0,\n    maximum: 100,\n    resetOnStart: false,\n    resetOnClone: true,\n    isPatch: true,\n    makeNodes() {\n      const node = Sound.audioContext.createGain();\n      return {\n        input: node,\n        output: node,\n        node\n      };\n    },\n    set(value, { node }) {\n      node.gain.linearRampToValueAtTime(\n        value / 100,\n        Sound.audioContext.currentTime + EffectChain.decayDuration\n      );\n    }\n  }\n];\n\nexport class AudioEffectMap {\n  // This class provides a simple interface for setting and getting audio\n  // effects stored on an EffectChain, similar to EffectMap (that class being\n  // for graphic effects). It takes an EffectChain and automatically generates\n  // properties according to the names of the effect descriptors, acting with\n  // the EffectChain's API when accessed.\n\n  constructor(effectChain) {\n    this.effectChain = effectChain;\n\n    for (const { name } of EffectChain.effectDescriptors) {\n      Object.defineProperty(this, name, {\n        get: () => effectChain.getEffectValue(name),\n        set: value => effectChain.setEffectValue(name, value)\n      });\n    }\n  }\n\n  clear() {\n    this.effectChain.resetToInitial();\n  }\n}\n","import Color from \"./Color.js\";\nimport Trigger from \"./Trigger.js\";\nimport Sound, { EffectChain, AudioEffectMap } from \"./Sound.js\";\n\nimport { effectNames } from \"./renderer/effectInfo.js\";\n// This is a wrapper to allow the enabled effects in a sprite to be used as a Map key.\n// By setting an effect, the bitmask is updated as well.\n// This allows the bitmask to be used to uniquely identify a set of enabled effects.\nclass _EffectMap {\n  constructor() {\n    this._bitmask = 0;\n    this._effectValues = {};\n\n    for (let i = 0; i < effectNames.length; i++) {\n      const effectName = effectNames[i];\n      this._effectValues[effectName] = 0;\n\n      Object.defineProperty(this, effectName, {\n        get: () => {\n          return this._effectValues[effectName];\n        },\n\n        set: val => {\n          this._effectValues[effectName] = val;\n\n          if (val === 0) {\n            // If the effect value is 0, meaning it's disabled, set its bit in the bitmask to 0.\n            this._bitmask = this._bitmask & ~(1 << i);\n          } else {\n            // Otherwise, set its bit to 1.\n            this._bitmask = this._bitmask | (1 << i);\n          }\n        }\n      });\n    }\n  }\n\n  _clone() {\n    const m = new _EffectMap();\n    for (const effectName of Object.keys(this._effectValues)) {\n      m[effectName] = this[effectName];\n    }\n    return m;\n  }\n\n  clear() {\n    for (const effectName of Object.keys(this._effectValues)) {\n      this._effectValues[effectName] = 0;\n    }\n    this._bitmask = 0;\n  }\n}\n\nclass SpriteBase {\n  constructor(initialConditions, vars = {}) {\n    this._project = null;\n\n    const { costumeNumber, layerOrder = 0 } = initialConditions;\n    this._costumeNumber = costumeNumber;\n    this._layerOrder = layerOrder;\n\n    this.triggers = [];\n    this.watchers = {};\n    this.costumes = [];\n    this.sounds = [];\n\n    this.effectChain = new EffectChain({\n      getNonPatchSoundList: this.getSoundsPlayedByMe.bind(this)\n    });\n    this.effectChain.connect(Sound.audioContext.destination);\n\n    this.effects = new _EffectMap();\n    this.audioEffects = new AudioEffectMap(this.effectChain);\n\n    this._vars = vars;\n  }\n\n  getSoundsPlayedByMe() {\n    return this.sounds.filter(sound => this.effectChain.isTargetOf(sound));\n  }\n\n  get stage() {\n    return this._project.stage;\n  }\n\n  get sprites() {\n    return this._project.sprites;\n  }\n\n  get vars() {\n    return this._vars;\n  }\n\n  get costumeNumber() {\n    return this._costumeNumber;\n  }\n\n  set costumeNumber(number) {\n    this._costumeNumber = ((number - 1) % this.costumes.length) + 1;\n    if (this.fireBackdropChanged) this.fireBackdropChanged();\n  }\n\n  set costume(costume) {\n    if (typeof costume === \"number\") {\n      this.costumeNumber = costume;\n    }\n    if (typeof costume === \"string\") {\n      const index = this.costumes.findIndex(c => c.name === costume);\n      if (index > -1) {\n        this.costumeNumber = index + 1;\n      } else {\n        switch (costume) {\n          case \"next costume\":\n          case \"next backdrop\": {\n            this.costumeNumber = this.costumeNumber + 1;\n            break;\n          }\n\n          case \"previous costume\":\n          case \"previous backdrop\": {\n            this.costumeNumber = this.costumeNumber - 1;\n            break;\n          }\n\n          case \"random costume\":\n          case \"random backdrop\": {\n            // Based on joker314's inclusiveRandIntWithout: https://github.com/LLK/scratch-vm/pull/2011\n            // Note: We use 1 -> length instead of 0 -> length-1, since we want a 1-indexed result.\n            const lower = 1;\n            const upper = this.costumes.length;\n            const excluded = this.costumeNumber;\n\n            const possibleOptions = upper - lower;\n            let randInt = lower + Math.floor(Math.random() * possibleOptions);\n            if (randInt >= excluded) {\n              randInt++;\n            }\n\n            this.costumeNumber = randInt;\n            break;\n          }\n\n          default: {\n            if (!(isNaN(costume) || costume.trim().length === 0)) {\n              this.costumeNumber = Number(costume);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  get costume() {\n    return this.costumes[this.costumeNumber - 1];\n  }\n\n  moveAhead(value = Infinity) {\n    if (typeof value === \"number\") {\n      this._project.changeSpriteLayer(this, value);\n    } else {\n      this._project.changeSpriteLayer(this, 1, value);\n    }\n  }\n\n  moveBehind(value = Infinity) {\n    if (typeof value === \"number\") {\n      this._project.changeSpriteLayer(this, -value);\n    } else {\n      this._project.changeSpriteLayer(this, -1, value);\n    }\n  }\n\n  degToRad(deg) {\n    return (deg * Math.PI) / 180;\n  }\n\n  radToDeg(rad) {\n    return (rad * 180) / Math.PI;\n  }\n\n  degToScratch(deg) {\n    return -deg + 90;\n  }\n\n  scratchToDeg(scratchDir) {\n    return -scratchDir + 90;\n  }\n\n  radToScratch(rad) {\n    return this.degToScratch(this.radToDeg(rad));\n  }\n\n  scratchToRad(scratchDir) {\n    return this.degToRad(this.scratchToDeg(scratchDir));\n  }\n\n  // Wrap rotation from -180 to 180.\n  normalizeDeg(deg) {\n    // This is a pretty big math expression, but it's necessary because in JavaScript,\n    // the % operator means \"remainder\", not \"modulo\", and so negative numbers won't \"wrap around\".\n    // See https://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm\n    return ((((deg + 180) % 360) + 360) % 360) - 180;\n  }\n\n  // Given a generator function, return a version of it that runs in \"warp mode\" (no yields).\n  warp(procedure) {\n    const bound = procedure.bind(this);\n    return (...args) => {\n      const inst = bound(...args);\n      while (!inst.next().done);\n    };\n  }\n\n  random(a, b) {\n    const min = Math.min(a, b);\n    const max = Math.max(a, b);\n    if (min % 1 === 0 && max % 1 === 0) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return Math.random() * (max - min) + min;\n  }\n\n  *wait(secs) {\n    let endTime = new Date();\n    endTime.setMilliseconds(endTime.getMilliseconds() + secs * 1000);\n    while (new Date() < endTime) {\n      yield;\n    }\n  }\n\n  get mouse() {\n    return this._project.input.mouse;\n  }\n\n  keyPressed(name) {\n    return this._project.input.keyPressed(name);\n  }\n\n  get timer() {\n    return this._project.timer;\n  }\n\n  restartTimer() {\n    this._project.restartTimer();\n  }\n\n  *startSound(soundName) {\n    const sound = this.getSound(soundName);\n    if (sound) {\n      this.effectChain.applyToSound(sound);\n      yield* sound.start();\n    }\n  }\n\n  *playSoundUntilDone(soundName) {\n    const sound = this.getSound(soundName);\n    if (sound) {\n      sound.connect(this.effectChain.inputNode);\n      this.effectChain.applyToSound(sound);\n      yield* sound.playUntilDone();\n    }\n  }\n\n  getSound(soundName) {\n    if (typeof soundName === \"number\") {\n      return this.sounds[(soundName - 1) % this.sounds.length];\n    } else {\n      return this.sounds.find(s => s.name === soundName);\n    }\n  }\n\n  stopAllSounds() {\n    this._project.stopAllSounds();\n  }\n\n  stopAllOfMySounds() {\n    for (const sound of this.sounds) {\n      sound.stop();\n    }\n  }\n\n  broadcast(name) {\n    return this._project.fireTrigger(Trigger.BROADCAST, { name });\n  }\n\n  *broadcastAndWait(name) {\n    let running = true;\n    this.broadcast(name).then(() => {\n      running = false;\n    });\n\n    while (running) {\n      yield;\n    }\n  }\n\n  clearPen() {\n    this._project.renderer.clearPen();\n  }\n\n  *askAndWait(question) {\n    if (this._speechBubble) {\n      this.say(\"\");\n    }\n\n    let done = false;\n    this._project.askAndWait(question).then(() => {\n      done = true;\n    });\n\n    while (!done) yield;\n  }\n\n  get answer() {\n    return this._project.answer;\n  }\n\n  get loudness() {\n    return this._project.loudness;\n  }\n}\n\nexport class Sprite extends SpriteBase {\n  constructor(initialConditions, ...args) {\n    super(initialConditions, ...args);\n\n    const {\n      x,\n      y,\n      direction,\n      rotationStyle,\n      costumeNumber,\n      size,\n      visible,\n      penDown,\n      penSize,\n      penColor\n    } = initialConditions;\n\n    this._x = x;\n    this._y = y;\n    this._direction = direction;\n    this.rotationStyle = rotationStyle || Sprite.RotationStyle.ALL_AROUND;\n    this._costumeNumber = costumeNumber;\n    this.size = size;\n    this.visible = visible;\n\n    this.parent = null;\n    this.clones = [];\n\n    this._penDown = penDown || false;\n    this.penSize = penSize || 1;\n    this._penColor = penColor || Color.rgb(0, 0, 255);\n\n    this._speechBubble = {\n      text: \"\",\n      style: \"say\",\n      timeout: null\n    };\n  }\n\n  createClone() {\n    const clone = Object.assign(\n      Object.create(Object.getPrototypeOf(this)),\n      this\n    );\n\n    clone._project = this._project;\n    clone.triggers = this.triggers.map(\n      trigger => new Trigger(trigger.trigger, trigger.options, trigger._script)\n    );\n    clone.costumes = this.costumes;\n    clone.sounds = this.sounds;\n    clone._vars = Object.assign({}, this._vars);\n\n    clone._speechBubble = {\n      text: \"\",\n      style: \"say\",\n      timeout: null\n    };\n\n    clone.effects = this.effects._clone();\n\n    // Clones inherit audio effects from the original sprite, for some reason.\n    // Couldn't explain it, but that's the behavior in Scratch 3.0.\n    let original = this;\n    while (original.parent) {\n      original = original.parent;\n    }\n    clone.effectChain = original.effectChain.clone({\n      getNonPatchSoundList: clone.getSoundsPlayedByMe.bind(clone)\n    });\n\n    // Make a new audioEffects interface which acts on the cloned effect chain.\n    clone.audioEffects = new AudioEffectMap(clone.effectChain);\n\n    clone.clones = [];\n    clone.parent = this;\n    this.clones.push(clone);\n\n    // Trigger CLONE_START:\n    const triggers = clone.triggers.filter(tr =>\n      tr.matches(Trigger.CLONE_START, {}, clone)\n    );\n    this._project._startTriggers(\n      triggers.map(trigger => ({ trigger, target: clone }))\n    );\n  }\n\n  deleteThisClone() {\n    if (this.parent === null) return;\n\n    this.parent.clones = this.parent.clones.filter(clone => clone !== this);\n\n    this._project.runningTriggers = this._project.runningTriggers.filter(\n      ({ target }) => target !== this\n    );\n  }\n\n  andClones() {\n    return [this, ...this.clones.flatMap(clone => clone.andClones())];\n  }\n\n  get direction() {\n    return this._direction;\n  }\n\n  set direction(dir) {\n    this._direction = this.normalizeDeg(dir);\n  }\n\n  goto(x, y) {\n    if (x === this.x && y === this.y) return;\n\n    if (this.penDown) {\n      this._project.renderer.penLine(\n        { x: this._x, y: this._y },\n        { x, y },\n        this._penColor,\n        this.penSize\n      );\n    }\n\n    this._x = x;\n    this._y = y;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  set x(x) {\n    this.goto(x, this._y);\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set y(y) {\n    this.goto(this._x, y);\n  }\n\n  move(dist) {\n    const moveDir = this.scratchToRad(this.direction);\n\n    this.goto(\n      this._x + dist * Math.cos(moveDir),\n      this._y + dist * Math.sin(moveDir)\n    );\n  }\n\n  *glide(seconds, x, y) {\n    const interpolate = (a, b, t) => a + (b - a) * t;\n\n    const startTime = new Date();\n    const startX = this._x;\n    const startY = this._y;\n\n    let t;\n    do {\n      t = (new Date() - startTime) / (seconds * 1000);\n      this.goto(interpolate(startX, x, t), interpolate(startY, y, t));\n      yield;\n    } while (t < 1);\n  }\n\n  get penDown() {\n    return this._penDown;\n  }\n\n  set penDown(penDown) {\n    if (penDown) {\n      this._project.renderer.penLine(\n        { x: this.x, y: this.y },\n        { x: this.x, y: this.y },\n        this._penColor,\n        this.penSize\n      );\n    }\n    this._penDown = penDown;\n  }\n\n  get penColor() {\n    return this._penColor;\n  }\n\n  set penColor(color) {\n    if (color instanceof Color) {\n      this._penColor = color;\n    } else {\n      console.error(\n        `${color} is not a valid penColor. Try using the Color class!`\n      );\n    }\n  }\n\n  stamp() {\n    this._project.renderer.stamp(this);\n  }\n\n  touching(target, fast = false) {\n    if (typeof target === \"string\") {\n      switch (target) {\n        case \"mouse\":\n          return this._project.renderer.checkPointCollision(\n            this,\n            {\n              x: this.mouse.x,\n              y: this.mouse.y\n            },\n            fast\n          );\n        case \"edge\": {\n          const bounds = this._project.renderer.getTightBoundingBox(this);\n          const stageWidth = this.stage.width;\n          const stageHeight = this.stage.height;\n          return (\n            bounds.left < -stageWidth / 2 ||\n            bounds.right > stageWidth / 2 ||\n            bounds.top > stageHeight / 2 ||\n            bounds.bottom < -stageHeight / 2\n          );\n        }\n        default:\n          console.error(\n            `Cannot find target \"${target}\" in \"touching\". Did you mean to pass a sprite class instead?`\n          );\n          return false;\n      }\n    } else if (target instanceof Color) {\n      return this._project.renderer.checkColorCollision(this, target);\n    }\n\n    return this._project.renderer.checkSpriteCollision(this, target, fast);\n  }\n\n  colorTouching(color, target) {\n    if (typeof target === \"string\") {\n      console.error(\n        `Cannot find target \"${target}\" in \"touchingColor\". Did you mean to pass a sprite class instead?`\n      );\n      return false;\n    }\n\n    if (typeof color === \"string\") {\n      console.error(\n        `Cannot find color \"${color}\" in \"touchingColor\". Did you mean to pass a Color instance instead?`\n      );\n      return false;\n    }\n\n    if (target instanceof Color) {\n      // \"Color is touching color\"\n      return this._project.renderer.checkColorCollision(this, target, color);\n    } else {\n      // \"Color is touching sprite\" (not implemented in Scratch!)\n      return this._project.renderer.checkSpriteCollision(\n        this,\n        target,\n        false,\n        color\n      );\n    }\n  }\n\n  say(text) {\n    clearTimeout(this._speechBubble.timeout);\n    this._speechBubble = { text: String(text), style: \"say\", timeout: null };\n  }\n\n  think(text) {\n    clearTimeout(this._speechBubble.timeout);\n    this._speechBubble = { text: String(text), style: \"think\", timeout: null };\n  }\n\n  *sayAndWait(text, seconds) {\n    clearTimeout(this._speechBubble.timeout);\n\n    let done = false;\n    const timeout = setTimeout(() => {\n      this._speechBubble.text = \"\";\n      this.timeout = null;\n      done = true;\n    }, seconds * 1000);\n\n    this._speechBubble = { text, style: \"say\", timeout };\n    while (!done) yield;\n  }\n\n  *thinkAndWait(text, seconds) {\n    clearTimeout(this._speechBubble.timeout);\n\n    let done = false;\n    const timeout = setTimeout(() => {\n      this._speechBubble.text = \"\";\n      this.timeout = null;\n      done = true;\n    }, seconds * 1000);\n\n    this._speechBubble = { text, style: \"think\", timeout };\n    while (!done) yield;\n  }\n}\n\nSprite.RotationStyle = Object.freeze({\n  ALL_AROUND: Symbol(\"ALL_AROUND\"),\n  LEFT_RIGHT: Symbol(\"LEFT_RIGHT\"),\n  DONT_ROTATE: Symbol(\"DONT_ROTATE\")\n});\n\nexport class Stage extends SpriteBase {\n  constructor(initialConditions, ...args) {\n    super(initialConditions, ...args);\n\n    // Use defineProperties to make these non-writable.\n    // Changing the width and height of the stage after initialization isn't supported.\n    Object.defineProperties(this, {\n      width: {\n        value: initialConditions.width || 480,\n        enumerable: true\n      },\n      height: {\n        value: initialConditions.height || 360,\n        enumerable: true\n      }\n    });\n\n    this.name = \"Stage\";\n\n    // For obsolete counter blocks.\n    this.__counter = 0;\n  }\n\n  fireBackdropChanged() {\n    return this._project.fireTrigger(Trigger.BACKDROP_CHANGED, {\n      backdrop: this.costume.name\n    });\n  }\n}\n","import Matrix from \"./Matrix.js\";\n\nimport Rectangle from \"./Rectangle.js\";\nimport effectTransformPoint from \"./effectTransformPoint.js\";\nimport { effectBitmasks } from \"./effectInfo.js\";\n\nimport { Sprite, Stage } from \"../Sprite.js\";\n\n// Returns the determinant of two vectors, the vector from A to B and the vector\n// from A to C. If positive, it means AC is counterclockwise from AB.\n// If negative, AC is clockwise from AB.\nconst determinant = (a, b, c) => {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n};\n\n// Used to track whether a sprite's transform has changed since we last looked\n// at it.\n// TODO: store renderer-specific data on the sprite and have *it* set a\n// \"transform changed\" flag.\nclass SpriteTransformDiff {\n  constructor(sprite) {\n    this._sprite = sprite;\n    this._unset = true;\n    this.update();\n  }\n\n  update() {\n    this._lastX = this._sprite.x;\n    this._lastY = this._sprite.y;\n    this._lastRotation = this._sprite.direction;\n    this._lastRotationStyle = this._sprite.rotationStyle;\n    this._lastSize = this._sprite.size;\n    this._lastCostume = this._sprite.costume;\n    this._lastCostumeLoaded = this._sprite.costume.img.complete;\n    this._unset = false;\n  }\n\n  get changed() {\n    return (\n      this._lastX !== this._sprite.x ||\n      this._lastY !== this._sprite.y ||\n      this._lastRotation !== this._sprite.direction ||\n      this._lastRotationStyle !== this._sprite.rotationStyle ||\n      this._lastSize !== this._sprite.size ||\n      this._lastCostume !== this._sprite.costume ||\n      this._lastCostumeLoaded !== this._sprite.costume.img.complete ||\n      this._unset\n    );\n  }\n}\n\n// Renderer-specific data for an instance (the original or a clone) of a Sprite\nexport default class Drawable {\n  constructor(renderer, sprite) {\n    this._renderer = renderer;\n    this._sprite = sprite;\n\n    // Transformation matrix for the sprite.\n    this._matrix = Matrix.create();\n    // Track when the sprite's transform changes so we can recalculate the\n    // transform matrix.\n    this._matrixDiff = new SpriteTransformDiff(sprite);\n    this._calculateSpriteMatrix();\n\n    // Track when the image data used to calculate the convex hull,\n    // or distortion effects that affect how it's drawn, change.\n    // We also need the image data to know how big the pixels are.\n    this._convexHullImageData = null;\n    this._convexHullMosaic = 0;\n    this._convexHullPixelate = 0;\n    this._convexHullWhirl = 0;\n    this._convexHullFisheye = 0;\n    this._convexHullPoints = null;\n\n    this._aabb = new Rectangle();\n    this._tightBoundingBox = new Rectangle();\n    // Track when the sprite's transform changes so we can recalculate the\n    // tight bounding box.\n    this._convexHullMatrixDiff = new SpriteTransformDiff(sprite);\n  }\n\n  getCurrentSkin() {\n    return this._renderer._getSkin(this._sprite.costume);\n  }\n\n  // Get the rough axis-aligned bounding box for this sprite. Not as tight as\n  // getTightBoundingBox, especially when rotated.\n  getAABB() {\n    return Rectangle.fromMatrix(this.getMatrix(), this._aabb);\n  }\n\n  // Get the Scratch-space tight bounding box for this sprite.\n  getTightBoundingBox() {\n    if (!this._convexHullMatrixDiff.changed) return this._tightBoundingBox;\n\n    const matrix = this.getMatrix();\n    const convexHullPoints = this._calculateConvexHull();\n    // Maybe the costume isn't loaded yet. Return a 0x0 bounding box around the\n    // center of the sprite.\n    if (convexHullPoints === null) {\n      return Rectangle.fromBounds(\n        this._sprite.x,\n        this._sprite.y,\n        this._sprite.x,\n        this._sprite.y,\n        this._tightBoundingBox\n      );\n    }\n\n    let left = Infinity;\n    let right = -Infinity;\n    let top = -Infinity;\n    let bottom = Infinity;\n    const transformedPoint = [0, 0];\n\n    // Each convex hull point is the center of a pixel. However, said pixels\n    // each have area. We must take into account the size of the pixels when\n    // calculating the bounds. The pixel dimensions depend on the scale and\n    // rotation (as we're treating pixels as squares, which change dimensions\n    // when rotated).\n    const xa = matrix[0] / 2;\n    const xb = matrix[3] / 2;\n    const halfPixelX =\n      (Math.abs(xa) + Math.abs(xb)) / this._convexHullImageData.width;\n    const ya = matrix[1] / 2;\n    const yb = matrix[4] / 2;\n    const halfPixelY =\n      (Math.abs(ya) + Math.abs(yb)) / this._convexHullImageData.height;\n\n    // Transform every point in the convex hull using our transform matrix,\n    // and expand the bounds to include that point.\n    for (let i = 0; i < convexHullPoints.length; i++) {\n      const point = convexHullPoints[i];\n      transformedPoint[0] = point[0];\n      transformedPoint[1] = 1 - point[1];\n      Matrix.transformPoint(matrix, transformedPoint, transformedPoint);\n\n      left = Math.min(left, transformedPoint[0] - halfPixelX);\n      right = Math.max(right, transformedPoint[0] + halfPixelX);\n      top = Math.max(top, transformedPoint[1] + halfPixelY);\n      bottom = Math.min(bottom, transformedPoint[1] - halfPixelY);\n    }\n\n    Rectangle.fromBounds(left, right, bottom, top, this._tightBoundingBox);\n    this._convexHullMatrixDiff.update();\n    return this._tightBoundingBox;\n  }\n\n  _calculateConvexHull() {\n    const sprite = this._sprite;\n    const skin = this.getCurrentSkin();\n    const imageData = skin.getImageData(\n      \"size\" in sprite ? sprite.size / 100 : 1\n    );\n    if (!imageData) return null;\n\n    // We only need to recalculate the convex hull points if the image data's\n    // changed since we last calculated the convex hull, or if the sprite's\n    // effects which distort its shape have changed.\n    const { mosaic, pixelate, whirl, fisheye } = sprite.effects;\n    if (\n      this._convexHullImageData === imageData &&\n      this._convexHullMosaic === mosaic &&\n      this._convexHullPixelate === pixelate &&\n      this._convexHullWhirl === whirl &&\n      this._convexHullFisheye === fisheye\n    ) {\n      return this._convexHullPoints;\n    }\n\n    const effectBitmask =\n      sprite.effects._bitmask &\n      (effectBitmasks.mosaic |\n        effectBitmasks.pixelate |\n        effectBitmasks.whirl |\n        effectBitmasks.fisheye);\n\n    const leftHull = [];\n    const rightHull = [];\n\n    const { width, height, data } = imageData;\n\n    const pixelPos = [0, 0];\n    const effectPos = [0, 0];\n    let currentPoint;\n    // Not Scratch-space: y increases as we go downwards\n    // Loop over all rows of pixels in the costume, starting at the top\n    for (let y = 0; y < height; y++) {\n      pixelPos[1] = (y + 0.5) / height;\n\n      // We start at the leftmost point, then go rightwards until we hit an\n      // opaque pixel\n      let x = 0;\n      for (; x < width; x++) {\n        pixelPos[0] = (x + 0.5) / width;\n        let pixelX = x;\n        let pixelY = y;\n        if (effectBitmask !== 0) {\n          effectTransformPoint(this, pixelPos, effectPos);\n          pixelX = Math.floor(effectPos[0] * width);\n          pixelY = Math.floor(effectPos[1] * height);\n        }\n        // We hit an opaque pixel\n        if (data[(pixelY * width + pixelX) * 4 + 3] > 0) {\n          currentPoint = [pixelPos[0], pixelPos[1]];\n          break;\n        }\n      }\n\n      // There are no opaque pixels on this row. Go to the next one.\n      if (x >= width) continue;\n\n      // If appending the current point to the left hull makes a\n      // counterclockwise turn, we want to append the current point to it.\n      // Otherwise, we remove hull points until the current point makes a\n      // counterclockwise turn with the last two points.\n      while (leftHull.length >= 2) {\n        if (\n          determinant(\n            leftHull[leftHull.length - 1],\n            leftHull[leftHull.length - 2],\n            currentPoint\n          ) > 0\n        ) {\n          break;\n        }\n\n        leftHull.pop();\n      }\n\n      leftHull.push(currentPoint);\n\n      // Now we repeat the process for the right side, looking leftwards for an\n      // opaque pixel.\n      for (x = width - 1; x >= 0; x--) {\n        pixelPos[0] = (x + 0.5) / width;\n        effectTransformPoint(this, pixelPos, effectPos);\n        let pixelX = x;\n        let pixelY = y;\n        if (effectBitmask !== 0) {\n          effectTransformPoint(this, pixelPos, effectPos);\n          pixelX = Math.floor(effectPos[0] * width);\n          pixelY = Math.floor(effectPos[1] * height);\n        }\n        // We hit an opaque pixel\n        if (data[(pixelY * width + pixelX) * 4 + 3] > 0) {\n          currentPoint = [pixelPos[0], pixelPos[1]];\n          break;\n        }\n      }\n\n      // Because we're coming at this from the right, it goes clockwise.\n      while (rightHull.length >= 2) {\n        if (\n          determinant(\n            rightHull[rightHull.length - 1],\n            rightHull[rightHull.length - 2],\n            currentPoint\n          ) < 0\n        ) {\n          break;\n        }\n\n        rightHull.pop();\n      }\n\n      rightHull.push(currentPoint);\n    }\n\n    // Add points from the right side in reverse order so all the points are\n    // clockwise.\n    for (let i = rightHull.length - 1; i >= 0; i--) {\n      leftHull.push(rightHull[i]);\n    }\n\n    this._convexHullPoints = leftHull;\n    this._convexHullMosaic = mosaic;\n    this._convexHullPixelate = pixelate;\n    this._convexHullWhirl = whirl;\n    this._convexHullFisheye = fisheye;\n    this._convexHullImageData = imageData;\n\n    return this._convexHullPoints;\n  }\n\n  _calculateSpriteMatrix() {\n    const m = this._matrix;\n    Matrix.identity(m);\n    const spr = this._sprite;\n    if (!(spr instanceof Stage)) {\n      Matrix.translate(m, m, spr.x, spr.y);\n      switch (spr.rotationStyle) {\n        case Sprite.RotationStyle.ALL_AROUND: {\n          Matrix.rotate(m, m, spr.scratchToRad(spr.direction));\n          break;\n        }\n        case Sprite.RotationStyle.LEFT_RIGHT: {\n          if (spr.direction < 0) Matrix.scale(m, m, -1, 1);\n          break;\n        }\n      }\n\n      const spriteScale = spr.size / 100;\n      Matrix.scale(m, m, spriteScale, spriteScale);\n    }\n\n    const scalingFactor = 1 / spr.costume.resolution;\n    // Rotation centers are in non-Scratch space (positive y-values = down),\n    // but these transforms are in Scratch space (negative y-values = down).\n    Matrix.translate(\n      m,\n      m,\n      -spr.costume.center.x * scalingFactor,\n      (spr.costume.center.y - spr.costume.height) * scalingFactor\n    );\n    Matrix.scale(\n      m,\n      m,\n      spr.costume.width * scalingFactor,\n      spr.costume.height * scalingFactor\n    );\n\n    // Store the values we used to compute the matrix so we only recalculate\n    // the matrix when we really need to.\n    this._matrixDiff.update();\n  }\n\n  getMatrix() {\n    // If all the values we used to calculate the matrix haven't changed since\n    // we last calculated the matrix, we can just return the matrix as-is.\n    if (this._matrixDiff.changed) {\n      this._calculateSpriteMatrix();\n    }\n\n    return this._matrix;\n  }\n}\n","export default class Skin {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n  }\n\n  // Get the skin's texture for a given (screen-space) scale.\n  /* eslint-disable-next-line no-unused-vars */\n  getTexture(scale) {\n    return null;\n  }\n\n  // Get the skin image's ImageData at a given (screen-space) scale.\n  // eslint-disable-next-line no-unused-vars\n  getImageData(scale) {\n    throw new Error(\"getImageData not implemented for this skin type\");\n  }\n\n  // Helper function to create a texture from an image and handle all the boilerplate.\n  _makeTexture(image, filtering) {\n    const gl = this.gl;\n    const glTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, glTexture);\n    // These need to be set because most sprite textures don't have power-of-two dimensions.\n    // Non-power-of-two textures only work with gl.CLAMP_TO_EDGE wrapping behavior,\n    // and because they don't support automatic mipmaps, can only use non-mipmap texture filtering.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\n    if (image)\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        image\n      );\n\n    return glTexture;\n  }\n\n  // Helper function to set this skin's size based on an image that may or may not be loaded.\n  _setSizeFromImage(image) {\n    if (image.complete) {\n      this.width = image.naturalWidth;\n      this.height = image.naturalHeight;\n    } else {\n      image.addEventListener(\"load\", () => {\n        this.width = image.naturalWidth;\n        this.height = image.naturalHeight;\n      });\n    }\n  }\n\n  // Clean up any textures or other objets created by this skin.\n  destroy() {}\n}\n","import Skin from \"./Skin.js\";\n\nexport default class BitmapSkin extends Skin {\n  constructor(renderer, image) {\n    super(renderer);\n\n    this._image = image;\n    this._imageData = null;\n    this._texture = null;\n\n    this._setSizeFromImage(image);\n  }\n\n  getImageData() {\n    // Make sure to handle potentially non-loaded textures\n    if (!this._image.complete) return null;\n\n    if (!this._imageData) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = this._image.naturalWidth || this._image.width;\n      canvas.height = this._image.naturalHeight || this._image.height;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(this._image, 0, 0);\n      // Cache image data so we can reuse it\n      this._imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    return this._imageData;\n  }\n\n  getTexture() {\n    // Make sure to handle potentially non-loaded textures\n    const image = this._image;\n    if (!image.complete) return null;\n\n    if (this._texture === null) {\n      // Use nearest-neighbor (i.e. blocky) texture filtering for bitmaps\n      this._texture = super._makeTexture(image, this.gl.NEAREST);\n    }\n    return this._texture;\n  }\n\n  destroy() {\n    if (this._texture !== null) this.gl.deleteTexture(this._texture);\n  }\n}\n","const SpriteShader = {};\n\nSpriteShader.vertex = `\nprecision mediump float;\n\nattribute vec2 a_position;\nuniform mat3 u_transform;\nuniform vec2 u_stageSize;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n  v_texCoord = vec2(a_position.x, 1.0 - a_position.y);\n  gl_Position = vec4((u_transform * vec3(a_position, 1.0)) / vec3(u_stageSize * 0.5, 1.0), 1.0);\n}\n`;\n\nSpriteShader.fragment = `\nprecision mediump float;\n\nconst float epsilon = 1e-3;\n\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\n\n#ifdef EFFECT_color\nuniform float u_color;\n#endif\n\n#ifdef EFFECT_fisheye\nuniform float u_fisheye;\n#endif\n\n#ifdef EFFECT_whirl\nuniform float u_whirl;\n#endif\n\n#ifdef EFFECT_pixelate\nuniform float u_pixelate;\nuniform vec2 u_skinSize;\n#endif\n\n#ifdef EFFECT_mosaic\nuniform float u_mosaic;\n#endif\n\n#ifdef EFFECT_brightness\nuniform float u_brightness;\n#endif\n\n#ifdef EFFECT_ghost\nuniform float u_ghost;\n#endif\n\n#if defined(EFFECT_whirl) || defined(EFFECT_fisheye) || defined(EFFECT_pixelate)\nconst vec2 CENTER = vec2(0.5, 0.5);\n#endif\n\n#ifdef DRAW_MODE_COLOR_MASK\nuniform vec4 u_colorMask;\n\n// TODO: Scratch 2.0 and Scratch 3.0's CPU path check if the top 6 bits match,\n// which a tolerance of 3/255 should be equivalent to,\n// but Scratch's GPU path has a tolerance of 2/255.\nconst vec3 COLOR_MASK_TOLERANCE = vec3(3.0 / 255.0);\n#endif\n\n#ifdef DRAW_MODE_SPRITE_ID\nuniform vec3 u_spriteId;\n#endif\n\n#ifdef EFFECT_color\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n#endif\n\nvoid main() {\n  vec2 coord = v_texCoord;\n\n  #ifdef EFFECT_mosaic\n  {\n    float mosaicFactor = clamp(floor(abs(u_mosaic + 10.0) / 10.0 + 0.5), 1.0, 512.0);\n    coord = fract(coord * mosaicFactor);\n  }\n  #endif\n\n  #ifdef EFFECT_pixelate\n    vec2 pixSize = u_skinSize / (abs(u_pixelate) * 0.1);\n    coord = (floor(coord * pixSize) + CENTER) / pixSize;\n  #endif\n\n  #ifdef EFFECT_whirl\n  {\n    const float PI_OVER_180 = 0.017453292519943295;\n    vec2 offset = coord - CENTER;\n    float whirlFactor = max(1.0 - (length(offset) * 2.0), 0.0);\n    float whirl = (-u_whirl * PI_OVER_180) * whirlFactor * whirlFactor;\n    float s = sin(whirl);\n    float c = cos(whirl);\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n    coord = rotationMatrix * offset + CENTER;\n  }\n  #endif\n\n  #ifdef EFFECT_fisheye\n  {\n    vec2 vec = (coord - CENTER) / CENTER;\n    float len = length(vec) + epsilon;\n    float factor = max(0.0, (u_fisheye + 100.0) / 100.0);\n    float r = pow(min(len, 1.0), factor) * max(1.0, len);\n    vec2 unit = vec / len;\n    coord = CENTER + (r * unit * CENTER);\n  }\n  #endif\n\n  vec4 color = texture2D(u_texture, coord);\n\n  #if defined(EFFECT_color) || defined(EFFECT_brightness)\n  // Un-premultiply color values by alpha channel\n  vec3 unmul = color.rgb / color.a;\n\n  #ifdef EFFECT_color\n  {\n    vec3 hsv = rgb2hsv(unmul);\n    const float minLightness = 0.11 / 2.0;\n    const float minSaturation = 0.09;\n\n    hsv.z = max(minLightness, hsv.z);\n    hsv.y = max(minSaturation, hsv.y);\n\n    hsv.x = mod(hsv.x + (u_color / 200.0), 1.0);\n\n    unmul = hsv2rgb(hsv);\n  }\n  #endif\n\n  #ifdef EFFECT_brightness\n  {\n    unmul = clamp(unmul + clamp(u_brightness * 0.01, -1.0, 1.0), 0.0, 1.0);\n  }\n  #endif\n\n  color = vec4(unmul * color.a, color.a);\n\n  #endif // defined(defined(EFFECT_color) || defined(EFFECT_brightness))\n\n  #ifdef DRAW_MODE_COLOR_MASK\n  vec3 diff = abs(u_colorMask.rgb - color.rgb);\n  if (any(greaterThan(diff, COLOR_MASK_TOLERANCE))) {\n    discard;\n  }\n  #endif\n\n  #ifdef EFFECT_ghost\n  color *= (1.0 - clamp(u_ghost * 0.01, 0.0, 1.0));\n  #endif\n\n  #ifdef DRAW_MODE_SILHOUETTE\n  if (color.a == 0.0) {\n    discard;\n  }\n  #endif\n\n  #ifdef DRAW_MODE_SPRITE_ID\n  color = color.a > 0.0 ? vec4(u_spriteId, 1.0) : vec4(0.0, 0.0, 0.0, 0.0);\n  #endif\n\n  gl_FragColor = color;\n}\n`;\n\nconst PenLineShader = {};\n\nPenLineShader.vertex = `\nprecision mediump float;\n\nattribute vec2 a_position;\n// The X and Y components of u_penPoints hold the first pen point. The Z and W components hold the difference between\n// the second pen point and the first. This is done because calculating the difference in the shader leads to floating-\n// point error when both points have large-ish coordinates.\nuniform vec4 u_penPoints;\nuniform vec2 u_penSkinSize;\nuniform float u_penSize;\nuniform float u_lineLength;\n\nvarying vec2 v_texCoord;\n\n// Add this to divisors to prevent division by 0, which results in NaNs propagating through calculations.\n// Smaller values can cause problems on some mobile devices.\nconst float epsilon = 1e-3;\n\nvoid main() {\n  // Calculate a rotated (\"tight\") bounding box around the two pen points.\n  // Yes, we're doing this 6 times (once per vertex), but on actual GPU hardware,\n  // it's still faster than doing it in JS combined with the cost of uniformMatrix4fv.\n\n  // Expand line bounds by sqrt(2) / 2 each side-- this ensures that all antialiased pixels\n  // fall within the quad, even at a 45-degree diagonal\n  vec2 position = a_position;\n  float expandedRadius = (u_penSize * 0.5) + 1.4142135623730951;\n\n  // The X coordinate increases along the length of the line. It's 0 at the center of the origin point\n  // and is in pixel-space (so at n pixels along the line, its value is n).\n  v_texCoord.x = mix(0.0, u_lineLength + (expandedRadius * 2.0), a_position.x) - expandedRadius;\n  // The Y coordinate is perpendicular to the line. It's also in pixel-space.\n  v_texCoord.y = ((a_position.y - 0.5) * expandedRadius) + 0.5;\n\n  position.x *= u_lineLength + (2.0 * expandedRadius);\n  position.y *= 2.0 * expandedRadius;\n\n  // 1. Center around first pen point\n  position -= expandedRadius;\n\n  // 2. Rotate quad to line angle\n  vec2 pointDiff = u_penPoints.zw;\n  // Ensure line has a nonzero length so it's rendered properly\n  // As long as either component is nonzero, the line length will be nonzero\n  // If the line is zero-length, give it a bit of horizontal length\n  pointDiff.x = (abs(pointDiff.x) < epsilon && abs(pointDiff.y) < epsilon) ? epsilon : pointDiff.x;\n  // The 'normalized' vector holds rotational values equivalent to sine/cosine\n  // We're applying the standard rotation matrix formula to the position to rotate the quad to the line angle\n  // pointDiff can hold large values so we must divide by u_lineLength instead of calling GLSL's normalize function:\n  // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\n  vec2 normalized = pointDiff / max(u_lineLength, epsilon);\n  position = mat2(normalized.x, normalized.y, -normalized.y, normalized.x) * position;\n\n  // 3. Translate quad\n  position += u_penPoints.xy;\n\n  // 4. Apply view transform\n  position *= 2.0 / u_penSkinSize;\n  gl_Position = vec4(position, 0, 1);\n}\n`;\n\nPenLineShader.fragment = `\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_penPoints;\nuniform vec4 u_penColor;\nuniform float u_penSize;\nuniform float u_lineLength;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  // Maaaaagic antialiased-line-with-round-caps shader.\n\n\t// \"along-the-lineness\". This increases parallel to the line.\n\t// It goes from negative before the start point, to 0.5 through the start to the end, then ramps up again\n\t// past the end point.\n\tfloat d = ((v_texCoord.x - clamp(v_texCoord.x, 0.0, u_lineLength)) * 0.5) + 0.5;\n\n\t// Distance from (0.5, 0.5) to (d, the perpendicular coordinate). When we're in the middle of the line,\n\t// d will be 0.5, so the distance will be 0 at points close to the line and will grow at points further from it.\n\t// For the \"caps\", d will ramp down/up, giving us rounding.\n\t// See https://www.youtube.com/watch?v=PMltMdi1Wzg for a rough outline of the technique used to round the lines.\n\tfloat line = distance(vec2(0.5), vec2(d, v_texCoord.y)) * 2.0;\n\t// Expand out the line by its thickness.\n\tline -= ((u_penSize - 1.0) * 0.5);\n\t// Because \"distance to the center of the line\" decreases the closer we get to the line, but we want more opacity\n\t// the closer we are to the line, invert it.\n\tgl_FragColor = u_penColor * clamp(1.0 - line, 0.0, 1.0);\n}\n`;\n\nexport { SpriteShader, PenLineShader };\n","import { SpriteShader, PenLineShader } from \"./Shaders.js\";\nimport { effectNames, effectBitmasks } from \"./effectInfo.js\";\n\n// Everything contained in a shader. It contains both the program, and the locations of the shader inputs.\nclass Shader {\n  constructor(gl, program) {\n    this.gl = gl;\n    this.program = program;\n    this.uniforms = {};\n    this.attribs = {};\n\n    // In order to pass a value into a shader as an attribute or uniform, you need to know its location.\n    // This maps the names of attributes and uniforms to their locations, accessible via the `uniforms` and `attribs`\n    // properties.\n    const numActiveUniforms = gl.getProgramParameter(\n      program,\n      gl.ACTIVE_UNIFORMS\n    );\n    for (let i = 0; i < numActiveUniforms; i++) {\n      const { name } = gl.getActiveUniform(program, i);\n      this.uniforms[name] = gl.getUniformLocation(program, name);\n    }\n\n    const numActiveAttributes = gl.getProgramParameter(\n      program,\n      gl.ACTIVE_ATTRIBUTES\n    );\n    for (let i = 0; i < numActiveAttributes; i++) {\n      const { name } = gl.getActiveAttrib(program, i);\n      this.attribs[name] = gl.getAttribLocation(program, name);\n    }\n  }\n}\n\nclass ShaderManager {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n\n    // We compile shaders on-demand. Create one shader cache per draw mode.\n    this._shaderCache = {};\n    for (const drawMode of Object.keys(ShaderManager.DrawModes)) {\n      this._shaderCache[drawMode] = new Map();\n    }\n  }\n\n  // Creates and compiles a vertex or fragment shader from the given source code.\n  _createShader(source, type) {\n    const gl = this.gl;\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      const info = gl.getShaderInfoLog(shader);\n      throw \"Could not compile WebGL program. \\n\" + info;\n    }\n\n    return shader;\n  }\n\n  getShader(drawMode, effectBitmask = 0) {\n    const gl = this.gl;\n    // Each combination of enabled effects is compiled to a different shader, with only the needed effect code.\n    // Check if we've already compiled the shader with this set of enabled effects.\n    const shaderMap = this._shaderCache[drawMode];\n    if (shaderMap.has(effectBitmask)) {\n      return shaderMap.get(effectBitmask);\n    } else {\n      let shaderCode;\n      switch (drawMode) {\n        case ShaderManager.DrawModes.PEN_LINE: {\n          shaderCode = PenLineShader;\n          break;\n        }\n        default: {\n          shaderCode = SpriteShader;\n          break;\n        }\n      }\n\n      // Use #define statements for conditional compilation in shader code.\n      let define = `#define DRAW_MODE_${drawMode}\\n`;\n\n      // Add #defines for each enabled effect.\n      for (let i = 0; i < effectNames.length; i++) {\n        const effectName = effectNames[i];\n        if ((effectBitmask & effectBitmasks[effectName]) !== 0) {\n          define += `#define EFFECT_${effectName}\\n`;\n        }\n      }\n\n      const vertShader = this._createShader(\n        define + shaderCode.vertex,\n        gl.VERTEX_SHADER\n      );\n      const fragShader = this._createShader(\n        define + shaderCode.fragment,\n        gl.FRAGMENT_SHADER\n      );\n\n      // Combine the vertex and fragment shaders into a single GL program.\n      const program = gl.createProgram();\n      gl.attachShader(program, vertShader);\n      gl.attachShader(program, fragShader);\n      gl.linkProgram(program);\n\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        const info = gl.getProgramInfoLog(program);\n        throw new Error(\"Could not compile WebGL program. \\n\" + info);\n      }\n\n      const shader = new Shader(gl, program);\n      shaderMap.set(effectBitmask, shader);\n      return shader;\n    }\n  }\n}\n\nShaderManager.DrawModes = {\n  // Used for drawing sprites normally\n  DEFAULT: \"DEFAULT\",\n  // Used for \"touching\" tests. Discards transparent pixels.\n  SILHOUETTE: \"SILHOUETTE\",\n  // Used for \"color is touching color\" tests. Only renders sprite colors which are close to the color passed in, and\n  // discards all pixels of a different color.\n  COLOR_MASK: \"COLOR_MASK\",\n  // Used for picking the topmost sprite and identifying which one it is.\n  // Assigns a color to each sprite.\n  SPRITE_ID: \"SPRITE_ID\",\n  // Used for drawing pen lines.\n  PEN_LINE: \"PEN_LINE\"\n};\n\nexport default ShaderManager;\n","import Skin from \"./Skin.js\";\nimport ShaderManager from \"./ShaderManager.js\";\n\nexport default class PenSkin extends Skin {\n  constructor(renderer, width, height) {\n    super(renderer);\n    this.width = width;\n    this.height = height;\n\n    const framebufferInfo = renderer._createFramebufferInfo(\n      width,\n      height,\n      this.gl.NEAREST\n    );\n    this._framebufferInfo = framebufferInfo;\n\n    this._lastPenState = {\n      size: 0,\n      color: [0, 0, 0, 0]\n    };\n\n    this.clear();\n  }\n\n  destroy() {\n    const gl = this.gl;\n    gl.deleteTexture(this._framebufferInfo.texture);\n    gl.deleteFramebuffer(this._framebufferInfo.framebuffer);\n  }\n\n  getTexture() {\n    return this._framebufferInfo.texture;\n  }\n\n  penLine(pt1, pt2, color, size) {\n    const renderer = this.renderer;\n    renderer._setFramebuffer(this._framebufferInfo);\n\n    const shader = renderer._shaderManager.getShader(\n      ShaderManager.DrawModes.PEN_LINE\n    );\n\n    const gl = this.gl;\n\n    // Set the shader, and check if it actually changed.\n    const shaderChanged = renderer._setShader(shader);\n\n    // These uniforms only need to be set if the shader actually changed.\n    if (shaderChanged) {\n      gl.uniform2f(shader.uniforms.u_penSkinSize, this.width, this.height);\n    }\n\n    // Only set the pen color if it changed or the shader changed.\n    const penColor = color.toRGBANormalized();\n    const oldColor = this._lastPenState.color;\n    if (\n      shaderChanged ||\n      penColor[0] !== oldColor[0] ||\n      penColor[1] !== oldColor[1] ||\n      penColor[2] !== oldColor[2] ||\n      penColor[3] !== oldColor[3]\n    ) {\n      this._lastPenState.color = penColor;\n      gl.uniform4f(\n        shader.uniforms.u_penColor,\n        penColor[0] * penColor[3],\n        penColor[1] * penColor[3],\n        penColor[2] * penColor[3],\n        penColor[3]\n      );\n    }\n\n    // Only set the pen size if it changed or the shader changed.\n    if (shaderChanged || this._lastPenState.size !== size) {\n      this._lastPenState.size = size;\n      gl.uniform1f(shader.uniforms.u_penSize, size);\n    }\n\n    const lineDiffX = pt2.x - pt1.x;\n    const lineDiffY = pt2.y - pt1.y;\n\n    // Offset pen lines of size 1 and 3 so they lie on integer coords.\n    // https://github.com/LLK/scratch-render/blob/791b2750cef140e714b002fd275b5f8434e6df9b/src/PenSkin.js#L167-L170\n    const offset = size === 1 || size === 3 ? 0.5 : 0;\n\n    gl.uniform4f(\n      shader.uniforms.u_penPoints,\n      pt1.x + offset,\n      pt1.y + offset,\n      lineDiffX,\n      lineDiffY\n    );\n\n    // Fun fact: Doing this calculation in the shader has the potential to overflow the floating-point range.\n    // 'mediump' precision is only required to have a range up to 2^14 (16384), so any lines longer than 2^7 (128)\n    // can overflow that, because you're squaring the operands, and they could end up as \"infinity\".\n    // Even GLSL's `length` function won't save us here:\n    // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\n    const lineLength = Math.sqrt(lineDiffX * lineDiffX + lineDiffY * lineDiffY);\n    gl.uniform1f(shader.uniforms.u_lineLength, lineLength);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  clear() {\n    this.renderer._setFramebuffer(this._framebufferInfo);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n  }\n}\n","import Skin from \"./Skin.js\";\n\nconst bubbleStyle = {\n  maxLineWidth: 170,\n  minWidth: 50,\n  strokeWidth: 4,\n  padding: 12,\n  tailHeight: 12\n};\n\n// TODO: multiline speech bubbles\nexport default class SpeechBubbleSkin extends Skin {\n  constructor(renderer, bubble) {\n    super(renderer);\n\n    this._canvas = document.createElement(\"canvas\");\n    this._texture = this._makeTexture(null, this.gl.LINEAR);\n    this._bubble = bubble;\n    this._flipped = false;\n    this._rendered = false;\n    this._renderedScale = 0;\n\n    this.width = 0;\n    this.height = 0;\n    this.offsetX = -bubbleStyle.strokeWidth / 2;\n    this.offsetY = this.offsetX + bubbleStyle.tailHeight;\n\n    this._renderBubble(this._bubble);\n  }\n\n  // To ensure proper text measurement and drawing, it's necessary to restyle the canvas after resizing it.\n  _restyleCanvas() {\n    const ctx = this._canvas.getContext(\"2d\");\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"hanging\";\n  }\n\n  set flipped(flipped) {\n    this._flipped = flipped;\n    this._rendered = false;\n  }\n\n  _renderBubble(bubble, scale) {\n    const canvas = this._canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    const renderBubbleBackground = (x, y, w, h, r, style) => {\n      if (r > w / 2) r = w / 2;\n      if (r > h / 2) r = h / 2;\n      if (r < 0) return;\n\n      ctx.beginPath();\n      ctx.moveTo(x + r, y);\n      ctx.arcTo(x + w, y, x + w, y + h, r);\n      ctx.arcTo(x + w, y + h, x + r, y + h, r);\n      if (style === \"say\") {\n        ctx.lineTo(Math.min(x + 3 * r, x + w - r), y + h);\n        ctx.lineTo(x + r / 2, y + h + r);\n        ctx.lineTo(x + r, y + h);\n      } else if (style === \"think\") {\n        ctx.ellipse(x + r * 2.25, y + h, (r * 3) / 4, r / 2, 0, 0, Math.PI);\n      }\n      ctx.arcTo(x, y + h, x, y, r);\n      ctx.arcTo(x, y, x + w, y, r);\n      ctx.closePath();\n      ctx.stroke();\n      ctx.fill();\n\n      if (style === \"think\") {\n        ctx.beginPath();\n        ctx.ellipse(\n          x + r,\n          y + h + (r * 3) / 4,\n          r / 3,\n          r / 3,\n          0,\n          0,\n          2 * Math.PI\n        );\n        ctx.stroke();\n        ctx.fill();\n      }\n    };\n\n    this._restyleCanvas();\n\n    const { text, style } = bubble;\n    const textWidth = ctx.measureText(text).width;\n\n    const maxWidth = bubbleStyle.maxLineWidth;\n    const padding = bubbleStyle.padding;\n\n    const width = Math.ceil(Math.min(textWidth, maxWidth) + 2 * padding);\n    const height = 10 + 2 * padding;\n\n    this.width = width + bubbleStyle.strokeWidth;\n    this.height = height + bubbleStyle.tailHeight + bubbleStyle.strokeWidth;\n\n    canvas.width = this.width * scale;\n    canvas.height = this.height * scale;\n\n    this._restyleCanvas();\n\n    const x = bubbleStyle.strokeWidth / 2;\n    const y = x;\n\n    ctx.setTransform(scale, 0, 0, scale, 0, 0);\n\n    ctx.fillStyle = \"#fff\";\n    ctx.strokeStyle = \"#ccc\";\n    ctx.lineWidth = bubbleStyle.strokeWidth;\n    ctx.save();\n    if (this._flipped) {\n      ctx.scale(-1, 1);\n      ctx.translate(-this.width, 0);\n    }\n    renderBubbleBackground(x, y, width, height, bubbleStyle.tailHeight, style);\n    ctx.restore();\n\n    ctx.fillStyle = \"#444\";\n    ctx.fillText(text, x + padding, y + padding, maxWidth);\n\n    this._rendered = true;\n    this._renderedScale = scale;\n  }\n\n  getTexture(scale) {\n    if (!this._rendered || this._renderedScale !== scale) {\n      this._renderBubble(this._bubble, scale);\n      const gl = this.gl;\n      gl.bindTexture(gl.TEXTURE_2D, this._texture);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        this._canvas\n      );\n    }\n\n    return this._texture;\n  }\n\n  destroy() {\n    this.gl.deleteTexture(this._texture);\n  }\n}\n","import Skin from \"./Skin.js\";\n\n// This means that the smallest mipmap will be 1/(2**4)th the size of the sprite's \"100%\" size.\nconst MIPMAP_OFFSET = 4;\n\nexport default class VectorSkin extends Skin {\n  constructor(renderer, image) {\n    super(renderer);\n\n    this._image = image;\n    this._canvas = document.createElement(\"canvas\");\n\n    this._imageDataMipLevel = 0;\n    this._imageData = null;\n\n    this._maxTextureSize = renderer.gl.getParameter(\n      renderer.gl.MAX_TEXTURE_SIZE\n    );\n\n    this._setSizeFromImage(image);\n\n    this._mipmaps = new Map();\n  }\n\n  static mipLevelForScale(scale) {\n    return Math.max(Math.ceil(Math.log2(scale)) + MIPMAP_OFFSET, 0);\n  }\n\n  getImageData(scale) {\n    if (!this._image.complete) return null;\n\n    // Round off the scale of the image data drawn to a given power-of-two mip level.\n    const mipLevel = VectorSkin.mipLevelForScale(scale);\n    if (!this._imageData || this._imageDataMipLevel !== mipLevel) {\n      const canvas = this._drawSvgToCanvas(mipLevel);\n      if (canvas === null) return null;\n\n      // Cache image data so we can reuse it\n      this._imageData = canvas\n        .getContext(\"2d\")\n        .getImageData(0, 0, canvas.width, canvas.height);\n      this._imageDataMipLevel = mipLevel;\n    }\n\n    return this._imageData;\n  }\n\n  _drawSvgToCanvas(mipLevel) {\n    const scale = 2 ** (mipLevel - MIPMAP_OFFSET);\n\n    const image = this._image;\n    let width = image.naturalWidth * scale;\n    let height = image.naturalHeight * scale;\n\n    width = Math.round(Math.min(width, this._maxTextureSize));\n    height = Math.round(Math.min(height, this._maxTextureSize));\n\n    // Prevent IndexSizeErrors if the image is too small to render\n    if (width === 0 || height === 0) {\n      return null;\n    }\n\n    // Instead of uploading the image to WebGL as a texture, render the image to a canvas and upload the canvas.\n    const canvas = this._canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    canvas.width = width;\n    canvas.height = height;\n\n    ctx.drawImage(image, 0, 0, width, height);\n    return this._canvas;\n  }\n\n  // TODO: handle proper subpixel positioning when SVG viewbox has non-integer coordinates\n  // This will require rethinking costume + project loading probably\n  _createMipmap(mipLevel) {\n    // Instead of uploading the image to WebGL as a texture, render the image to a canvas and upload the canvas.\n    const canvas = this._drawSvgToCanvas(mipLevel);\n    this._mipmaps.set(\n      mipLevel,\n      // Use linear (i.e. smooth) texture filtering for vectors\n      // If the image is 0x0, we return null. Check for that.\n      canvas === null ? null : this._makeTexture(canvas, this.gl.LINEAR)\n    );\n  }\n\n  getTexture(scale) {\n    if (!this._image.complete) return null;\n\n    // Because WebGL doesn't support vector graphics, substitute a bunch of bitmaps.\n    // This skin contains several renderings of its image at different scales.\n    // We render the SVG at 0.5x scale, 1x scale, 2x scale, 4x scale, etc. and store those as textures,\n    // so we can use the properly-sized texture for whatever scale we're currently rendering at.\n    // Math.ceil(Math.log2(scale)) means we use the \"2x\" texture at 1x-2x scale, the \"4x\" texture at 2x-4x scale, etc.\n    // This means that one texture pixel will always be between 0.5x and 1x the size of one rendered pixel,\n    // but never bigger than one rendered pixel--this prevents blurriness from blowing up the texture too much.\n    const mipLevel = VectorSkin.mipLevelForScale(scale);\n    if (!this._mipmaps.has(mipLevel)) this._createMipmap(mipLevel);\n\n    return this._mipmaps.get(mipLevel);\n  }\n\n  destroy() {\n    for (const mip of this._mipmaps.values()) {\n      this.gl.deleteTexture(mip);\n    }\n  }\n}\n","export default class Costume {\n  constructor(name, url, center = { x: 0, y: 0 }) {\n    this.name = name;\n    this.url = url;\n\n    this.img = new Image();\n    this.img.crossOrigin = \"Anonymous\";\n    this.img.src = this.url;\n\n    // TODO: this is super janky, but fixing this fully requires restructuring costume loading\n    this.isBitmap = !this.url.match(/\\.svg/);\n    this.resolution = this.isBitmap ? 2 : 1;\n\n    this.center = center;\n  }\n\n  get width() {\n    return this.img.naturalWidth;\n  }\n\n  get height() {\n    return this.img.naturalHeight;\n  }\n}\n","import Matrix from \"./renderer/Matrix.js\";\nimport Drawable from \"./renderer/Drawable.js\";\nimport BitmapSkin from \"./renderer/BitmapSkin.js\";\nimport PenSkin from \"./renderer/PenSkin.js\";\nimport SpeechBubbleSkin from \"./renderer/SpeechBubbleSkin.js\";\nimport VectorSkin from \"./renderer/VectorSkin.js\";\nimport Rectangle from \"./renderer/Rectangle.js\";\nimport ShaderManager from \"./renderer/ShaderManager.js\";\nimport { effectNames, effectBitmasks } from \"./renderer/effectInfo.js\";\n\nimport Costume from \"./Costume.js\";\n\n// Rectangle used for checking collision bounds.\n// Rather than create a new one each time, we can just reuse this one.\nconst __collisionBox = new Rectangle();\n\n// Convert a sprite ID/index number to a 24-bit color. The lowest 8 bits are\n// stored in the blue channel, then green, then red.\n// RGB [0, 0, 0] is reserved for \"no sprite here\".\n// This allows for up to 2^24 - 2 different sprites to be rendered at once.\nconst idToColor = id => [\n  (((id + 1) >> 16) & 0xff) / 255,\n  (((id + 1) >> 8) & 0xff) / 255,\n  ((id + 1) & 0xff) / 255\n];\n\n// Convert a 24-bit color back into a sprite ID/index number.\n// -1 means \"no sprite here\".\nconst colorToId = ([r, g, b]) => ((r << 16) | (g << 8) | b) - 1;\n\nexport default class Renderer {\n  constructor(project, renderTarget) {\n    const w = project.stage.width;\n    const h = project.stage.height;\n    this.project = project;\n    this.stage = this.createStage(w, h);\n    this.gl = this.stage.getContext(\"webgl\", { antialias: false });\n\n    if (renderTarget) {\n      this.setRenderTarget(renderTarget);\n    } else {\n      this.renderTarget = null;\n    }\n\n    this._shaderManager = new ShaderManager(this);\n    this._drawables = new WeakMap();\n    this._skins = new WeakMap();\n\n    this._currentShader = null;\n    this._currentFramebuffer = null;\n    this._screenSpaceScale = 1;\n\n    // Initialize a bunch of WebGL state\n    const gl = this.gl;\n\n    // Use premultiplied alpha for proper color blending.\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n    // Initialize vertex buffer. This will draw one 2D quadrilateral.\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n    // These are 6 points which make up 2 triangles which make up 1 quad/rectangle.\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      // Prettier mangles the formatting here but every 2 array values make one (x, y) pair\n      // and every 6 values make one triangle\n      new Float32Array([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]),\n      gl.STATIC_DRAW\n    );\n\n    // Set the active texture unit to 0.\n    gl.activeTexture(gl.TEXTURE0);\n\n    this._penSkin = new PenSkin(this, w, h);\n\n    // This framebuffer is where sprites are drawn for e.g. \"touching\" checks.\n    this._collisionBuffer = this._createFramebufferInfo(\n      w,\n      h,\n      gl.NEAREST,\n      true // stencil\n    );\n  }\n\n  // Retrieve a given object (e.g. costume or speech bubble)'s skin. If it doesn't exist, make one.\n  _getSkin(obj) {\n    if (this._skins.has(obj)) {\n      return this._skins.get(obj);\n    }\n\n    let skin;\n\n    if (obj instanceof Costume) {\n      if (obj.isBitmap) {\n        skin = new BitmapSkin(this, obj.img);\n      } else {\n        skin = new VectorSkin(this, obj.img);\n      }\n    } else {\n      // If it's not a costume, assume it's a speech bubble.\n      skin = new SpeechBubbleSkin(this, obj);\n    }\n    this._skins.set(obj, skin);\n    return skin;\n  }\n\n  // Retrieve the renderer-specific data object for a given sprite or clone. If it doesn't exist, make one.\n  _getDrawable(sprite) {\n    if (this._drawables.has(sprite)) {\n      return this._drawables.get(sprite);\n    }\n    const drawable = new Drawable(this, sprite);\n    this._drawables.set(sprite, drawable);\n    return drawable;\n  }\n\n  // Create a framebuffer info object, which contains the following:\n  // * The framebuffer itself.\n  // * The texture backing the framebuffer.\n  // * The resolution (width and height) of the framebuffer.\n  _createFramebufferInfo(width, height, filtering, stencil = false) {\n    // Create an empty texture with this skin's dimensions.\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      null\n    );\n\n    // Create a framebuffer backed by said texture. This means we can draw onto the framebuffer,\n    // and the results appear in the texture.\n    const framebufferInfo = {\n      texture,\n      width,\n      height,\n      framebuffer: gl.createFramebuffer()\n    };\n    this._setFramebuffer(framebufferInfo);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n\n    // The depth buffer is unnecessary, but WebGL only guarantees\n    // that certain combinations of framebuffer attachments will work, and \"stencil but no depth\" is not among them.\n    if (stencil) {\n      const renderbuffer = gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n      gl.framebufferRenderbuffer(\n        gl.FRAMEBUFFER,\n        gl.DEPTH_STENCIL_ATTACHMENT,\n        gl.RENDERBUFFER,\n        renderbuffer\n      );\n    }\n\n    return framebufferInfo;\n  }\n\n  _setShader(shader) {\n    if (shader !== this._currentShader) {\n      const gl = this.gl;\n      gl.useProgram(shader.program);\n\n      // These attributes and uniforms don't ever change, but must be set whenever a new shader program is used.\n\n      const attribLocation = shader.attribs.a_position;\n      gl.enableVertexAttribArray(attribLocation);\n      // Bind the 'a_position' vertex attribute to the current contents of `gl.ARRAY_BUFFER`, which in this case\n      // is a quadrilateral (as buffered earlier).\n      gl.vertexAttribPointer(\n        attribLocation,\n        2, // every 2 array elements make one vertex.\n        gl.FLOAT, // data type\n        false, // normalized\n        0, // stride (space between attributes)\n        0 // offset (index of the first attribute to start from)\n      );\n\n      this._currentShader = shader;\n      this._updateStageSize();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _setFramebuffer(framebufferInfo) {\n    if (framebufferInfo !== this._currentFramebuffer) {\n      this._currentFramebuffer = framebufferInfo;\n      if (framebufferInfo === null) {\n        // The \"null\" framebuffer means the drawing buffer which we're displaying to the screen.\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n        this._updateStageSize();\n      } else {\n        this.gl.bindFramebuffer(\n          this.gl.FRAMEBUFFER,\n          framebufferInfo.framebuffer\n        );\n        // Make sure to update the drawing viewport to the current framebuffer size.\n        this.gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n      }\n    }\n  }\n\n  setRenderTarget(renderTarget) {\n    if (typeof renderTarget === \"string\") {\n      renderTarget = document.querySelector(renderTarget);\n    }\n    this.renderTarget = renderTarget;\n    this.renderTarget.classList.add(\"leopard__project\");\n    this.renderTarget.style.width = `${this.project.stage.width}px`;\n    this.renderTarget.style.height = `${this.project.stage.height}px`;\n\n    this.renderTarget.append(this.stage);\n  }\n\n  // Handles rendering of all layers (including stage, pen layer, sprites, and all clones) in proper order.\n  _renderLayers(layers, options = {}) {\n    options = Object.assign(\n      {\n        drawMode: ShaderManager.DrawModes.DEFAULT,\n        renderSpeechBubbles: true\n      },\n      options\n    );\n\n    // If we're given a list of layers, filter by that.\n    // If we're given a filter function in the options, filter by that too.\n    // If we're given both, then only include layers which match both.\n    const shouldRestrictLayers = layers instanceof Set;\n    const shouldFilterLayers = typeof options.filter === \"function\";\n    const shouldIncludeLayer = layer =>\n      !(\n        (shouldRestrictLayers && !layers.has(layer)) ||\n        (shouldFilterLayers && !options.filter(layer))\n      );\n\n    // Stage\n    if (shouldIncludeLayer(this.project.stage)) {\n      this.renderSprite(this.project.stage, options);\n    }\n\n    // Pen layer\n    if (shouldIncludeLayer(this._penSkin)) {\n      const penMatrix = Matrix.create();\n      Matrix.scale(\n        penMatrix,\n        penMatrix,\n        this._penSkin.width,\n        -this._penSkin.height\n      );\n      Matrix.translate(penMatrix, penMatrix, -0.5, -0.5);\n\n      this._renderSkin(\n        this._penSkin,\n        options.drawMode,\n        penMatrix,\n        1 /* scale */\n      );\n    }\n\n    // Sprites + clones\n    for (const sprite of this.project.spritesAndClones) {\n      // Stage doesn't have \"visible\" defined, so check if it's strictly false\n      if (shouldIncludeLayer(sprite) && sprite.visible !== false) {\n        this.renderSprite(sprite, options);\n      }\n    }\n  }\n\n  _updateStageSize() {\n    if (this._currentShader) {\n      // The shader is passed things in \"Scratch-space\" (-240, 240) and (-180, 180).\n      // This tells it those dimensions so it can convert them to OpenGL \"clip-space\" (-1, 1).\n      this.gl.uniform2f(\n        this._currentShader.uniforms.u_stageSize,\n        this.project.stage.width,\n        this.project.stage.height\n      );\n    }\n\n    if (this._currentFramebuffer === null) {\n      this.gl.viewport(\n        0,\n        0,\n        this.gl.drawingBufferWidth,\n        this.gl.drawingBufferHeight\n      );\n    }\n  }\n\n  // Keep the canvas size in sync with the CSS size.\n  _resize() {\n    const stageSize = this.stage.getBoundingClientRect();\n    const ratio = window.devicePixelRatio;\n    const adjustedWidth = Math.round(stageSize.width * ratio);\n    const adjustedHeight = Math.round(stageSize.height * ratio);\n    if (\n      this.stage.width !== adjustedWidth ||\n      this.stage.height !== adjustedHeight\n    ) {\n      this.stage.width = adjustedWidth;\n      this.stage.height = adjustedHeight;\n      this._screenSpaceScale = Math.max(\n        adjustedWidth / this.project.stage.width,\n        adjustedHeight / this.project.stage.height\n      );\n\n      this._updateStageSize();\n    }\n  }\n\n  update() {\n    this._resize();\n\n    // Draw to the screen, not to a framebuffer.\n    this._setFramebuffer(null);\n\n    // Clear to opaque white.\n    const gl = this.gl;\n    gl.clearColor(1, 1, 1, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    this._renderLayers();\n  }\n\n  createStage(w, h) {\n    const stage = document.createElement(\"canvas\");\n    stage.width = w;\n    stage.height = h;\n\n    // Size canvas to parent container\n    stage.style.width = stage.style.height = \"100%\";\n\n    // If the container width is a non-integer size, don't blur the canvas.\n    // Chrome:\n    stage.style.imageRendering = \"pixelated\";\n    // Firefox:\n    stage.style.imageRendering = \"crisp-edges\";\n    // Safari + Opera:\n    stage.style.imageRendering = \"-webkit-optimize-contrast\";\n\n    return stage;\n  }\n\n  // Calculate the transform matrix for a speech bubble attached to a sprite.\n  _calculateSpeechBubbleMatrix(spr, speechBubbleSkin) {\n    const sprBounds = this.getBoundingBox(spr);\n    let x;\n    if (\n      speechBubbleSkin.width + sprBounds.right >\n      this.project.stage.width / 2\n    ) {\n      x = sprBounds.left - speechBubbleSkin.width;\n      speechBubbleSkin.flipped = true;\n    } else {\n      x = sprBounds.right;\n      speechBubbleSkin.flipped = false;\n    }\n    x = Math.round(x - speechBubbleSkin.offsetX);\n    const y = Math.round(sprBounds.top - speechBubbleSkin.offsetY);\n\n    const m = Matrix.create();\n    Matrix.translate(m, m, x, y);\n    Matrix.scale(m, m, speechBubbleSkin.width, speechBubbleSkin.height);\n\n    return m;\n  }\n\n  _renderSkin(\n    skin,\n    drawMode,\n    matrix,\n    scale,\n    effects,\n    effectMask,\n    colorMask,\n    spriteColorId\n  ) {\n    const gl = this.gl;\n\n    const skinTexture = skin.getTexture(scale * this._screenSpaceScale);\n    // Skip rendering the skin if it has no texture.\n    if (!skinTexture) return;\n\n    let effectBitmask = effects ? effects._bitmask : 0;\n    if (typeof effectMask === \"number\") effectBitmask &= effectMask;\n    const shader = this._shaderManager.getShader(drawMode, effectBitmask);\n    this._setShader(shader);\n    gl.uniformMatrix3fv(shader.uniforms.u_transform, false, matrix);\n\n    if (effectBitmask !== 0) {\n      for (const effect of effectNames) {\n        const effectVal = effects._effectValues[effect];\n        if (effectVal !== 0)\n          gl.uniform1f(shader.uniforms[`u_${effect}`], effectVal);\n      }\n\n      // Pixelate effect needs the skin size\n      if (effects._effectValues.pixelate !== 0)\n        gl.uniform2f(shader.uniforms.u_skinSize, skin.width, skin.height);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, skinTexture);\n    // All textures are bound to texture unit 0, so that's where the texture sampler should point\n    gl.uniform1i(shader.uniforms.u_texture, 0);\n\n    // Enable color masking mode if set\n    if (Array.isArray(colorMask))\n      this.gl.uniform4fv(this._currentShader.uniforms.u_colorMask, colorMask);\n\n    // Used for mapping drawn sprites back to their indices in a list.\n    // By looking at the color of a given pixel, we can tell which sprite is\n    // the topmost one drawn on that pixel.\n    if (drawMode === ShaderManager.DrawModes.SPRITE_ID) {\n      this.gl.uniform3fv(\n        this._currentShader.uniforms.u_spriteId,\n        idToColor(spriteColorId)\n      );\n    }\n\n    // Actually draw the skin\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n  }\n\n  renderSprite(sprite, options) {\n    const spriteScale = Object.prototype.hasOwnProperty.call(sprite, \"size\")\n      ? sprite.size / 100\n      : 1;\n\n    this._renderSkin(\n      this._getSkin(sprite.costume),\n      options.drawMode,\n      this._getDrawable(sprite).getMatrix(),\n      spriteScale,\n      sprite.effects,\n      options.effectMask,\n      options.colorMask\n    );\n\n    if (\n      options.renderSpeechBubbles &&\n      sprite._speechBubble &&\n      sprite._speechBubble.text !== \"\"\n    ) {\n      const speechBubbleSkin = this._getSkin(sprite._speechBubble);\n\n      this._renderSkin(\n        speechBubbleSkin,\n        options.drawMode,\n        this._calculateSpeechBubbleMatrix(sprite, speechBubbleSkin),\n        1 /* spriteScale */\n      );\n    }\n  }\n\n  getTightBoundingBox(sprite) {\n    return this._getDrawable(sprite).getTightBoundingBox();\n  }\n\n  getBoundingBox(sprite) {\n    return Rectangle.fromMatrix(this._getDrawable(sprite).getMatrix());\n  }\n\n  // Mask drawing in to only areas where this sprite is opaque.\n  _stencilSprite(spr, colorMask) {\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n    // Enable stenciling. This means that:\n    // 1. Only pixels which pass the \"stencil test\" will be drawn.\n    // 2. Anything rendered will also draw to the stencil buffer.\n    gl.enable(gl.STENCIL_TEST);\n    // Pass the stencil test regardless of what's in the stencil buffer.\n    // Note that pixels which the shader has discarded will still fail the stencil test.\n    // 1 is the reference value which we use in the next line.\n    gl.stencilFunc(gl.ALWAYS, 1, 1);\n    // If the stencil test passes (in this case, if the shader hasn't discarded the pixel),\n    // draw a 1 to that pixel in the stencil buffer, replacing whatever's already there.\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n    // Don't draw to the color buffer. Only to the stencil buffer.\n    gl.colorMask(false, false, false, false);\n    // Draw the sprite in the \"silhouette\" mode, which discards transparent pixels.\n    // This, along with the above line, has the effect of not drawing anything to the color buffer, but\n    // creating a \"mask\" in the stencil buffer that masks out all pixels where this sprite is transparent.\n\n    const opts = {\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\n      renderSpeechBubbles: false,\n      // Ignore ghost effect\n      effectMask: ~effectBitmasks.ghost\n    };\n\n    // If we mask in the color (for e.g. \"color is touching color\"),\n    // we need to pass that in as a uniform as well.\n    if (colorMask) {\n      opts.colorMask = colorMask.toRGBANormalized();\n      opts.drawMode = ShaderManager.DrawModes.COLOR_MASK;\n    }\n    this._renderLayers(new Set([spr]), opts);\n\n    // Pass the stencil test if the stencil buffer value equals 1 (e.g. the pixel got masked in above).\n    gl.stencilFunc(gl.EQUAL, 1, 1);\n    // Keep the current stencil buffer values no matter what.\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n    // We can draw to the color buffer again. Note that only pixels which pass the stencil test are drawn.\n    gl.colorMask(true, true, true, true);\n  }\n\n  checkSpriteCollision(spr, targets, fast, sprColor) {\n    if (!spr.visible) return false;\n    if (!(targets instanceof Set)) {\n      if (targets instanceof Array) {\n        targets = new Set(targets);\n      } else {\n        targets = new Set([targets]);\n      }\n    }\n\n    const sprBox = Rectangle.copy(\n      this.getBoundingBox(spr),\n      __collisionBox\n    ).snapToInt();\n\n    // This is an \"impossible rectangle\"-- its left bound is infinitely far to the right,\n    // its right bound is infinitely to the left, and so on. Its size is effectively -Infinity.\n    // Its only purpose is to be the \"identity rectangle\" that starts the rectangle union process.\n    const targetBox = Rectangle.fromBounds(\n      Infinity,\n      -Infinity,\n      Infinity,\n      -Infinity\n    );\n    for (const target of targets) {\n      Rectangle.union(targetBox, this.getBoundingBox(target), targetBox);\n    }\n    targetBox.snapToInt();\n\n    if (!sprBox.intersects(targetBox)) return false;\n    if (fast) return true;\n\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    const collisionBox = Rectangle.intersection(sprBox, targetBox).clamp(\n      -cx,\n      cx,\n      -cy,\n      cy\n    );\n\n    if (collisionBox.width === 0 || collisionBox.height === 0) return false;\n\n    this._setFramebuffer(this._collisionBuffer);\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\n    this._stencilSprite(spr, sprColor);\n\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\n    this._renderLayers(targets, {\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\n      // Ignore ghost effect\n      effectMask: ~effectBitmasks.ghost\n    });\n\n    const gl = this.gl;\n    // Make sure to disable the stencil test so as not to affect other rendering!\n    gl.disable(gl.STENCIL_TEST);\n\n    const pixelData = new Uint8Array(\n      collisionBox.width * collisionBox.height * 4\n    );\n    gl.readPixels(\n      collisionBox.left + cx,\n      collisionBox.bottom + cy,\n      collisionBox.width,\n      collisionBox.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixelData\n    );\n\n    // Any opaque pixel = an overlap between the two sprites.\n    for (let i = 0; i < pixelData.length; i += 4) {\n      if (pixelData[i + 3] !== 0) return true;\n    }\n\n    return false;\n  }\n\n  checkColorCollision(spr, targetsColor, sprColor) {\n    const sprBox = Rectangle.copy(\n      this.getBoundingBox(spr),\n      __collisionBox\n    ).snapToInt();\n\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    sprBox.clamp(-cx, cx, -cy, cy);\n\n    if (sprBox.width === 0 || sprBox.height === 0) return false;\n\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n    this._setFramebuffer(this._collisionBuffer);\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\n    this._stencilSprite(spr, sprColor);\n\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\n    this._renderLayers(null, {\n      filter: layer => layer !== spr\n    });\n\n    // Make sure to disable the stencil test so as not to affect other rendering!\n    gl.disable(gl.STENCIL_TEST);\n\n    const pixelData = new Uint8Array(sprBox.width * sprBox.height * 4);\n    gl.readPixels(\n      sprBox.left + cx,\n      sprBox.bottom + cy,\n      sprBox.width,\n      sprBox.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixelData\n    );\n\n    const color = targetsColor.toRGBA();\n    for (let i = 0; i < pixelData.length; i += 4) {\n      if (\n        // Ensure we're not testing transparent pixels\n        pixelData[i + 3] !== 0 &&\n        // Scratch tests the top 5 bits of the red and green channels,\n        // and the top 4 bits of the blue channel.\n        ((pixelData[i] ^ color[0]) & 0b11111000) === 0 &&\n        ((pixelData[i + 1] ^ color[1]) & 0b11111000) === 0 &&\n        ((pixelData[i + 2] ^ color[2]) & 0b11110000) === 0\n      )\n        return true;\n    }\n\n    return false;\n  }\n\n  // Pick the topmost sprite at the given point (if one exists).\n  pick(sprites, point) {\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    for (let i = 0; i < sprites.length; i++) {\n      const sprite = sprites[i];\n      this._renderSkin(\n        this._getSkin(sprite.costume),\n        ShaderManager.DrawModes.SPRITE_ID,\n        this._getDrawable(sprite).getMatrix(),\n        1 /* scale */,\n        sprite.effects,\n        null,\n        null,\n        i\n      );\n    }\n\n    this._renderLayers(new Set([sprites]), {\n      effectMask: ~effectBitmasks.ghost\n    });\n\n    const hoveredPixel = new Uint8Array(4);\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    gl.readPixels(\n      point.x + cx,\n      point.y + cy,\n      1,\n      1,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      hoveredPixel\n    );\n\n    const index = colorToId(hoveredPixel);\n    if (index === -1) return null;\n    return sprites[index];\n  }\n\n  checkPointCollision(spr, point, fast) {\n    if (!spr.visible) return false;\n\n    const box = this.getBoundingBox(spr);\n    if (!box.containsPoint(point.x, point.y)) return false;\n    if (fast) return true;\n\n    // TODO: would it be faster to enable a scissor rectangle?\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    this._renderLayers(new Set([spr]), { effectMask: ~effectBitmasks.ghost });\n\n    const hoveredPixel = new Uint8Array(4);\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    gl.readPixels(\n      point.x + cx,\n      point.y + cy,\n      1,\n      1,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      hoveredPixel\n    );\n    return hoveredPixel[3] !== 0;\n  }\n\n  penLine(pt1, pt2, color, size) {\n    this._penSkin.penLine(pt1, pt2, color, size);\n  }\n\n  clearPen() {\n    this._penSkin.clear();\n  }\n\n  stamp(spr) {\n    this._setFramebuffer(this._penSkin._framebufferInfo);\n    this._renderLayers(new Set([spr]), { renderSpeechBubbles: false });\n  }\n\n  displayAskBox(question) {\n    const askBox = document.createElement(\"form\");\n    askBox.classList.add(\"leopard__askBox\");\n\n    const askText = document.createElement(\"span\");\n    askText.classList.add(\"leopard__askText\");\n    askText.innerText = question;\n    askBox.append(askText);\n\n    const askInput = document.createElement(\"input\");\n    askInput.type = \"text\";\n    askInput.classList.add(\"leopard__askInput\");\n    askBox.append(askInput);\n\n    const askButton = document.createElement(\"button\");\n    askButton.classList.add(\"leopard__askButton\");\n    askButton.innerText = \"Answer\";\n    askBox.append(askButton);\n\n    this.renderTarget.append(askBox);\n    askInput.focus();\n\n    return new Promise(resolve => {\n      askBox.addEventListener(\"submit\", e => {\n        e.preventDefault();\n        askBox.remove();\n        resolve(askInput.value);\n      });\n    });\n  }\n}\n","export default class Input {\n  constructor(stage, canvas, onKeyDown) {\n    this._stage = stage;\n    this._canvas = canvas;\n\n    // Allow setting focus to canvas\n    if (this._canvas.tabIndex < 0) {\n      this._canvas.tabIndex = 0;\n    }\n\n    this.mouse = { x: 0, y: 0, down: false };\n    this._canvas.addEventListener(\"mousemove\", this._mouseMove.bind(this));\n    this._canvas.addEventListener(\"mousedown\", this._mouseDown.bind(this));\n    this._canvas.addEventListener(\"mouseup\", this._mouseUp.bind(this));\n\n    this._canvas.addEventListener(\"keyup\", this._keyup.bind(this));\n    this._canvas.addEventListener(\"keydown\", this._keydown.bind(this));\n\n    this.keys = [];\n    this._onKeyDown = onKeyDown;\n  }\n\n  _mouseMove(e) {\n    const rect = this._canvas.getBoundingClientRect();\n    const scaleX = this._stage.width / rect.width;\n    const scaleY = this._stage.height / rect.height;\n    const realCoords = {\n      x: (e.clientX - rect.left) * scaleX,\n      y: (e.clientY - rect.top) * scaleY\n    };\n\n    this.mouse = {\n      ...this.mouse,\n      x: realCoords.x - this._stage.width / 2,\n      y: -realCoords.y + this._stage.height / 2\n    };\n  }\n\n  _mouseDown() {\n    this.mouse = {\n      ...this.mouse,\n      down: true\n    };\n  }\n\n  _mouseUp() {\n    this.mouse = {\n      ...this.mouse,\n      down: false\n    };\n  }\n\n  _keyup(e) {\n    const key = this._getKeyName(e);\n    this.keys = this.keys.filter(k => k !== key);\n  }\n\n  _keydown(e) {\n    e.preventDefault();\n\n    const key = this._getKeyName(e);\n    if (this.keys.indexOf(key) === -1) {\n      this.keys.push(key);\n    }\n\n    this._onKeyDown(key);\n  }\n\n  _getKeyName(e) {\n    if (e.key === \"ArrowUp\") return \"up arrow\";\n    if (e.key === \"ArrowDown\") return \"down arrow\";\n    if (e.key === \"ArrowLeft\") return \"left arrow\";\n    if (e.key === \"ArrowRight\") return \"right arrow\";\n    if (e.key === \" \") return \"space\";\n    if (e.code.substring(0, 5) === \"Digit\") return e.code[5];\n\n    return e.key.toLowerCase();\n  }\n\n  keyPressed(name) {\n    if (name === \"any\") return this.keys.length > 0;\n    return this.keys.indexOf(name) > -1;\n  }\n\n  focus() {\n    this._canvas.focus();\n  }\n}\n","import Sound from \"./Sound.js\";\n\nconst IGNORABLE_ERROR = [\"NotAllowedError\", \"NotFoundError\"];\n\n// https://github.com/LLK/scratch-audio/blob/develop/src/Loudness.js\nexport default class LoudnessHandler {\n  constructor() {\n    // TODO: use a TypeScript enum\n    this.connectionState = \"NOT_CONNECTED\";\n  }\n\n  get audioContext() {\n    return Sound.audioContext;\n  }\n\n  async connect() {\n    // If we're in the middle of connecting, or failed to connect,\n    // don't attempt to connect again\n    if (this.connectionState !== \"NOT_CONNECTED\") return;\n    this.connectionState = \"CONNECTING\";\n\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      // Chrome blocks usage of audio until the user interacts with the page.\n      // By calling `resume` here, we will wait until that happens.\n      await Sound.audioContext.resume();\n      this.hasConnected = true;\n      this.audioStream = stream;\n      const mic = this.audioContext.createMediaStreamSource(stream);\n      this.analyser = this.audioContext.createAnalyser();\n      mic.connect(this.analyser);\n      this.micDataArray = new Float32Array(this.analyser.fftSize);\n      this.connectionState = \"CONNECTED\";\n    } catch (e) {\n      this.connectionState = \"ERROR\";\n      if (IGNORABLE_ERROR.includes(e.name)) {\n        console.warn(\"Mic is not available.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  get loudness() {\n    if (this.connectionState !== \"CONNECTED\" || !this.audioStream.active) {\n      return -1;\n    }\n\n    this.analyser.getFloatTimeDomainData(this.micDataArray);\n    let sum = 0;\n    // compute the RMS of the sound\n    for (let i = 0; i < this.micDataArray.length; i++) {\n      sum += Math.pow(this.micDataArray[i], 2);\n    }\n    let rms = Math.sqrt(sum / this.micDataArray.length);\n    // smoothe the value with the last one, if it is descending\n    if (this._lastValue) {\n      rms = Math.max(rms, this._lastValue * 0.6);\n    }\n    this._lastValue = rms;\n\n    // scale the measurement so it's more sensitive to quieter sounds\n    rms *= 1.63;\n    rms = Math.sqrt(rms);\n    rms = Math.round(rms * 100);\n    rms = Math.min(rms, 100);\n    return rms;\n  }\n\n  getLoudness() {\n    this.connect();\n    return this.loudness;\n  }\n}\n","import Trigger from \"./Trigger.js\";\nimport Renderer from \"./Renderer.js\";\nimport Input from \"./Input.js\";\nimport LoudnessHandler from \"./Loudness.js\";\nimport Sound from \"./Sound.js\";\n\nexport default class Project {\n  constructor(stage, sprites = {}, { frameRate = 30 } = {}) {\n    this.stage = stage;\n    this.sprites = sprites;\n\n    Object.freeze(sprites); // Prevent adding/removing sprites while project is running\n\n    for (const sprite of this.spritesAndClones) {\n      sprite._project = this;\n    }\n    this.stage._project = this;\n\n    this.renderer = new Renderer(this);\n    this.input = new Input(this.stage, this.renderer.stage, key => {\n      this.fireTrigger(Trigger.KEY_PRESSED, { key });\n    });\n\n    this.loudnessHandler = new LoudnessHandler();\n    // Only update loudness once per step.\n    this._cachedLoudness = null;\n\n    this.runningTriggers = [];\n    // Used to keep track of what edge-activated trigger predicates evaluted to\n    // on the previous step.\n    this._prevStepTriggerPredicates = new WeakMap();\n\n    this.restartTimer();\n\n    this.answer = null;\n\n    // Run project code at specified framerate\n    setInterval(() => {\n      this.step();\n    }, 1000 / frameRate);\n\n    // Render project as fast as possible\n    this._renderLoop();\n  }\n\n  attach(renderTarget) {\n    this.renderer.setRenderTarget(renderTarget);\n    this.renderer.stage.addEventListener(\"click\", () => {\n      // Chrome requires a user gesture on the page before we can start the\n      // audio context.\n      // When we click the stage, that counts as a user gesture, so try\n      // resuming the audio context.\n      if (Sound.audioContext.state === \"suspended\") {\n        Sound.audioContext.resume();\n      }\n\n      let clickedSprite = this.renderer.pick(this.spritesAndClones, {\n        x: this.input.mouse.x,\n        y: this.input.mouse.y\n      });\n      if (!clickedSprite) {\n        clickedSprite = this.stage;\n      }\n\n      const matchingTriggers = [];\n      for (const trigger of clickedSprite.triggers) {\n        if (trigger.matches(Trigger.CLICKED, {}, clickedSprite)) {\n          matchingTriggers.push({ trigger, target: clickedSprite });\n        }\n      }\n\n      this._startTriggers(matchingTriggers);\n    });\n  }\n\n  greenFlag() {\n    // Chrome requires a user gesture on the page before we can start the\n    // audio context.\n    // When greenFlag is triggered, it's likely that the cause of it was some\n    // kind of button click, so try resuming the audio context.\n    if (Sound.audioContext.state === \"suspended\") {\n      Sound.audioContext.resume();\n    }\n    this.fireTrigger(Trigger.GREEN_FLAG);\n    this.input.focus();\n  }\n\n  // Find triggers which match the given condition\n  _matchingTriggers(triggerMatches) {\n    let matchingTriggers = [];\n    const targets = this.spritesAndStage;\n    for (const target of targets) {\n      const matchingTargetTriggers = target.triggers.filter(tr =>\n        triggerMatches(tr, target)\n      );\n      for (const match of matchingTargetTriggers) {\n        matchingTriggers.push({ trigger: match, target });\n      }\n    }\n    return matchingTriggers;\n  }\n\n  _stepEdgeActivatedTriggers() {\n    const edgeActivated = this._matchingTriggers(tr => tr.isEdgeActivated);\n    const triggersToStart = [];\n    for (const triggerWithTarget of edgeActivated) {\n      const { trigger, target } = triggerWithTarget;\n      let predicate;\n      switch (trigger.trigger) {\n        case Trigger.TIMER_GREATER_THAN:\n          predicate = this.timer > trigger.option(\"VALUE\", target);\n          break;\n        case Trigger.LOUDNESS_GREATER_THAN:\n          predicate = this.loudness > trigger.option(\"VALUE\", target);\n          break;\n        default:\n          throw new Error(`Unimplemented trigger ${trigger.trigger}`);\n      }\n\n      // Default to false\n      const prevPredicate = !!this._prevStepTriggerPredicates.get(trigger);\n      this._prevStepTriggerPredicates.set(trigger, predicate);\n\n      // The predicate evaluated to false last time and true this time\n      // Activate the trigger\n      if (!prevPredicate && predicate) {\n        triggersToStart.push(triggerWithTarget);\n      }\n    }\n    this._startTriggers(triggersToStart);\n  }\n\n  step() {\n    this._cachedLoudness = null;\n    this._stepEdgeActivatedTriggers();\n\n    // Step all triggers\n    const alreadyRunningTriggers = this.runningTriggers;\n    for (let i = 0; i < alreadyRunningTriggers.length; i++) {\n      alreadyRunningTriggers[i].trigger.step();\n    }\n\n    // Remove finished triggers\n    this.runningTriggers = this.runningTriggers.filter(\n      ({ trigger }) => !trigger.done\n    );\n  }\n\n  render() {\n    // Render to canvas\n    this.renderer.update(this.stage, this.spritesAndClones);\n\n    // Update watchers\n    for (const sprite of [...Object.values(this.sprites), this.stage]) {\n      for (const watcher of Object.values(sprite.watchers)) {\n        watcher.updateDOM(this.renderer.renderTarget);\n      }\n    }\n  }\n\n  _renderLoop() {\n    requestAnimationFrame(this._renderLoop.bind(this));\n    this.render();\n  }\n\n  fireTrigger(trigger, options) {\n    // Special trigger behaviors\n    if (trigger === Trigger.GREEN_FLAG) {\n      this.restartTimer();\n      this.stopAllSounds();\n      this.runningTriggers = [];\n\n      for (const spriteName in this.sprites) {\n        const sprite = this.sprites[spriteName];\n        sprite.clones = [];\n      }\n\n      for (const sprite of this.spritesAndStage) {\n        sprite.effects.clear();\n        sprite.audioEffects.clear();\n      }\n    }\n\n    const matchingTriggers = this._matchingTriggers((tr, target) =>\n      tr.matches(trigger, options, target)\n    );\n\n    return this._startTriggers(matchingTriggers);\n  }\n\n  _startTriggers(triggers) {\n    // Only add these triggers to this.runningTriggers if they're not already there.\n    // TODO: if the triggers are already running, they'll be restarted but their execution order is unchanged.\n    // Does that match Scratch's behavior?\n    for (const trigger of triggers) {\n      if (\n        !this.runningTriggers.find(\n          runningTrigger =>\n            trigger.trigger === runningTrigger.trigger &&\n            trigger.target === runningTrigger.target\n        )\n      ) {\n        this.runningTriggers.push(trigger);\n      }\n    }\n    return Promise.all(\n      triggers.map(({ trigger, target }) => {\n        return trigger.start(target);\n      })\n    );\n  }\n\n  get spritesAndClones() {\n    return Object.values(this.sprites)\n      .flatMap(sprite => sprite.andClones())\n      .sort((a, b) => a._layerOrder - b._layerOrder);\n  }\n\n  get spritesAndStage() {\n    return [...this.spritesAndClones, this.stage];\n  }\n\n  changeSpriteLayer(sprite, layerDelta, relativeToSprite = sprite) {\n    let spritesArray = this.spritesAndClones;\n\n    const originalIndex = spritesArray.indexOf(sprite);\n    const relativeToIndex = spritesArray.indexOf(relativeToSprite);\n\n    let newIndex = relativeToIndex + layerDelta;\n    if (newIndex < 0) newIndex = 0;\n    if (newIndex > spritesArray.length - 1) newIndex = spritesArray.length - 1;\n\n    // Remove sprite from originalIndex and insert at newIndex\n    spritesArray.splice(originalIndex, 1);\n    spritesArray.splice(newIndex, 0, sprite);\n\n    // spritesArray is sorted correctly, but to influence\n    // the actual order of the sprites we need to update\n    // each one's _layerOrder property.\n    spritesArray.forEach((sprite, index) => {\n      sprite._layerOrder = index + 1;\n    });\n  }\n\n  stopAllSounds() {\n    for (const target of this.spritesAndStage) {\n      target.stopAllOfMySounds();\n    }\n  }\n\n  get timer() {\n    const ms = new Date() - this.timerStart;\n    return ms / 1000;\n  }\n\n  restartTimer() {\n    this.timerStart = new Date();\n  }\n\n  async askAndWait(question) {\n    this.answer = await this.renderer.displayAskBox(question);\n  }\n\n  get loudness() {\n    if (this._cachedLoudness === null) {\n      this._cachedLoudness = this.loudnessHandler.getLoudness();\n    }\n    return this._cachedLoudness;\n  }\n}\n","import Color from \"./Color\";\n\nexport default class Watcher {\n  constructor({\n    value = () => \"\",\n    setValue = () => {},\n    label,\n    style = \"normal\",\n    visible = true,\n    color = Color.rgb(255, 140, 26),\n    step = 1,\n    x = -240,\n    y = 180,\n    width,\n    height\n  }) {\n    this.initializeDOM();\n\n    this.value = value;\n    this.setValue = setValue;\n    this._previousValue = Symbol(\"NO_PREVIOUS_VALUE\");\n\n    this.label = label;\n    this.style = style;\n    this.visible = visible;\n    this.color = color;\n    this.step = step;\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  initializeDOM() {\n    const node = document.createElement(\"div\");\n    node.classList.add(\"leopard__watcher\");\n\n    const label = document.createElement(\"div\");\n    label.classList.add(\"leopard__watcherLabel\");\n    node.append(label);\n\n    const value = document.createElement(\"div\");\n    value.classList.add(\"leopard__watcherValue\");\n    node.append(value);\n\n    const slider = document.createElement(\"input\");\n    slider.type = \"range\";\n    slider.classList.add(\"leopard__watcherSlider\");\n\n    slider.addEventListener(\"input\", event => {\n      this.setValue(Number(event.target.value));\n    });\n\n    node.append(slider);\n\n    this._dom = { node, label, value, slider };\n  }\n\n  updateDOM(renderTarget) {\n    if (renderTarget && !renderTarget.contains(this._dom.node)) {\n      renderTarget.append(this._dom.node);\n    }\n\n    if (!this.visible) return;\n\n    const value = this.value();\n\n    const isList = Array.isArray(value);\n    this._dom.node.classList.toggle(\"leopard__watcher--list\", isList);\n    if (isList) {\n      // Render like a list\n      if (\n        !Array.isArray(this._previousValue) ||\n        JSON.stringify(value.map(String)) !==\n          JSON.stringify(this._previousValue.map(String))\n      ) {\n        this._dom.value.innerHTML = \"\";\n        for (const [index, item] of value.entries()) {\n          const itemElem = document.createElement(\"div\");\n          itemElem.classList.add(\"leopard__watcherListItem\");\n\n          const indexElem = document.createElement(\"div\");\n          indexElem.classList.add(\"leopard__watcherListItemIndex\");\n          indexElem.innerText = index;\n\n          const contentElem = document.createElement(\"div\");\n          contentElem.classList.add(\"leopard__watcherListItemContent\");\n          contentElem.innerText = item.toString();\n\n          itemElem.append(indexElem);\n          itemElem.append(contentElem);\n          this._dom.value.append(itemElem);\n        }\n      }\n    } else {\n      // Render like a normal variable\n      if (value !== this._previousValue) {\n        this._dom.value.innerText = value.toString();\n      }\n    }\n\n    if (isList) {\n      this._previousValue = [...value];\n    } else {\n      this._previousValue = value;\n    }\n\n    // Set slider value\n    if (this._style === \"slider\") {\n      this._dom.slider.value = value;\n    }\n\n    // Update color\n    // (Needs to happen here rather than a setter because\n    // mutation of color object is possible.)\n    const textColor =\n      this.color.r * 0.299 + this.color.g * 0.587 + this.color.b * 0.114 > 162\n        ? \"#000\"\n        : \"#fff\";\n    this._dom.value.style.setProperty(\"--watcher-color\", this.color.toString());\n    this._dom.value.style.setProperty(\"--watcher-text-color\", textColor);\n  }\n\n  get visible() {\n    return this._visible;\n  }\n  set visible(visible) {\n    this._visible = visible;\n    this._dom.node.style.visibility = visible ? \"visible\" : \"hidden\";\n  }\n\n  get x() {\n    return this._x;\n  }\n  set x(x) {\n    this._x = x;\n    this._dom.node.style.left = `${x - 240}px`;\n  }\n\n  get y() {\n    return this._y;\n  }\n  set y(y) {\n    this._y = y;\n    this._dom.node.style.top = `${180 - y}px`;\n  }\n\n  get width() {\n    return this._width;\n  }\n  set width(width) {\n    this._width = width;\n    if (width) {\n      this._dom.node.style.width = `${width}px`;\n    } else {\n      this._dom.node.style.width = undefined;\n    }\n  }\n\n  get height() {\n    return this._height;\n  }\n  set height(height) {\n    this._height = height;\n    if (height) {\n      this._dom.node.style.height = `${height}px`;\n    } else {\n      this._dom.node.style.height = undefined;\n    }\n  }\n\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    this._style = style;\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--normal\",\n      style === \"normal\"\n    );\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--large\",\n      style === \"large\"\n    );\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--slider\",\n      style === \"slider\"\n    );\n  }\n\n  get min() {\n    return this._min;\n  }\n  set min(min) {\n    this._min = min;\n    this._dom.slider.min = min;\n  }\n\n  get max() {\n    return this._max;\n  }\n  set max(max) {\n    this._max = max;\n    this._dom.slider.max = max;\n  }\n\n  get step() {\n    return this._step;\n  }\n  set step(step) {\n    this._step = step;\n    this._dom.slider.step = step;\n  }\n\n  get label() {\n    return this._label;\n  }\n  set label(label) {\n    this._label = label;\n    this._dom.label.innerText = label;\n  }\n}\n"],"names":["GREEN_FLAG","Symbol","KEY_PRESSED","BROADCAST","CLICKED","CLONE_START","LOUDNESS_GREATER_THAN","TIMER_GREATER_THAN","BACKDROP_CHANGED","Trigger","constructor","trigger","options","script","this","_script","done","stop","isEdgeActivated","option","target","triggerOption","matches","start","boundScript","bind","_runningScript","Promise","resolve","step","next","Matrix","static","matrix","Float32Array","identity","dst","src","x","y","a00","a01","a02","a10","a11","a12","a20","a21","a22","rad","s","Math","sin","c","cos","m","Rectangle","left","Infinity","right","bottom","top","result","xa","xb","absx","abs","sumx","ya","yb","absy","sumy","snapToInt","floor","ceil","intersects","rect","containsPoint","clamp","min","max","rect1","rect2","width","height","effectNames","effectBitmasks","i","length","effectTransformPoint","drawable","effects","_sprite","effectBitmask","_bitmask","mosaic","mosaicFactor","pixelate","skin","getCurrentSkin","pixSizeX","pixSizeY","whirl","PI_OVER_180","offsetX","offsetY","offsetLength","sqrt","whirlFactor","fisheye","vecX","vecY","len","factor","r","pow","unitX","unitY","n","rgbToHSV","g","b","delta","h","v","hsvToRGB","Color","a","Number","rgb","_setRGB","_a","_h","_s","_v","toHexString","forceIncludeAlpha","toHexDigits","str","round","toString","hex","map","join","toRGBString","toRGBA","toRGBANormalized","ADPCM_STEPS","ADPCM_INDEX","decodeADPCMAudio","ab","audioContext","dv","DataView","getUint32","reject","Error","blocks","l","byteLength","String","fromCharCode","getUint8","format","getUint16","sampleRate","blockSize","frameCount","fact","buffer","createBuffer","channel","getChannelData","sample","code","index","lastByte","offset","data","j","getInt16","isADPCMData","arrayBuffer","dataView","isWavData","Sound","name","url","audioBuffer","source","playbackRate","downloadMyAudioBuffer","duration","started","isLatestCallToStart","_markDone","playMyAudioBuffer","oldDoneDownloading","_doneDownloading","fromMoreRecentCall","playUntilDone","playing","addEventListener","disconnect","fetch","then","body","catch","error","console","warn","decodeAudioData","createBufferSource","value","connect","currentTime","setPlaybackRate","isConnectedTo","_setupAudioContext","_audioContext","AudioContext","window","webkitAudioContext","EffectChain","config","getNonPatchSoundList","inputNode","createGain","effectNodes","resetToInitial","initials","getInitialEffectValues","effectValues","initialValue","Object","entries","getEffectDescriptor","reset","setEffectValue","updateAudioEffect","descriptor","isPatch","getNextEffectDescriptor","previous","getPreviousEffectDescriptor","output","input","nodes","initial","makeNodes","node","Set","values","set","sound","last","getLastEffectDescriptor","isNaN","clampEffectValue","changeEffectValue","minimum","maximum","getEffectValue","clone","newConfig","newEffectChain","assign","resetOnClone","applyToSound","isTargetOf","effectDescriptors","find","slice","_","decayDuration","decayWait","aCtx","leftGain","rightGain","channelMerger","createChannelMerger","p","leftVal","PI","rightVal","gain","setTargetAtTime","interval","ratio","resetOnStart","linearRampToValueAtTime","AudioEffectMap","effectChain","defineProperty","get","clear","_EffectMap","_effectValues","effectName","val","_clone","keys","SpriteBase","initialConditions","vars","_project","costumeNumber","layerOrder","_costumeNumber","_layerOrder","triggers","watchers","costumes","sounds","getSoundsPlayedByMe","destination","audioEffects","_vars","filter","stage","sprites","number","fireBackdropChanged","costume","findIndex","lower","upper","excluded","possibleOptions","randInt","random","trim","moveAhead","changeSpriteLayer","moveBehind","degToRad","deg","radToDeg","degToScratch","scratchToDeg","scratchDir","radToScratch","scratchToRad","normalizeDeg","warp","procedure","bound","args","inst","wait","secs","endTime","Date","setMilliseconds","getMilliseconds","mouse","keyPressed","timer","restartTimer","startSound","soundName","getSound","playSoundUntilDone","stopAllSounds","stopAllOfMySounds","broadcast","fireTrigger","broadcastAndWait","running","clearPen","renderer","askAndWait","question","_speechBubble","say","answer","loudness","Sprite","super","direction","rotationStyle","size","visible","penDown","penSize","penColor","_x","_y","_direction","RotationStyle","ALL_AROUND","parent","clones","_penDown","_penColor","text","style","timeout","createClone","create","getPrototypeOf","original","push","tr","_startTriggers","deleteThisClone","runningTriggers","andClones","flatMap","dir","goto","penLine","move","dist","moveDir","glide","seconds","interpolate","t","startTime","startX","startY","color","stamp","touching","fast","checkPointCollision","bounds","getTightBoundingBox","stageWidth","stageHeight","checkColorCollision","checkSpriteCollision","colorTouching","clearTimeout","think","sayAndWait","setTimeout","thinkAndWait","freeze","LEFT_RIGHT","DONT_ROTATE","Stage","defineProperties","enumerable","__counter","backdrop","determinant","SpriteTransformDiff","sprite","_unset","update","_lastX","_lastY","_lastRotation","_lastRotationStyle","_lastSize","_lastCostume","_lastCostumeLoaded","img","complete","changed","Drawable","_renderer","_matrix","_matrixDiff","_calculateSpriteMatrix","_convexHullImageData","_convexHullMosaic","_convexHullPixelate","_convexHullWhirl","_convexHullFisheye","_convexHullPoints","_aabb","_tightBoundingBox","_convexHullMatrixDiff","_getSkin","getAABB","fromMatrix","getMatrix","convexHullPoints","_calculateConvexHull","fromBounds","transformedPoint","halfPixelX","halfPixelY","point","transformPoint","imageData","getImageData","leftHull","rightHull","pixelPos","effectPos","currentPoint","pixelX","pixelY","pop","spr","translate","rotate","scale","spriteScale","scalingFactor","resolution","center","Skin","gl","getTexture","_makeTexture","image","filtering","glTexture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","_setSizeFromImage","naturalWidth","naturalHeight","destroy","BitmapSkin","_image","_imageData","_texture","canvas","document","createElement","ctx","getContext","drawImage","NEAREST","deleteTexture","SpriteShader","PenLineShader","Shader","program","uniforms","attribs","numActiveUniforms","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","numActiveAttributes","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","ShaderManager","_shaderCache","drawMode","DrawModes","Map","_createShader","type","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","getShader","shaderMap","has","shaderCode","PEN_LINE","define","vertShader","vertex","VERTEX_SHADER","fragShader","fragment","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","LINK_STATUS","info","getProgramInfoLog","DEFAULT","SILHOUETTE","COLOR_MASK","SPRITE_ID","PenSkin","framebufferInfo","_createFramebufferInfo","_framebufferInfo","_lastPenState","texture","deleteFramebuffer","framebuffer","pt1","pt2","_setFramebuffer","_shaderManager","shaderChanged","_setShader","uniform2f","u_penSkinSize","oldColor","uniform4f","u_penColor","uniform1f","u_penSize","lineDiffX","lineDiffY","u_penPoints","lineLength","u_lineLength","drawArrays","TRIANGLES","clearColor","COLOR_BUFFER_BIT","bubbleStyle","SpeechBubbleSkin","bubble","_canvas","LINEAR","_bubble","_flipped","_rendered","_renderedScale","_renderBubble","_restyleCanvas","font","textBaseline","flipped","textWidth","measureText","maxWidth","padding","setTransform","fillStyle","strokeStyle","lineWidth","save","w","beginPath","moveTo","arcTo","lineTo","ellipse","closePath","stroke","fill","renderBubbleBackground","restore","fillText","VectorSkin","_imageDataMipLevel","_maxTextureSize","getParameter","MAX_TEXTURE_SIZE","_mipmaps","log2","mipLevel","mipLevelForScale","_drawSvgToCanvas","_createMipmap","mip","Costume","Image","crossOrigin","isBitmap","match","__collisionBox","Renderer","project","renderTarget","createStage","antialias","setRenderTarget","_drawables","WeakMap","_skins","_currentShader","_currentFramebuffer","_screenSpaceScale","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","activeTexture","TEXTURE0","_penSkin","_collisionBuffer","obj","_getDrawable","stencil","createFramebuffer","framebufferTexture2D","FRAMEBUFFER","COLOR_ATTACHMENT0","renderbuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","DEPTH_STENCIL","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","useProgram","attribLocation","a_position","enableVertexAttribArray","vertexAttribPointer","FLOAT","_updateStageSize","bindFramebuffer","viewport","querySelector","classList","add","append","_renderLayers","layers","renderSpeechBubbles","shouldRestrictLayers","shouldFilterLayers","shouldIncludeLayer","layer","renderSprite","penMatrix","_renderSkin","spritesAndClones","u_stageSize","drawingBufferWidth","drawingBufferHeight","_resize","stageSize","getBoundingClientRect","devicePixelRatio","adjustedWidth","adjustedHeight","imageRendering","_calculateSpeechBubbleMatrix","speechBubbleSkin","sprBounds","getBoundingBox","effectMask","colorMask","spriteColorId","skinTexture","uniformMatrix3fv","u_transform","effect","effectVal","u_skinSize","id","uniform1i","u_texture","Array","isArray","uniform4fv","u_colorMask","uniform3fv","u_spriteId","prototype","hasOwnProperty","call","_stencilSprite","STENCIL_BUFFER_BIT","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","opts","ghost","EQUAL","targets","sprColor","sprBox","copy","targetBox","union","cx","cy","collisionBox","intersection","disable","pixelData","Uint8Array","readPixels","targetsColor","pick","hoveredPixel","colorToId","displayAskBox","askBox","askText","innerText","askInput","askButton","focus","e","preventDefault","remove","Input","onKeyDown","_stage","tabIndex","down","_mouseMove","_mouseDown","_mouseUp","_keyup","_keydown","_onKeyDown","scaleX","scaleY","realCoords","clientX","clientY","key","_getKeyName","k","indexOf","substring","toLowerCase","IGNORABLE_ERROR","LoudnessHandler","connectionState","async","stream","navigator","mediaDevices","getUserMedia","audio","resume","hasConnected","audioStream","mic","createMediaStreamSource","analyser","createAnalyser","micDataArray","fftSize","includes","active","getFloatTimeDomainData","sum","rms","_lastValue","getLoudness","Project","frameRate","loudnessHandler","_cachedLoudness","_prevStepTriggerPredicates","setInterval","_renderLoop","attach","state","clickedSprite","matchingTriggers","greenFlag","_matchingTriggers","triggerMatches","spritesAndStage","matchingTargetTriggers","_stepEdgeActivatedTriggers","edgeActivated","triggersToStart","triggerWithTarget","predicate","prevPredicate","alreadyRunningTriggers","render","watcher","updateDOM","requestAnimationFrame","spriteName","runningTrigger","all","sort","layerDelta","relativeToSprite","spritesArray","originalIndex","newIndex","splice","forEach","timerStart","Watcher","setValue","label","initializeDOM","_previousValue","slider","event","_dom","contains","isList","toggle","JSON","stringify","innerHTML","item","itemElem","indexElem","contentElem","_style","textColor","setProperty","_visible","visibility","_width","undefined","_height","_min","_max","_step","_label"],"mappings":"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"}