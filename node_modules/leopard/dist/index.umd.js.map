{"version":3,"file":"index.umd.js","sources":["../src/Trigger.js","../src/renderer/Matrix.js","../src/renderer/Rectangle.js","../src/renderer/effectInfo.js","../src/renderer/effectTransformPoint.js","../src/Color.js","../src/lib/decode-adpcm-audio.js","../src/Sound.js","../src/Sprite.js","../src/renderer/Drawable.js","../src/renderer/Skin.js","../src/renderer/BitmapSkin.js","../src/renderer/Shaders.js","../src/renderer/ShaderManager.js","../src/renderer/PenSkin.js","../src/renderer/SpeechBubbleSkin.js","../src/renderer/VectorSkin.js","../src/Costume.js","../src/Renderer.js","../src/Input.js","../src/Loudness.js","../src/Project.js","../src/Watcher.js"],"sourcesContent":["const GREEN_FLAG = Symbol(\"GREEN_FLAG\");\nconst KEY_PRESSED = Symbol(\"KEY_PRESSED\");\nconst BROADCAST = Symbol(\"BROADCAST\");\nconst CLICKED = Symbol(\"CLICKED\");\nconst CLONE_START = Symbol(\"CLONE_START\");\nconst LOUDNESS_GREATER_THAN = Symbol(\"LOUDNESS_GREATER_THAN\");\nconst TIMER_GREATER_THAN = Symbol(\"TIMER_GREATER_THAN\");\nconst BACKDROP_CHANGED = Symbol(\"BACKDROP_CHANGED\");\n\nexport default class Trigger {\n  constructor(trigger, options, script) {\n    this.trigger = trigger;\n\n    if (typeof script === \"undefined\") {\n      this.options = {};\n      this._script = options;\n    } else {\n      this.options = options;\n      this._script = script;\n    }\n\n    this.done = false;\n    this.stop = () => {};\n  }\n\n  get isEdgeActivated() {\n    return (\n      this.trigger === TIMER_GREATER_THAN ||\n      this.trigger === LOUDNESS_GREATER_THAN\n    );\n  }\n\n  // Evaluate the given trigger option, whether it's a value or a function that\n  // returns a value given a target\n  option(option, target) {\n    let triggerOption = this.options[option];\n    // If the given option is a function, evaluate that function, passing in\n    // the target that we're evaluating the trigger for\n    if (typeof triggerOption === \"function\") {\n      return triggerOption(target);\n    }\n    return triggerOption;\n  }\n\n  matches(trigger, options, target) {\n    if (this.trigger !== trigger) return false;\n    for (let option in options) {\n      if (this.option(option, target) !== options[option]) return false;\n    }\n\n    return true;\n  }\n\n  start(target) {\n    this.stop();\n\n    const boundScript = this._script.bind(target);\n\n    this.done = false;\n    this._runningScript = boundScript();\n\n    return new Promise(resolve => {\n      this.stop = () => {\n        this.done = true;\n        resolve();\n      };\n    });\n  }\n\n  step() {\n    this.done = this._runningScript.next().done;\n    if (this.done) this.stop();\n  }\n\n  static get GREEN_FLAG() {\n    return GREEN_FLAG;\n  }\n  static get KEY_PRESSED() {\n    return KEY_PRESSED;\n  }\n  static get BROADCAST() {\n    return BROADCAST;\n  }\n  static get CLICKED() {\n    return CLICKED;\n  }\n  static get CLONE_START() {\n    return CLONE_START;\n  }\n  static get LOUDNESS_GREATER_THAN() {\n    return LOUDNESS_GREATER_THAN;\n  }\n  static get TIMER_GREATER_THAN() {\n    return TIMER_GREATER_THAN;\n  }\n  static get BACKDROP_CHANGED() {\n    return BACKDROP_CHANGED;\n  }\n}\n","/* Adapted from gl-matrix\n * https://github.com/toji/gl-matrix\n */\n\n// 3x3 transform matrix operations, unrolled 4 da speedz.\nexport default class Matrix {\n  // Create a new 3x3 transform matrix, initialized to the identity matrix.\n  static create() {\n    const matrix = new Float32Array(9);\n    Matrix.identity(matrix);\n    return matrix;\n  }\n\n  // Reset a matrix to the identity matrix\n  static identity(dst) {\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 1;\n    dst[5] = 0;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 1;\n    return dst;\n  }\n\n  // Translate a matrix by the given X and Y values\n  static translate(dst, src, x, y) {\n    const a00 = src[0],\n      a01 = src[1],\n      a02 = src[2],\n      a10 = src[3],\n      a11 = src[4],\n      a12 = src[5],\n      a20 = src[6],\n      a21 = src[7],\n      a22 = src[8];\n\n    dst[0] = a00;\n    dst[1] = a01;\n    dst[2] = a02;\n\n    dst[3] = a10;\n    dst[4] = a11;\n    dst[5] = a12;\n\n    dst[6] = x * a00 + y * a10 + a20;\n    dst[7] = x * a01 + y * a11 + a21;\n    dst[8] = x * a02 + y * a12 + a22;\n    return dst;\n  }\n\n  // Rotate a matrix, in radians\n  static rotate(dst, src, rad) {\n    const a00 = src[0],\n      a01 = src[1],\n      a02 = src[2],\n      a10 = src[3],\n      a11 = src[4],\n      a12 = src[5],\n      a20 = src[6],\n      a21 = src[7],\n      a22 = src[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n\n    dst[0] = c * a00 + s * a10;\n    dst[1] = c * a01 + s * a11;\n    dst[2] = c * a02 + s * a12;\n\n    dst[3] = c * a10 - s * a00;\n    dst[4] = c * a11 - s * a01;\n    dst[5] = c * a12 - s * a02;\n\n    dst[6] = a20;\n    dst[7] = a21;\n    dst[8] = a22;\n    return dst;\n  }\n\n  // Scale a matrix by the given X and Y values\n  static scale(dst, src, x, y) {\n    dst[0] = x * src[0];\n    dst[1] = x * src[1];\n    dst[2] = x * src[2];\n\n    dst[3] = y * src[3];\n    dst[4] = y * src[4];\n    dst[5] = y * src[5];\n\n    dst[6] = src[6];\n    dst[7] = src[7];\n    dst[8] = src[8];\n    return dst;\n  }\n\n  // Transform a 2D point by the given matrix\n  static transformPoint(m, dst, src) {\n    const x = src[0];\n    const y = src[1];\n    dst[0] = m[0] * x + m[3] * y + m[6];\n    dst[1] = m[1] * x + m[4] * y + m[7];\n    return dst;\n  }\n}\n","export default class Rectangle {\n  constructor() {\n    this.left = -Infinity;\n    this.right = Infinity;\n    this.bottom = -Infinity;\n    this.top = Infinity;\n\n    return this;\n  }\n\n  static fromBounds(left, right, bottom, top, result) {\n    if (!result) result = new Rectangle();\n    result.left = left;\n    result.right = right;\n    result.bottom = bottom;\n    result.top = top;\n\n    return result;\n  }\n\n  // Initialize a bounding box around a sprite given the sprite's transform matrix.\n  static fromMatrix(matrix, result) {\n    if (!result) result = new Rectangle();\n\n    // Adapted somewhat from https://github.com/LLK/scratch-render/blob/develop/docs/Rectangle-AABB-Matrix.md\n    const xa = matrix[0] / 2;\n    const xb = matrix[3] / 2;\n    const absx = Math.abs(xa) + Math.abs(xb);\n    const sumx = xa + xb + matrix[6];\n\n    const ya = matrix[1] / 2;\n    const yb = matrix[4] / 2;\n    const absy = Math.abs(ya) + Math.abs(yb);\n    const sumy = ya + yb + matrix[7];\n\n    result.left = sumx - absx;\n    result.right = sumx + absx;\n    result.bottom = sumy - absy;\n    result.top = sumy + absy;\n\n    return result;\n  }\n\n  // Initialize from another rectangle.\n  static copy(src, dst) {\n    dst.left = src.left;\n    dst.right = src.right;\n    dst.bottom = src.bottom;\n    dst.top = src.top;\n    return dst;\n  }\n\n  // Push this rectangle out to integer bounds.\n  // This takes a conservative approach and will always expand the rectangle outwards.\n  snapToInt() {\n    this.left = Math.floor(this.left);\n    this.right = Math.ceil(this.right);\n    this.bottom = Math.floor(this.bottom);\n    this.top = Math.ceil(this.top);\n\n    return this;\n  }\n\n  // Check whether any part of this rectangle touches another rectangle.\n  intersects(rect) {\n    return (\n      this.left <= rect.right &&\n      rect.left <= this.right &&\n      this.top >= rect.bottom &&\n      rect.top >= this.bottom\n    );\n  }\n\n  // Check whether a given point is inside this rectangle.\n  containsPoint(x, y) {\n    return (\n      x >= this.left && x <= this.right && y >= this.bottom && y <= this.top\n    );\n  }\n\n  // Clamp this rectangle within bounds.\n  clamp(left, right, bottom, top) {\n    this.left = Math.min(Math.max(this.left, left), right);\n    this.right = Math.max(Math.min(this.right, right), left);\n    this.bottom = Math.min(Math.max(this.bottom, bottom), top);\n    this.top = Math.max(Math.min(this.top, top), bottom);\n\n    return this;\n  }\n\n  // Compute the union of two rectangles.\n  static union(rect1, rect2, result = new Rectangle()) {\n    result.left = Math.min(rect1.left, rect2.left);\n    result.right = Math.max(rect1.right, rect2.right);\n    result.bottom = Math.min(rect1.bottom, rect2.bottom);\n    result.top = Math.max(rect1.top, rect2.top);\n\n    return result;\n  }\n\n  // Compute the intersection of two rectangles.\n  static intersection(rect1, rect2, result = new Rectangle()) {\n    result.left = Math.max(rect1.left, rect2.left);\n    result.right = Math.min(rect1.right, rect2.right);\n    result.bottom = Math.max(rect1.bottom, rect2.bottom);\n    result.top = Math.min(rect1.top, rect2.top);\n\n    return result;\n  }\n\n  get width() {\n    return this.right - this.left;\n  }\n\n  get height() {\n    return this.top - this.bottom;\n  }\n}\n","// This file exists to specify a mapping from numeric indices to effect names in all places that require it.\nconst effectNames = [\n  \"color\",\n  \"fisheye\",\n  \"whirl\",\n  \"pixelate\",\n  \"mosaic\",\n  \"brightness\",\n  \"ghost\"\n];\n\nconst effectBitmasks = {};\nfor (let i = 0; i < effectNames.length; i++) {\n  effectBitmasks[effectNames[i]] = 1 << i;\n}\n\nexport { effectNames, effectBitmasks };\n","import { effectBitmasks } from \"./effectInfo.js\";\n\nconst CENTER = 0.5;\nconst EPSILON = 1e-3;\n\n// Transform a texture-space point using the effects defined on the given drawable.\nconst effectTransformPoint = (drawable, src, dst) => {\n  const { effects } = drawable._sprite;\n  const effectBitmask = effects._bitmask;\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n\n  if ((effectBitmask & effectBitmasks.mosaic) !== 0) {\n    // float mosaicFactor = clamp(floor(abs(u_mosaic + 10.0) / 10.0 + 0.5), 1.0, 512.0);\n    const mosaicFactor = Math.max(\n      1,\n      Math.min(Math.floor(Math.abs(effects.mosaic + 10) / 10 + 0.5), 512)\n    );\n    // coord = fract(coord * mosaicFactor);\n    dst[0] = (mosaicFactor * dst[0]) % 1;\n    dst[1] = (mosaicFactor * dst[1]) % 1;\n  }\n\n  if ((effectBitmask & effectBitmasks.pixelate) !== 0) {\n    // vec2 pixSize = u_skinSize / (abs(u_pixelate) * 0.1);\n    const skin = drawable.getCurrentSkin();\n    const pixSizeX = skin.width / (Math.abs(effects.pixelate) * 0.1);\n    const pixSizeY = skin.height / (Math.abs(effects.pixelate) * 0.1);\n    // coord = (floor(coord * pixSize) + CENTER) / pixSize;\n    dst[0] = (Math.floor(dst[0] * pixSizeX) + CENTER) / pixSizeX;\n    dst[1] = (Math.floor(dst[1] * pixSizeY) + CENTER) / pixSizeY;\n  }\n\n  if ((effectBitmask & effectBitmasks.whirl) !== 0) {\n    // const float PI_OVER_180 = 0.017453292519943295;\n    const PI_OVER_180 = 0.017453292519943295;\n    // vec2 offset = coord - CENTER;\n    const offsetX = dst[0] - CENTER;\n    const offsetY = dst[1] - CENTER;\n    // float whirlFactor = max(1.0 - (length(offset) * 2.0), 0.0);\n    const offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n    const whirlFactor = Math.max(1 - offsetLength * 2, 0);\n    // float whirl = (-u_whirl * PI_OVER_180) * whirlFactor * whirlFactor;\n    const whirl = -effects.whirl * PI_OVER_180 * whirlFactor * whirlFactor;\n    // float s = sin(whirl);\n    // float c = cos(whirl);\n    const s = Math.sin(whirl);\n    const c = Math.cos(whirl);\n    // mat2 rotationMatrix = mat2(c, -s, s, c);\n    // coord = rotationMatrix * offset + CENTER;\n    dst[0] = c * offsetX + s * offsetY + CENTER;\n    dst[1] = -s * offsetX + c * offsetY + CENTER;\n  }\n\n  if ((effectBitmask & effectBitmasks.fisheye) !== 0) {\n    // vec2 vec = (coord - CENTER) / CENTER;\n    const vecX = (dst[0] - CENTER) / CENTER;\n    const vecY = (dst[1] - CENTER) / CENTER;\n    // float len = length(vec) + epsilon;\n    const len = Math.sqrt(vecX * vecX + vecY * vecY) + EPSILON;\n    // float factor = max(0.0, (u_fisheye + 100.0) / 100.0);\n    const factor = Math.max(0, (effects.fisheye + 100) / 100);\n    // float r = pow(min(len, 1.0), factor) * max(1.0, len);\n    const r = Math.pow(Math.min(len, 1), factor) * Math.max(1, len);\n    // vec2 unit = vec / len;\n    const unitX = vecX / len;\n    const unitY = vecY / len;\n    // coord = CENTER + (r * unit * CENTER);\n    dst[0] = CENTER + r * unitX * CENTER;\n    dst[1] = CENTER + r * unitY * CENTER;\n  }\n\n  return dst;\n};\n\nexport default effectTransformPoint;\n","const clamp = (n, min, max) => Math.max(min, Math.min(max, n));\n\n// https://www.rapidtables.com/convert/color/rgb-to-hsv.html\nfunction rgbToHSV(r, g, b) {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const delta = max - min;\n\n  let h = 0;\n  if (delta === 0) {\n    // Grey. Leave at 0.\n  } else if (max === r) {\n    h = (((g - b) / delta + 6) % 6) / 6;\n  } else if (max === g) {\n    h = (((b - r) / delta + 2) % 6) / 6;\n  } else if (max === b) {\n    h = (((r - g) / delta + 4) % 6) / 6;\n  }\n\n  let s = 0;\n  if (max !== 0) {\n    s = delta / max;\n  }\n\n  let v = max;\n\n  return {\n    h: h * 100,\n    s: s * 100,\n    v: v * 100\n  };\n}\n\n// https://www.rapidtables.com/convert/color/hsv-to-rgb.html\nfunction hsvToRGB(h, s, v) {\n  h = (h / 100) * 360;\n  s /= 100;\n  v /= 100;\n\n  const c = v * s;\n  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n\n  const min = v - c;\n\n  let r = min;\n  let g = min;\n  let b = min;\n\n  if (h < 60) {\n    r += c;\n    g += x;\n  } else if (h < 120) {\n    g += c;\n    r += x;\n  } else if (h < 180) {\n    g += c;\n    b += x;\n  } else if (h < 240) {\n    b += c;\n    g += x;\n  } else if (h < 300) {\n    b += c;\n    r += x;\n  } else if (h < 360) {\n    r += c;\n    b += x;\n  }\n\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\nexport default class Color {\n  constructor(h = 0, s = 0, v = 0, a = 1) {\n    this.h = h;\n    this.s = s;\n    this.v = v;\n    this.a = a;\n  }\n\n  static rgb(r, g, b, a = 1) {\n    const { h, s, v } = rgbToHSV(r, g, b);\n    return new Color(h, s, v, a);\n  }\n\n  static hsv(h, s, v, a = 1) {\n    return new Color(h, s, v, a);\n  }\n\n  static num(n) {\n    n = Number(n);\n\n    // Match Scratch rgba system\n    // https://github.com/LLK/scratch-vm/blob/0dffc65ce99307d048f6b9a10b1c31b01ab0133d/src/util/color.js#L45\n    const a = (n >> 24) & 0xff;\n    const r = (n >> 16) & 0xff;\n    const g = (n >> 8) & 0xff;\n    const b = n & 0xff;\n    return Color.rgb(r, g, b, a > 0 ? a / 255 : 1);\n  }\n\n  // Red\n  get r() {\n    return hsvToRGB(this.h, this.s, this.v).r;\n  }\n  set r(r) {\n    this._setRGB(r, this.g, this.b);\n  }\n\n  // Green\n  get g() {\n    return hsvToRGB(this.h, this.s, this.v).g;\n  }\n  set g(g) {\n    this._setRGB(this.r, g, this.b);\n  }\n\n  // Blue\n  get b() {\n    return hsvToRGB(this.h, this.s, this.v).b;\n  }\n  set b(b) {\n    this._setRGB(this.r, this.g, b);\n  }\n\n  // Alpha\n  get a() {\n    return this._a;\n  }\n  set a(a) {\n    this._a = clamp(a, 0, 1);\n  }\n\n  // Hue\n  get h() {\n    return this._h;\n  }\n  set h(h) {\n    this._h = ((h % 100) + 100) % 100;\n  }\n\n  // Shade\n  get s() {\n    return this._s;\n  }\n  set s(s) {\n    this._s = clamp(s, 0, 100);\n  }\n\n  // Value\n  get v() {\n    return this._v;\n  }\n  set v(v) {\n    this._v = clamp(v, 0, 100);\n  }\n\n  _setRGB(r, g, b) {\n    r = clamp(r, 0, 255);\n    g = clamp(g, 0, 255);\n    b = clamp(b, 0, 255);\n\n    const { h, s, v } = rgbToHSV(r, g, b);\n\n    this.h = h;\n    this.s = s;\n    this.v = v;\n  }\n\n  toHexString(forceIncludeAlpha = false) {\n    const toHexDigits = n => {\n      n = clamp(Math.round(n), 0, 255);\n\n      let str = n.toString(16);\n      if (str.length === 1) {\n        str = \"0\" + str;\n      }\n\n      return str;\n    };\n\n    let hex = \"#\" + [this.r, this.g, this.b].map(toHexDigits).join(\"\");\n    if (forceIncludeAlpha || this.a !== 1) {\n      hex += toHexDigits(this.a * 255);\n    }\n\n    return hex;\n  }\n\n  toRGBString(forceIncludeAlpha = false) {\n    const rgb = [this.r, this.g, this.b].map(Math.round);\n\n    if (forceIncludeAlpha || this.a !== 1) {\n      return `rgba(${rgb.join(\", \")}, ${this.a})`;\n    }\n    return `rgb(${rgb.join(\", \")})`;\n  }\n\n  toRGBA() {\n    const rgb = hsvToRGB(this._h, this._s, this._v);\n    return [rgb.r, rgb.g, rgb.b, this._a * 255];\n  }\n\n  toRGBANormalized() {\n    const rgb = hsvToRGB(this._h, this._s, this._v);\n    return [rgb.r / 255, rgb.g / 255, rgb.b / 255, this._a];\n  }\n\n  toString() {\n    return this.toRGBString();\n  }\n}\n","/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2013-2019 Truman Kilen, Nathan Dinsmore, and Adroitwhiz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n// prettier-ignore\nconst ADPCM_STEPS = [\n  7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107,\n  118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963,\n  1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894,\n  6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\n  32767\n];\n\nconst ADPCM_INDEX = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];\n\nexport default function decodeADPCMAudio(ab, audioContext) {\n  const dv = new DataView(ab);\n  // WAV magic number\n  if (dv.getUint32(0) !== 0x52494646 || dv.getUint32(8) !== 0x57415645) {\n    return Promise.reject(new Error(\"Unrecognized audio format\"));\n  }\n\n  const blocks = {};\n  const l = dv.byteLength - 8;\n  let i = 12;\n  while (i < l) {\n    blocks[\n      String.fromCharCode(\n        dv.getUint8(i),\n        dv.getUint8(i + 1),\n        dv.getUint8(i + 2),\n        dv.getUint8(i + 3)\n      )\n    ] = i;\n    i += 8 + dv.getUint32(i + 4, true);\n  }\n\n  const format = dv.getUint16(20, true);\n  const sampleRate = dv.getUint32(24, true);\n\n  if (format === 17) {\n    const samplesPerBlock = dv.getUint16(38, true);\n    const blockSize = (samplesPerBlock - 1) / 2 + 4;\n\n    const frameCount = dv.getUint32(blocks.fact + 8, true);\n\n    const buffer = audioContext.createBuffer(1, frameCount, sampleRate);\n    const channel = buffer.getChannelData(0);\n\n    let sample;\n    let index = 0;\n    let step, code, delta;\n    let lastByte = -1;\n\n    const offset = blocks.data + 8;\n    let i = offset;\n    let j = 0;\n    // eslint-disable-next-line\n    while (true) {\n      if ((i - offset) % blockSize === 0 && lastByte < 0) {\n        if (i >= dv.byteLength) break;\n        sample = dv.getInt16(i, true);\n        i += 2;\n        index = dv.getUint8(i);\n        i += 1;\n        i++;\n        if (index > 88) index = 88;\n        channel[j++] = sample / 32767;\n      } else {\n        if (lastByte < 0) {\n          if (i >= dv.byteLength) break;\n          lastByte = dv.getUint8(i);\n          i += 1;\n          code = lastByte & 0xf;\n        } else {\n          code = (lastByte >> 4) & 0xf;\n          lastByte = -1;\n        }\n        step = ADPCM_STEPS[index];\n        delta = 0;\n        if (code & 4) delta += step;\n        if (code & 2) delta += step >> 1;\n        if (code & 1) delta += step >> 2;\n        delta += step >> 3;\n        index += ADPCM_INDEX[code];\n        if (index > 88) index = 88;\n        if (index < 0) index = 0;\n        sample += code & 8 ? -delta : delta;\n        if (sample > 32767) sample = 32767;\n        if (sample < -32768) sample = -32768;\n        channel[j++] = sample / 32768;\n      }\n    }\n    return Promise.resolve(buffer);\n  }\n  return Promise.reject(new Error(`Unrecognized WAV format ${format}`));\n}\n\nexport function isWavData(arrayBuffer) {\n  const dataView = new DataView(arrayBuffer);\n  return (\n    dataView.getUint32(0) === 0x52494646 && dataView.getUint32(8) === 0x57415645\n  );\n}\n\nexport function isADPCMData(arrayBuffer) {\n  const dataView = new DataView(arrayBuffer);\n  const format = dataView.getUint16(20, true);\n  return isWavData(arrayBuffer) && format === 17;\n}\n","import decodeADPCMAudio, { isADPCMData } from \"./lib/decode-adpcm-audio.js\";\n\nexport default class Sound {\n  constructor(name, url) {\n    this.name = name;\n    this.url = url;\n\n    this.audioBuffer = null;\n    this.source = null;\n    this.playbackRate = 1;\n\n    // TODO: Remove this line; initiate downloads from somewhere else instead.\n    this.downloadMyAudioBuffer();\n  }\n\n  get duration() {\n    return this.audioBuffer.duration;\n  }\n\n  *start() {\n    let started = false;\n    let isLatestCallToStart = true;\n\n    if (this._markDone) {\n      this._markDone();\n    }\n\n    if (this.audioBuffer) {\n      this.playMyAudioBuffer();\n      started = true;\n    } else {\n      // It's possible that start() will be called again before this start()\n      // has successfully started the sound (i.e. because it was waiting for\n      // the audio buffer to download). If that's the case, _doneDownloading\n      // will already exist. We never want to return from start() before the\n      // sound has begun playing, but in the case of playUntilDone(), only the\n      // latest call should wait for the sound to finish playing; also, we only\n      // need to run playMyAudioBuffer once. To meet all these conditions, and\n      // also to avoid implementing some kind of addEventListener-esque system,\n      // we implement a simple \"listener chain\" here. Every time we set call\n      // start(), we keep track of the previous value of doneDownloading, and\n      // replace it with a new function. When this function is called directly\n      // as a result of the download finishing, it will call, if existent, the\n      // previous value of doneDownloading with a flag indicating it is being\n      // called from a more recent call to start(). That function will in turn\n      // do the same for its saved previous value, and so on, until all the\n      // previous values of doneDownloading have been called. Thus, all\n      // previous calls of start() will then finish, returning their value of\n      // isLatestCallToStart: false, indicating that if the call came from\n      // playUntilDone(), that playUntilDone should not wait for the sound to\n      // finish playing. Of course, the latest call returns true, and so the\n      // containing playUntilDone() (if present) knows to wait.\n      const oldDoneDownloading = this._doneDownloading;\n      this._doneDownloading = fromMoreRecentCall => {\n        if (fromMoreRecentCall) {\n          isLatestCallToStart = false;\n        } else {\n          this.playMyAudioBuffer();\n          started = true;\n          delete this._doneDownloading;\n        }\n        if (oldDoneDownloading) {\n          oldDoneDownloading(true);\n        }\n      };\n    }\n\n    while (!started && isLatestCallToStart) yield;\n\n    return isLatestCallToStart;\n  }\n\n  *playUntilDone() {\n    let playing = true;\n\n    const isLatestCallToStart = yield* this.start();\n\n    // If we failed to download the audio buffer, just stop here - the sound will\n    // never play, so it doesn't make sense to wait for it.\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    this.source.addEventListener(\"ended\", () => {\n      playing = false;\n      delete this._markDone;\n    });\n\n    // If there was another call to start() since ours, don't wait for the\n    // sound to finish before returning.\n    if (!isLatestCallToStart) {\n      return;\n    }\n\n    // Set _markDone after calling start(), because start() will call the existing\n    // value of _markDone if it's already set. It does this because playUntilDone()\n    // is meant to be interrupted if another start() is ran while it's playing.\n    // Of course, we don't want *this* playUntilDone() to be treated as though it\n    // were interrupted when we call start(), so setting _markDone comes after.\n    this._markDone = () => {\n      playing = false;\n      delete this._markDone;\n    };\n\n    while (playing) yield;\n  }\n\n  stop() {\n    if (this._markDone) {\n      this._markDone();\n    }\n\n    if (this.source) {\n      this.source.disconnect();\n      this.source = null;\n    }\n  }\n\n  downloadMyAudioBuffer() {\n    return fetch(this.url)\n      .then(body => body.arrayBuffer())\n      .then(arrayBuffer => {\n        if (isADPCMData(arrayBuffer)) {\n          return decodeADPCMAudio(arrayBuffer, Sound.audioContext).catch(\n            error => {\n              console.warn(\n                `Failed to load sound \"${this.name}\" - will not play:\\n` + error\n              );\n              return null;\n            }\n          );\n        } else {\n          return new Promise((resolve, reject) => {\n            Sound.audioContext.decodeAudioData(arrayBuffer, resolve, reject);\n          });\n        }\n      })\n      .then(audioBuffer => {\n        this.audioBuffer = audioBuffer;\n        if (this._doneDownloading) {\n          this._doneDownloading();\n        }\n        return audioBuffer;\n      });\n  }\n\n  playMyAudioBuffer() {\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    if (this.source) {\n      this.source.disconnect();\n    }\n\n    this.source = Sound.audioContext.createBufferSource();\n    this.source.buffer = this.audioBuffer;\n    this.source.playbackRate.value = this.playbackRate;\n\n    if (this.target) {\n      this.source.connect(this.target);\n    }\n\n    this.source.start(Sound.audioContext.currentTime);\n  }\n\n  connect(target) {\n    if (target !== this.target) {\n      this.target = target;\n      if (this.source) {\n        this.source.disconnect();\n        this.source.connect(this.target);\n      }\n    }\n  }\n\n  setPlaybackRate(value) {\n    this.playbackRate = value;\n    if (this.source) {\n      this.source.playbackRate.value = value;\n    }\n  }\n\n  isConnectedTo(target) {\n    return this.target === target;\n  }\n\n  // Note: \"this\" refers to the Sound class in static functions.\n\n  static get audioContext() {\n    this._setupAudioContext();\n    return this._audioContext;\n  }\n\n  static _setupAudioContext() {\n    if (!this._audioContext) {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      this._audioContext = new AudioContext();\n    }\n  }\n\n  static decodeADPCMAudio(audioBuffer) {\n    return decodeADPCMAudio(audioBuffer, this.audioContext);\n  }\n}\n\nexport class EffectChain {\n  // The code in this class is functionally comparable to the class of the same\n  // name in the scratch-audio library, but is completely rewritten and follows\n  // somewhat different logic. Still, the class exists on the same principle:\n  // a portable way to store the effect chain, independent of the audio sources\n  // it affects.\n\n  constructor(config) {\n    const { getNonPatchSoundList } = config;\n    this.config = config;\n\n    this.inputNode = Sound.audioContext.createGain();\n\n    // This is a mapping of an effect's name to an object containing all the\n    // nodes which are of use to that effect: always an {input, output} pair,\n    // as well as any other nodes of use to that effect. The values here are\n    // filled in by an effect descriptor's makeNodes() function, and may\n    // contain duplicate copies of the same node within a particular effect's\n    // object, when that's of use to make the logic clearer (e.g. when there's\n    // no distinction between the input and output node, or referring to the\n    // output node by a more specific name).\n    this.effectNodes = {};\n\n    this.resetToInitial();\n\n    this.getNonPatchSoundList = getNonPatchSoundList;\n  }\n\n  resetToInitial() {\n    // Note: some effects won't be reset by this function, except for when they\n    // are set for the first time (i.e. when the EffectChain is instantiated).\n    // Look for the \"reset: false\" flag in the effect descriptor list.\n\n    const initials = EffectChain.getInitialEffectValues();\n    if (this.effectValues) {\n      for (const [name, initialValue] of Object.entries(\n        EffectChain.getInitialEffectValues()\n      )) {\n        if (EffectChain.getEffectDescriptor(name).reset !== false) {\n          this.setEffectValue(name, initialValue);\n        }\n      }\n    } else {\n      this.effectValues = initials;\n    }\n  }\n\n  updateAudioEffect(name) {\n    const descriptor = EffectChain.getEffectDescriptor(name);\n\n    if (!descriptor) {\n      return;\n    }\n\n    // updateAudioEffect doesn't take a value - it only reflects the existing\n    // value in the actual effects applied to nodes and sounds!\n    const value = this.effectValues[name];\n\n    if (descriptor.isPatch) {\n      // Here, we search for the next and previous effects in the chain\n      // who have existent nodes. This means we'll skip non-patch effects as\n      // well as effects are set to their initial value.\n\n      let next = descriptor;\n      do {\n        next = EffectChain.getNextEffectDescriptor(next.name);\n      } while (next && !this.effectNodes[next.name]);\n\n      let previous = descriptor;\n      do {\n        previous = EffectChain.getPreviousEffectDescriptor(previous.name);\n      } while (previous && !this.effectNodes[previous.name]);\n\n      // If we have previous and next values available, they'll currently be\n      // the corresponding descriptors. But we only ever need to access the\n      // nodes which correspond to those descriptor's names, so we replace them\n      // with the actual objects containing the effect's nodes here to simplify\n      // later code.\n\n      if (next) {\n        next = this.effectNodes[next.name];\n      }\n\n      if (previous) {\n        next = this.effectNodes[previous.name];\n      }\n\n      // If there is no preceding or following effect which has existent nodes,\n      // we'll make the variables reference the target input and target nodes\n      // of the EffectChain - i.e, the two ends of the chain, as far as this\n      // class is concerned. (Note that while the input node will always be\n      // present, because it's defined right on the EffectChain, it's possible\n      // that there won't be any target node, leaving the value for \"next\"\n      // still null.)\n      //\n      // We do need to keep to the structure that effectNodes contains, though.\n      // When we access the previous node (or the EffectChain's input node, in\n      // this case), we'll be making a connection with its output; likewise,\n      // when we're accessing the next node (or the EffectChain's target),\n      // we'll be connecting something to its input. That's reflected in the\n      // values here.\n\n      if (!previous) {\n        previous = { output: this.inputNode };\n      }\n\n      if (!next && this.target) {\n        next = { input: this.target };\n      }\n\n      // \"Patch\" effects are applied by sending audio data through an ordered\n      // series - i.e, a chain - of WebAudio nodes. All effects have an input\n      // node and an output node; for simple effects, these may actually be the\n      // same node. (Take a look at the volume effect, which uses a single Gain\n      // node as both its input and output.) Other effects are more complex.\n      // The code in this block controls the actual chaining behavior of\n      // EffectChain, assuring that all effects form a clean chain.\n      let nodes = this.effectNodes[descriptor.name];\n      if (!nodes && value !== descriptor.initial) {\n        nodes = descriptor.makeNodes();\n        this.effectNodes[descriptor.name] = nodes;\n\n        // Connect the previous effect, or, if there is none, the EffectChain\n        // input, to this effect. Also disconnect it from whatever it was\n        // previously connected to, so we aren't sending data more than one\n        // place at a time - that would mess with the chain.\n        previous.output.disconnect();\n        previous.output.connect(nodes.input);\n\n        // Connect this effect to the next effect, or, if there is none,\n        // the EffectChain target.\n        if (next) {\n          nodes.output.connect(next.input);\n        }\n      }\n\n      if (value === descriptor.initial) {\n        // If we're setting to the initial value, disconnect and discard the\n        // effect's nodes. It's not necessary to keep nodes that don't cause\n        // an effect in the chain. (We don't need to run the set() behavior\n        // specified on the effect descriptor, since we're disconnecting and\n        // discarding the nodes - the only values that function has access to.)\n        if (nodes) {\n          // There's no need to define custom disposal behavior per effect,\n          // since it's always a matter of simply disconnecting every node.\n          // The disconnect() method of a WebAudio node won't error if it's\n          // already had all its connections removed, but we avoid redundant\n          // calls here anyway.\n          for (const node of new Set(Object.values(nodes))) {\n            node.disconnect();\n          }\n\n          // We also need to establish a connection between the adjacent nodes\n          // (which may be the EffectChain's input node and target node, if\n          // there aren't any adjacent effect nodes).\n          if (next) {\n            previous.output.connect(next.input);\n          }\n\n          // Finally, we discard the object which holds the effect's nodes.\n          // We aren't going to be using it anymore, and we need it gone so\n          // that we recreate the nodes and correctly position them back in\n          // the chain, if we use this effect again later.\n          delete this.effectNodes[name];\n        }\n      } else {\n        descriptor.set(value, nodes);\n      }\n    } else {\n      // Non-\"patch\" effects operate directly on Sound objects, accessing\n      // APIs provided by that class. The actual sound list is provided by the\n      // caller of EffectChain.\n      for (const sound of this.getNonPatchSoundList()) {\n        descriptor.set(value, sound);\n      }\n    }\n  }\n\n  connect(target) {\n    this.target = target;\n\n    // All the code here is basically the same as what's written in\n    // updateAudioEffect above; specific to this function, we want to\n    // disconnect the final output in the chain - which may be the input\n    // node - and then connect it to the newly specified target.\n\n    let last = EffectChain.getLastEffectDescriptor();\n    do {\n      last = EffectChain.getPreviousEffectDescriptor(last.name);\n    } while (last && !this.effectNodes[last.name]);\n\n    if (last) {\n      last = this.effectNodes[last.name];\n    } else {\n      last = { output: this.inputNode };\n    }\n\n    last.output.disconnect();\n    last.output.connect(target);\n  }\n\n  setEffectValue(name, value) {\n    value = Number(value);\n    if (\n      name in this.effectValues &&\n      !isNaN(value) &&\n      value !== this.effectValues[name]\n    ) {\n      this.effectValues[name] = value;\n      this.clampEffectValue(name);\n      this.updateAudioEffect(name);\n    }\n  }\n\n  changeEffectValue(name, value) {\n    value = Number(value);\n    if (name in this.effectValues && !isNaN(value) && value !== 0) {\n      this.effectValues[name] += value;\n      this.clampEffectValue(name);\n      this.updateAudioEffect(name);\n    }\n  }\n\n  clampEffectValue(name) {\n    // Not all effects are clamped (pitch, for example); it's also possible to\n    // specify only a minimum or maximum bound, instead of both.\n    const descriptor = EffectChain.getEffectDescriptor(name);\n    let value = this.effectValues[name];\n    if (\"minimum\" in descriptor && value < descriptor.minimum) {\n      value = descriptor.minimum;\n    } else if (\"maximum\" in descriptor && value > descriptor.maximum) {\n      value = descriptor.maximum;\n    }\n    this.effectValues[name] = value;\n  }\n\n  getEffectValue(name) {\n    return this.effectValues[name] || 0;\n  }\n\n  clone(newConfig) {\n    const newEffectChain = new EffectChain(\n      Object.assign({}, this.config, newConfig)\n    );\n\n    for (const [name, value] of Object.entries(this.effectValues)) {\n      const descriptor = EffectChain.getEffectDescriptor(name);\n      if (!descriptor.resetOnClone) {\n        newEffectChain.setEffectValue(name, value);\n      }\n    }\n\n    newEffectChain.connect(this.target);\n\n    return newEffectChain;\n  }\n\n  applyToSound(sound) {\n    sound.connect(this.inputNode);\n\n    for (const [name, value] of Object.entries(this.effectValues)) {\n      const descriptor = EffectChain.getEffectDescriptor(name);\n      if (!descriptor.isPatch) {\n        descriptor.set(value, sound);\n      }\n    }\n  }\n\n  isTargetOf(sound) {\n    return sound.isConnectedTo(this.inputNode);\n  }\n\n  static getInitialEffectValues() {\n    // This would be an excellent place to use Object.fromEntries, but that\n    // function has been implemented in only the latest of a few modern\n    // browsers. :P\n    const initials = {};\n    for (const { name, initial } of this.effectDescriptors) {\n      initials[name] = initial;\n    }\n    return initials;\n  }\n\n  static getEffectDescriptor(name) {\n    return this.effectDescriptors.find(descriptor => descriptor.name === name);\n  }\n\n  static getFirstEffectDescriptor() {\n    return this.effectDescriptors[0];\n  }\n\n  static getLastEffectDescriptor() {\n    return this.effectDescriptors[this.effectDescriptors.length - 1];\n  }\n\n  static getNextEffectDescriptor(name) {\n    // .find() provides three values to its passed function: the value of the\n    // current item, that item's index, and the array on which .find() is\n    // operating. In this case, we're only concerned with the index.\n    // For each item in the list, besides the first, we check if the item\n    // before it matches the name we were given. By initially shifting all the\n    // descriptors using slice(1), the index of any item in the shifted list\n    // corresponds to the previous item in the original list. Thus, if that\n    // previous item matches the provided name, by definition, we'll have found\n    // the item which comes after it.\n    return this.effectDescriptors\n      .slice(1)\n      .find((_, i) => this.effectDescriptors[i].name === name);\n  }\n\n  static getPreviousEffectDescriptor(name) {\n    // This function's a little simpler, since it doesn't involve shifting the\n    // list. We still use slice(), but this time simply to cut off the last\n    // item; that item will never come before any other, after all. We search\n    // the list for the item whose following item matches the provided name,\n    // using the more typical [i + 1] way of accessing an adjacent item.\n    // (In getNextEffectDescriptor(), we don't need to offset the index like\n    // that, because the shift already lines up the index as we need it.)\n    return this.effectDescriptors\n      .slice(0, -1)\n      .find((_, i) => this.effectDescriptors[i + 1].name === name);\n  }\n}\n\n// These are constant values which can be affected to tweak the way effects\n// are applied. They match the values used in Scratch 3.0.\nEffectChain.decayDuration = 0.025;\nEffectChain.decayWait = 0.05;\n\n// Instead of creating a basic Effect class and then implementing a subclass\n// for each effect type, we use a simplified object-descriptor style.\n// The makeNodes() function returns an object which is passed on to set(), so\n// that effects are able to access a variety of nodes (or other values, if\n// necessary) required to execute the desired effect.\n//\n// The code in makeNodes as well as the general definition for each effect is\n// all graciously based on LLK's scratch-audio library.\n//\n// The initial value of an effect should always be the value at which the\n// sound is not affected at all - i.e, it would be the same if the effect\n// nodes were completely disconnected from the chain or otherwise had never\n// been applied. This allows for clean discarding of effect nodes when returned\n// to the initial value.\n//\n// The order of this array matches AudioEngine's effects list in scratch-audio.\n// Earlier in the list is closer to the EffectChain input node; later is closer\n// to its target (output). Note that a non-\"patch\" effect's position in the\n// array has no bearing on effect behavior, since it isn't part of the chain\n// system.\n//\n// Note that this descriptor list is fairly easy to build on, if we'd like to\n// add more audio effects in the future. (Scratch used to have more, but they\n// were removed - see commit ff6cd4a - because they depended on an external\n// library and were too processor-intensive to support on some devices.)\nEffectChain.effectDescriptors = [\n  {\n    name: \"pan\",\n    initial: 0,\n    minimum: -100,\n    maximum: 100,\n    isPatch: true,\n    makeNodes() {\n      const aCtx = Sound.audioContext;\n      const input = aCtx.createGain();\n      const leftGain = aCtx.createGain();\n      const rightGain = aCtx.createGain();\n      const channelMerger = aCtx.createChannelMerger(2);\n      const output = channelMerger;\n      input.connect(leftGain);\n      input.connect(rightGain);\n      leftGain.connect(channelMerger, 0, 0);\n      rightGain.connect(channelMerger, 0, 1);\n      return { input, output, leftGain, rightGain, channelMerger };\n    },\n    set(value, { input, output, leftGain, rightGain }) {\n      const p = (value + 100) / 200;\n      const leftVal = Math.cos((p * Math.PI) / 2);\n      const rightVal = Math.sin((p * Math.PI) / 2);\n      const { currentTime } = Sound.audioContext;\n      const { decayWait, decayDuration } = EffectChain;\n      leftGain.gain.setTargetAtTime(\n        leftVal,\n        currentTime + decayWait,\n        decayDuration\n      );\n      rightGain.gain.setTargetAtTime(\n        rightVal,\n        currentTime + decayWait,\n        decayDuration\n      );\n    }\n  },\n  {\n    name: \"pitch\",\n    initial: 0,\n    isPatch: false,\n    set(value, sound) {\n      const interval = value / 10;\n      const ratio = Math.pow(2, interval / 12);\n      sound.setPlaybackRate(ratio);\n    }\n  },\n  {\n    name: \"volume\",\n    initial: 100,\n    minimum: 0,\n    maximum: 100,\n    resetOnStart: false,\n    resetOnClone: true,\n    isPatch: true,\n    makeNodes() {\n      const node = Sound.audioContext.createGain();\n      return {\n        input: node,\n        output: node,\n        node\n      };\n    },\n    set(value, { node }) {\n      node.gain.linearRampToValueAtTime(\n        value / 100,\n        Sound.audioContext.currentTime + EffectChain.decayDuration\n      );\n    }\n  }\n];\n\nexport class AudioEffectMap {\n  // This class provides a simple interface for setting and getting audio\n  // effects stored on an EffectChain, similar to EffectMap (that class being\n  // for graphic effects). It takes an EffectChain and automatically generates\n  // properties according to the names of the effect descriptors, acting with\n  // the EffectChain's API when accessed.\n\n  constructor(effectChain) {\n    this.effectChain = effectChain;\n\n    for (const { name } of EffectChain.effectDescriptors) {\n      Object.defineProperty(this, name, {\n        get: () => effectChain.getEffectValue(name),\n        set: value => effectChain.setEffectValue(name, value)\n      });\n    }\n  }\n\n  clear() {\n    this.effectChain.resetToInitial();\n  }\n}\n","import Color from \"./Color.js\";\nimport Trigger from \"./Trigger.js\";\nimport Sound, { EffectChain, AudioEffectMap } from \"./Sound.js\";\n\nimport { effectNames } from \"./renderer/effectInfo.js\";\n// This is a wrapper to allow the enabled effects in a sprite to be used as a Map key.\n// By setting an effect, the bitmask is updated as well.\n// This allows the bitmask to be used to uniquely identify a set of enabled effects.\nclass _EffectMap {\n  constructor() {\n    this._bitmask = 0;\n    this._effectValues = {};\n\n    for (let i = 0; i < effectNames.length; i++) {\n      const effectName = effectNames[i];\n      this._effectValues[effectName] = 0;\n\n      Object.defineProperty(this, effectName, {\n        get: () => {\n          return this._effectValues[effectName];\n        },\n\n        set: val => {\n          this._effectValues[effectName] = val;\n\n          if (val === 0) {\n            // If the effect value is 0, meaning it's disabled, set its bit in the bitmask to 0.\n            this._bitmask = this._bitmask & ~(1 << i);\n          } else {\n            // Otherwise, set its bit to 1.\n            this._bitmask = this._bitmask | (1 << i);\n          }\n        }\n      });\n    }\n  }\n\n  _clone() {\n    const m = new _EffectMap();\n    for (const effectName of Object.keys(this._effectValues)) {\n      m[effectName] = this[effectName];\n    }\n    return m;\n  }\n\n  clear() {\n    for (const effectName of Object.keys(this._effectValues)) {\n      this._effectValues[effectName] = 0;\n    }\n    this._bitmask = 0;\n  }\n}\n\nclass SpriteBase {\n  constructor(initialConditions, vars = {}) {\n    this._project = null;\n\n    const { costumeNumber, layerOrder = 0 } = initialConditions;\n    this._costumeNumber = costumeNumber;\n    this._layerOrder = layerOrder;\n\n    this.triggers = [];\n    this.watchers = {};\n    this.costumes = [];\n    this.sounds = [];\n\n    this.effectChain = new EffectChain({\n      getNonPatchSoundList: this.getSoundsPlayedByMe.bind(this)\n    });\n    this.effectChain.connect(Sound.audioContext.destination);\n\n    this.effects = new _EffectMap();\n    this.audioEffects = new AudioEffectMap(this.effectChain);\n\n    this._vars = vars;\n  }\n\n  getSoundsPlayedByMe() {\n    return this.sounds.filter(sound => this.effectChain.isTargetOf(sound));\n  }\n\n  get stage() {\n    return this._project.stage;\n  }\n\n  get sprites() {\n    return this._project.sprites;\n  }\n\n  get vars() {\n    return this._vars;\n  }\n\n  get costumeNumber() {\n    return this._costumeNumber;\n  }\n\n  set costumeNumber(number) {\n    this._costumeNumber = ((number - 1) % this.costumes.length) + 1;\n    if (this.fireBackdropChanged) this.fireBackdropChanged();\n  }\n\n  set costume(costume) {\n    if (typeof costume === \"number\") {\n      this.costumeNumber = costume;\n    }\n    if (typeof costume === \"string\") {\n      const index = this.costumes.findIndex(c => c.name === costume);\n      if (index > -1) {\n        this.costumeNumber = index + 1;\n      } else {\n        switch (costume) {\n          case \"next costume\":\n          case \"next backdrop\": {\n            this.costumeNumber = this.costumeNumber + 1;\n            break;\n          }\n\n          case \"previous costume\":\n          case \"previous backdrop\": {\n            this.costumeNumber = this.costumeNumber - 1;\n            break;\n          }\n\n          case \"random costume\":\n          case \"random backdrop\": {\n            // Based on joker314's inclusiveRandIntWithout: https://github.com/LLK/scratch-vm/pull/2011\n            // Note: We use 1 -> length instead of 0 -> length-1, since we want a 1-indexed result.\n            const lower = 1;\n            const upper = this.costumes.length;\n            const excluded = this.costumeNumber;\n\n            const possibleOptions = upper - lower;\n            let randInt = lower + Math.floor(Math.random() * possibleOptions);\n            if (randInt >= excluded) {\n              randInt++;\n            }\n\n            this.costumeNumber = randInt;\n            break;\n          }\n\n          default: {\n            if (!(isNaN(costume) || costume.trim().length === 0)) {\n              this.costumeNumber = Number(costume);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  get costume() {\n    return this.costumes[this.costumeNumber - 1];\n  }\n\n  moveAhead(value = Infinity) {\n    if (typeof value === \"number\") {\n      this._project.changeSpriteLayer(this, value);\n    } else {\n      this._project.changeSpriteLayer(this, 1, value);\n    }\n  }\n\n  moveBehind(value = Infinity) {\n    if (typeof value === \"number\") {\n      this._project.changeSpriteLayer(this, -value);\n    } else {\n      this._project.changeSpriteLayer(this, -1, value);\n    }\n  }\n\n  degToRad(deg) {\n    return (deg * Math.PI) / 180;\n  }\n\n  radToDeg(rad) {\n    return (rad * 180) / Math.PI;\n  }\n\n  degToScratch(deg) {\n    return -deg + 90;\n  }\n\n  scratchToDeg(scratchDir) {\n    return -scratchDir + 90;\n  }\n\n  radToScratch(rad) {\n    return this.degToScratch(this.radToDeg(rad));\n  }\n\n  scratchToRad(scratchDir) {\n    return this.degToRad(this.scratchToDeg(scratchDir));\n  }\n\n  // Wrap rotation from -180 to 180.\n  normalizeDeg(deg) {\n    // This is a pretty big math expression, but it's necessary because in JavaScript,\n    // the % operator means \"remainder\", not \"modulo\", and so negative numbers won't \"wrap around\".\n    // See https://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm\n    return ((((deg + 180) % 360) + 360) % 360) - 180;\n  }\n\n  // Given a generator function, return a version of it that runs in \"warp mode\" (no yields).\n  warp(procedure) {\n    const bound = procedure.bind(this);\n    return (...args) => {\n      const inst = bound(...args);\n      while (!inst.next().done);\n    };\n  }\n\n  random(a, b) {\n    const min = Math.min(a, b);\n    const max = Math.max(a, b);\n    if (min % 1 === 0 && max % 1 === 0) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return Math.random() * (max - min) + min;\n  }\n\n  *wait(secs) {\n    let endTime = new Date();\n    endTime.setMilliseconds(endTime.getMilliseconds() + secs * 1000);\n    while (new Date() < endTime) {\n      yield;\n    }\n  }\n\n  get mouse() {\n    return this._project.input.mouse;\n  }\n\n  keyPressed(name) {\n    return this._project.input.keyPressed(name);\n  }\n\n  get timer() {\n    return this._project.timer;\n  }\n\n  restartTimer() {\n    this._project.restartTimer();\n  }\n\n  *startSound(soundName) {\n    const sound = this.getSound(soundName);\n    if (sound) {\n      this.effectChain.applyToSound(sound);\n      yield* sound.start();\n    }\n  }\n\n  *playSoundUntilDone(soundName) {\n    const sound = this.getSound(soundName);\n    if (sound) {\n      sound.connect(this.effectChain.inputNode);\n      this.effectChain.applyToSound(sound);\n      yield* sound.playUntilDone();\n    }\n  }\n\n  getSound(soundName) {\n    if (typeof soundName === \"number\") {\n      return this.sounds[(soundName - 1) % this.sounds.length];\n    } else {\n      return this.sounds.find(s => s.name === soundName);\n    }\n  }\n\n  stopAllSounds() {\n    this._project.stopAllSounds();\n  }\n\n  stopAllOfMySounds() {\n    for (const sound of this.sounds) {\n      sound.stop();\n    }\n  }\n\n  broadcast(name) {\n    return this._project.fireTrigger(Trigger.BROADCAST, { name });\n  }\n\n  *broadcastAndWait(name) {\n    let running = true;\n    this.broadcast(name).then(() => {\n      running = false;\n    });\n\n    while (running) {\n      yield;\n    }\n  }\n\n  clearPen() {\n    this._project.renderer.clearPen();\n  }\n\n  *askAndWait(question) {\n    if (this._speechBubble) {\n      this.say(\"\");\n    }\n\n    let done = false;\n    this._project.askAndWait(question).then(() => {\n      done = true;\n    });\n\n    while (!done) yield;\n  }\n\n  get answer() {\n    return this._project.answer;\n  }\n\n  get loudness() {\n    return this._project.loudness;\n  }\n}\n\nexport class Sprite extends SpriteBase {\n  constructor(initialConditions, ...args) {\n    super(initialConditions, ...args);\n\n    const {\n      x,\n      y,\n      direction,\n      rotationStyle,\n      costumeNumber,\n      size,\n      visible,\n      penDown,\n      penSize,\n      penColor\n    } = initialConditions;\n\n    this._x = x;\n    this._y = y;\n    this._direction = direction;\n    this.rotationStyle = rotationStyle || Sprite.RotationStyle.ALL_AROUND;\n    this._costumeNumber = costumeNumber;\n    this.size = size;\n    this.visible = visible;\n\n    this.parent = null;\n    this.clones = [];\n\n    this._penDown = penDown || false;\n    this.penSize = penSize || 1;\n    this._penColor = penColor || Color.rgb(0, 0, 255);\n\n    this._speechBubble = {\n      text: \"\",\n      style: \"say\",\n      timeout: null\n    };\n  }\n\n  createClone() {\n    const clone = Object.assign(\n      Object.create(Object.getPrototypeOf(this)),\n      this\n    );\n\n    clone._project = this._project;\n    clone.triggers = this.triggers.map(\n      trigger => new Trigger(trigger.trigger, trigger.options, trigger._script)\n    );\n    clone.costumes = this.costumes;\n    clone.sounds = this.sounds;\n    clone._vars = Object.assign({}, this._vars);\n\n    clone._speechBubble = {\n      text: \"\",\n      style: \"say\",\n      timeout: null\n    };\n\n    clone.effects = this.effects._clone();\n\n    // Clones inherit audio effects from the original sprite, for some reason.\n    // Couldn't explain it, but that's the behavior in Scratch 3.0.\n    let original = this;\n    while (original.parent) {\n      original = original.parent;\n    }\n    clone.effectChain = original.effectChain.clone({\n      getNonPatchSoundList: clone.getSoundsPlayedByMe.bind(clone)\n    });\n\n    // Make a new audioEffects interface which acts on the cloned effect chain.\n    clone.audioEffects = new AudioEffectMap(clone.effectChain);\n\n    clone.clones = [];\n    clone.parent = this;\n    this.clones.push(clone);\n\n    // Trigger CLONE_START:\n    const triggers = clone.triggers.filter(tr =>\n      tr.matches(Trigger.CLONE_START, {}, clone)\n    );\n    this._project._startTriggers(\n      triggers.map(trigger => ({ trigger, target: clone }))\n    );\n  }\n\n  deleteThisClone() {\n    if (this.parent === null) return;\n\n    this.parent.clones = this.parent.clones.filter(clone => clone !== this);\n\n    this._project.runningTriggers = this._project.runningTriggers.filter(\n      ({ target }) => target !== this\n    );\n  }\n\n  andClones() {\n    return [this, ...this.clones.flatMap(clone => clone.andClones())];\n  }\n\n  get direction() {\n    return this._direction;\n  }\n\n  set direction(dir) {\n    this._direction = this.normalizeDeg(dir);\n  }\n\n  goto(x, y) {\n    if (x === this.x && y === this.y) return;\n\n    if (this.penDown) {\n      this._project.renderer.penLine(\n        { x: this._x, y: this._y },\n        { x, y },\n        this._penColor,\n        this.penSize\n      );\n    }\n\n    this._x = x;\n    this._y = y;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  set x(x) {\n    this.goto(x, this._y);\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set y(y) {\n    this.goto(this._x, y);\n  }\n\n  move(dist) {\n    const moveDir = this.scratchToRad(this.direction);\n\n    this.goto(\n      this._x + dist * Math.cos(moveDir),\n      this._y + dist * Math.sin(moveDir)\n    );\n  }\n\n  *glide(seconds, x, y) {\n    const interpolate = (a, b, t) => a + (b - a) * t;\n\n    const startTime = new Date();\n    const startX = this._x;\n    const startY = this._y;\n\n    let t;\n    do {\n      t = (new Date() - startTime) / (seconds * 1000);\n      this.goto(interpolate(startX, x, t), interpolate(startY, y, t));\n      yield;\n    } while (t < 1);\n  }\n\n  get penDown() {\n    return this._penDown;\n  }\n\n  set penDown(penDown) {\n    if (penDown) {\n      this._project.renderer.penLine(\n        { x: this.x, y: this.y },\n        { x: this.x, y: this.y },\n        this._penColor,\n        this.penSize\n      );\n    }\n    this._penDown = penDown;\n  }\n\n  get penColor() {\n    return this._penColor;\n  }\n\n  set penColor(color) {\n    if (color instanceof Color) {\n      this._penColor = color;\n    } else {\n      console.error(\n        `${color} is not a valid penColor. Try using the Color class!`\n      );\n    }\n  }\n\n  stamp() {\n    this._project.renderer.stamp(this);\n  }\n\n  touching(target, fast = false) {\n    if (typeof target === \"string\") {\n      switch (target) {\n        case \"mouse\":\n          return this._project.renderer.checkPointCollision(\n            this,\n            {\n              x: this.mouse.x,\n              y: this.mouse.y\n            },\n            fast\n          );\n        case \"edge\": {\n          const bounds = this._project.renderer.getTightBoundingBox(this);\n          const stageWidth = this.stage.width;\n          const stageHeight = this.stage.height;\n          return (\n            bounds.left < -stageWidth / 2 ||\n            bounds.right > stageWidth / 2 ||\n            bounds.top > stageHeight / 2 ||\n            bounds.bottom < -stageHeight / 2\n          );\n        }\n        default:\n          console.error(\n            `Cannot find target \"${target}\" in \"touching\". Did you mean to pass a sprite class instead?`\n          );\n          return false;\n      }\n    } else if (target instanceof Color) {\n      return this._project.renderer.checkColorCollision(this, target);\n    }\n\n    return this._project.renderer.checkSpriteCollision(this, target, fast);\n  }\n\n  colorTouching(color, target) {\n    if (typeof target === \"string\") {\n      console.error(\n        `Cannot find target \"${target}\" in \"touchingColor\". Did you mean to pass a sprite class instead?`\n      );\n      return false;\n    }\n\n    if (typeof color === \"string\") {\n      console.error(\n        `Cannot find color \"${color}\" in \"touchingColor\". Did you mean to pass a Color instance instead?`\n      );\n      return false;\n    }\n\n    if (target instanceof Color) {\n      // \"Color is touching color\"\n      return this._project.renderer.checkColorCollision(this, target, color);\n    } else {\n      // \"Color is touching sprite\" (not implemented in Scratch!)\n      return this._project.renderer.checkSpriteCollision(\n        this,\n        target,\n        false,\n        color\n      );\n    }\n  }\n\n  say(text) {\n    clearTimeout(this._speechBubble.timeout);\n    this._speechBubble = { text: String(text), style: \"say\", timeout: null };\n  }\n\n  think(text) {\n    clearTimeout(this._speechBubble.timeout);\n    this._speechBubble = { text: String(text), style: \"think\", timeout: null };\n  }\n\n  *sayAndWait(text, seconds) {\n    clearTimeout(this._speechBubble.timeout);\n\n    let done = false;\n    const timeout = setTimeout(() => {\n      this._speechBubble.text = \"\";\n      this.timeout = null;\n      done = true;\n    }, seconds * 1000);\n\n    this._speechBubble = { text, style: \"say\", timeout };\n    while (!done) yield;\n  }\n\n  *thinkAndWait(text, seconds) {\n    clearTimeout(this._speechBubble.timeout);\n\n    let done = false;\n    const timeout = setTimeout(() => {\n      this._speechBubble.text = \"\";\n      this.timeout = null;\n      done = true;\n    }, seconds * 1000);\n\n    this._speechBubble = { text, style: \"think\", timeout };\n    while (!done) yield;\n  }\n}\n\nSprite.RotationStyle = Object.freeze({\n  ALL_AROUND: Symbol(\"ALL_AROUND\"),\n  LEFT_RIGHT: Symbol(\"LEFT_RIGHT\"),\n  DONT_ROTATE: Symbol(\"DONT_ROTATE\")\n});\n\nexport class Stage extends SpriteBase {\n  constructor(initialConditions, ...args) {\n    super(initialConditions, ...args);\n\n    // Use defineProperties to make these non-writable.\n    // Changing the width and height of the stage after initialization isn't supported.\n    Object.defineProperties(this, {\n      width: {\n        value: initialConditions.width || 480,\n        enumerable: true\n      },\n      height: {\n        value: initialConditions.height || 360,\n        enumerable: true\n      }\n    });\n\n    this.name = \"Stage\";\n\n    // For obsolete counter blocks.\n    this.__counter = 0;\n  }\n\n  fireBackdropChanged() {\n    return this._project.fireTrigger(Trigger.BACKDROP_CHANGED, {\n      backdrop: this.costume.name\n    });\n  }\n}\n","import Matrix from \"./Matrix.js\";\n\nimport Rectangle from \"./Rectangle.js\";\nimport effectTransformPoint from \"./effectTransformPoint.js\";\nimport { effectBitmasks } from \"./effectInfo.js\";\n\nimport { Sprite, Stage } from \"../Sprite.js\";\n\n// Returns the determinant of two vectors, the vector from A to B and the vector\n// from A to C. If positive, it means AC is counterclockwise from AB.\n// If negative, AC is clockwise from AB.\nconst determinant = (a, b, c) => {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n};\n\n// Used to track whether a sprite's transform has changed since we last looked\n// at it.\n// TODO: store renderer-specific data on the sprite and have *it* set a\n// \"transform changed\" flag.\nclass SpriteTransformDiff {\n  constructor(sprite) {\n    this._sprite = sprite;\n    this._unset = true;\n    this.update();\n  }\n\n  update() {\n    this._lastX = this._sprite.x;\n    this._lastY = this._sprite.y;\n    this._lastRotation = this._sprite.direction;\n    this._lastRotationStyle = this._sprite.rotationStyle;\n    this._lastSize = this._sprite.size;\n    this._lastCostume = this._sprite.costume;\n    this._lastCostumeLoaded = this._sprite.costume.img.complete;\n    this._unset = false;\n  }\n\n  get changed() {\n    return (\n      this._lastX !== this._sprite.x ||\n      this._lastY !== this._sprite.y ||\n      this._lastRotation !== this._sprite.direction ||\n      this._lastRotationStyle !== this._sprite.rotationStyle ||\n      this._lastSize !== this._sprite.size ||\n      this._lastCostume !== this._sprite.costume ||\n      this._lastCostumeLoaded !== this._sprite.costume.img.complete ||\n      this._unset\n    );\n  }\n}\n\n// Renderer-specific data for an instance (the original or a clone) of a Sprite\nexport default class Drawable {\n  constructor(renderer, sprite) {\n    this._renderer = renderer;\n    this._sprite = sprite;\n\n    // Transformation matrix for the sprite.\n    this._matrix = Matrix.create();\n    // Track when the sprite's transform changes so we can recalculate the\n    // transform matrix.\n    this._matrixDiff = new SpriteTransformDiff(sprite);\n    this._calculateSpriteMatrix();\n\n    // Track when the image data used to calculate the convex hull,\n    // or distortion effects that affect how it's drawn, change.\n    // We also need the image data to know how big the pixels are.\n    this._convexHullImageData = null;\n    this._convexHullMosaic = 0;\n    this._convexHullPixelate = 0;\n    this._convexHullWhirl = 0;\n    this._convexHullFisheye = 0;\n    this._convexHullPoints = null;\n\n    this._aabb = new Rectangle();\n    this._tightBoundingBox = new Rectangle();\n    // Track when the sprite's transform changes so we can recalculate the\n    // tight bounding box.\n    this._convexHullMatrixDiff = new SpriteTransformDiff(sprite);\n  }\n\n  getCurrentSkin() {\n    return this._renderer._getSkin(this._sprite.costume);\n  }\n\n  // Get the rough axis-aligned bounding box for this sprite. Not as tight as\n  // getTightBoundingBox, especially when rotated.\n  getAABB() {\n    return Rectangle.fromMatrix(this.getMatrix(), this._aabb);\n  }\n\n  // Get the Scratch-space tight bounding box for this sprite.\n  getTightBoundingBox() {\n    if (!this._convexHullMatrixDiff.changed) return this._tightBoundingBox;\n\n    const matrix = this.getMatrix();\n    const convexHullPoints = this._calculateConvexHull();\n    // Maybe the costume isn't loaded yet. Return a 0x0 bounding box around the\n    // center of the sprite.\n    if (convexHullPoints === null) {\n      return Rectangle.fromBounds(\n        this._sprite.x,\n        this._sprite.y,\n        this._sprite.x,\n        this._sprite.y,\n        this._tightBoundingBox\n      );\n    }\n\n    let left = Infinity;\n    let right = -Infinity;\n    let top = -Infinity;\n    let bottom = Infinity;\n    const transformedPoint = [0, 0];\n\n    // Each convex hull point is the center of a pixel. However, said pixels\n    // each have area. We must take into account the size of the pixels when\n    // calculating the bounds. The pixel dimensions depend on the scale and\n    // rotation (as we're treating pixels as squares, which change dimensions\n    // when rotated).\n    const xa = matrix[0] / 2;\n    const xb = matrix[3] / 2;\n    const halfPixelX =\n      (Math.abs(xa) + Math.abs(xb)) / this._convexHullImageData.width;\n    const ya = matrix[1] / 2;\n    const yb = matrix[4] / 2;\n    const halfPixelY =\n      (Math.abs(ya) + Math.abs(yb)) / this._convexHullImageData.height;\n\n    // Transform every point in the convex hull using our transform matrix,\n    // and expand the bounds to include that point.\n    for (let i = 0; i < convexHullPoints.length; i++) {\n      const point = convexHullPoints[i];\n      transformedPoint[0] = point[0];\n      transformedPoint[1] = 1 - point[1];\n      Matrix.transformPoint(matrix, transformedPoint, transformedPoint);\n\n      left = Math.min(left, transformedPoint[0] - halfPixelX);\n      right = Math.max(right, transformedPoint[0] + halfPixelX);\n      top = Math.max(top, transformedPoint[1] + halfPixelY);\n      bottom = Math.min(bottom, transformedPoint[1] - halfPixelY);\n    }\n\n    Rectangle.fromBounds(left, right, bottom, top, this._tightBoundingBox);\n    this._convexHullMatrixDiff.update();\n    return this._tightBoundingBox;\n  }\n\n  _calculateConvexHull() {\n    const sprite = this._sprite;\n    const skin = this.getCurrentSkin();\n    const imageData = skin.getImageData(\n      \"size\" in sprite ? sprite.size / 100 : 1\n    );\n    if (!imageData) return null;\n\n    // We only need to recalculate the convex hull points if the image data's\n    // changed since we last calculated the convex hull, or if the sprite's\n    // effects which distort its shape have changed.\n    const { mosaic, pixelate, whirl, fisheye } = sprite.effects;\n    if (\n      this._convexHullImageData === imageData &&\n      this._convexHullMosaic === mosaic &&\n      this._convexHullPixelate === pixelate &&\n      this._convexHullWhirl === whirl &&\n      this._convexHullFisheye === fisheye\n    ) {\n      return this._convexHullPoints;\n    }\n\n    const effectBitmask =\n      sprite.effects._bitmask &\n      (effectBitmasks.mosaic |\n        effectBitmasks.pixelate |\n        effectBitmasks.whirl |\n        effectBitmasks.fisheye);\n\n    const leftHull = [];\n    const rightHull = [];\n\n    const { width, height, data } = imageData;\n\n    const pixelPos = [0, 0];\n    const effectPos = [0, 0];\n    let currentPoint;\n    // Not Scratch-space: y increases as we go downwards\n    // Loop over all rows of pixels in the costume, starting at the top\n    for (let y = 0; y < height; y++) {\n      pixelPos[1] = (y + 0.5) / height;\n\n      // We start at the leftmost point, then go rightwards until we hit an\n      // opaque pixel\n      let x = 0;\n      for (; x < width; x++) {\n        pixelPos[0] = (x + 0.5) / width;\n        let pixelX = x;\n        let pixelY = y;\n        if (effectBitmask !== 0) {\n          effectTransformPoint(this, pixelPos, effectPos);\n          pixelX = Math.floor(effectPos[0] * width);\n          pixelY = Math.floor(effectPos[1] * height);\n        }\n        // We hit an opaque pixel\n        if (data[(pixelY * width + pixelX) * 4 + 3] > 0) {\n          currentPoint = [pixelPos[0], pixelPos[1]];\n          break;\n        }\n      }\n\n      // There are no opaque pixels on this row. Go to the next one.\n      if (x >= width) continue;\n\n      // If appending the current point to the left hull makes a\n      // counterclockwise turn, we want to append the current point to it.\n      // Otherwise, we remove hull points until the current point makes a\n      // counterclockwise turn with the last two points.\n      while (leftHull.length >= 2) {\n        if (\n          determinant(\n            leftHull[leftHull.length - 1],\n            leftHull[leftHull.length - 2],\n            currentPoint\n          ) > 0\n        ) {\n          break;\n        }\n\n        leftHull.pop();\n      }\n\n      leftHull.push(currentPoint);\n\n      // Now we repeat the process for the right side, looking leftwards for an\n      // opaque pixel.\n      for (x = width - 1; x >= 0; x--) {\n        pixelPos[0] = (x + 0.5) / width;\n        effectTransformPoint(this, pixelPos, effectPos);\n        let pixelX = x;\n        let pixelY = y;\n        if (effectBitmask !== 0) {\n          effectTransformPoint(this, pixelPos, effectPos);\n          pixelX = Math.floor(effectPos[0] * width);\n          pixelY = Math.floor(effectPos[1] * height);\n        }\n        // We hit an opaque pixel\n        if (data[(pixelY * width + pixelX) * 4 + 3] > 0) {\n          currentPoint = [pixelPos[0], pixelPos[1]];\n          break;\n        }\n      }\n\n      // Because we're coming at this from the right, it goes clockwise.\n      while (rightHull.length >= 2) {\n        if (\n          determinant(\n            rightHull[rightHull.length - 1],\n            rightHull[rightHull.length - 2],\n            currentPoint\n          ) < 0\n        ) {\n          break;\n        }\n\n        rightHull.pop();\n      }\n\n      rightHull.push(currentPoint);\n    }\n\n    // Add points from the right side in reverse order so all the points are\n    // clockwise.\n    for (let i = rightHull.length - 1; i >= 0; i--) {\n      leftHull.push(rightHull[i]);\n    }\n\n    this._convexHullPoints = leftHull;\n    this._convexHullMosaic = mosaic;\n    this._convexHullPixelate = pixelate;\n    this._convexHullWhirl = whirl;\n    this._convexHullFisheye = fisheye;\n    this._convexHullImageData = imageData;\n\n    return this._convexHullPoints;\n  }\n\n  _calculateSpriteMatrix() {\n    const m = this._matrix;\n    Matrix.identity(m);\n    const spr = this._sprite;\n    if (!(spr instanceof Stage)) {\n      Matrix.translate(m, m, spr.x, spr.y);\n      switch (spr.rotationStyle) {\n        case Sprite.RotationStyle.ALL_AROUND: {\n          Matrix.rotate(m, m, spr.scratchToRad(spr.direction));\n          break;\n        }\n        case Sprite.RotationStyle.LEFT_RIGHT: {\n          if (spr.direction < 0) Matrix.scale(m, m, -1, 1);\n          break;\n        }\n      }\n\n      const spriteScale = spr.size / 100;\n      Matrix.scale(m, m, spriteScale, spriteScale);\n    }\n\n    const scalingFactor = 1 / spr.costume.resolution;\n    // Rotation centers are in non-Scratch space (positive y-values = down),\n    // but these transforms are in Scratch space (negative y-values = down).\n    Matrix.translate(\n      m,\n      m,\n      -spr.costume.center.x * scalingFactor,\n      (spr.costume.center.y - spr.costume.height) * scalingFactor\n    );\n    Matrix.scale(\n      m,\n      m,\n      spr.costume.width * scalingFactor,\n      spr.costume.height * scalingFactor\n    );\n\n    // Store the values we used to compute the matrix so we only recalculate\n    // the matrix when we really need to.\n    this._matrixDiff.update();\n  }\n\n  getMatrix() {\n    // If all the values we used to calculate the matrix haven't changed since\n    // we last calculated the matrix, we can just return the matrix as-is.\n    if (this._matrixDiff.changed) {\n      this._calculateSpriteMatrix();\n    }\n\n    return this._matrix;\n  }\n}\n","export default class Skin {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n  }\n\n  // Get the skin's texture for a given (screen-space) scale.\n  /* eslint-disable-next-line no-unused-vars */\n  getTexture(scale) {\n    return null;\n  }\n\n  // Get the skin image's ImageData at a given (screen-space) scale.\n  // eslint-disable-next-line no-unused-vars\n  getImageData(scale) {\n    throw new Error(\"getImageData not implemented for this skin type\");\n  }\n\n  // Helper function to create a texture from an image and handle all the boilerplate.\n  _makeTexture(image, filtering) {\n    const gl = this.gl;\n    const glTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, glTexture);\n    // These need to be set because most sprite textures don't have power-of-two dimensions.\n    // Non-power-of-two textures only work with gl.CLAMP_TO_EDGE wrapping behavior,\n    // and because they don't support automatic mipmaps, can only use non-mipmap texture filtering.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\n    if (image)\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        image\n      );\n\n    return glTexture;\n  }\n\n  // Helper function to set this skin's size based on an image that may or may not be loaded.\n  _setSizeFromImage(image) {\n    if (image.complete) {\n      this.width = image.naturalWidth;\n      this.height = image.naturalHeight;\n    } else {\n      image.addEventListener(\"load\", () => {\n        this.width = image.naturalWidth;\n        this.height = image.naturalHeight;\n      });\n    }\n  }\n\n  // Clean up any textures or other objets created by this skin.\n  destroy() {}\n}\n","import Skin from \"./Skin.js\";\n\nexport default class BitmapSkin extends Skin {\n  constructor(renderer, image) {\n    super(renderer);\n\n    this._image = image;\n    this._imageData = null;\n    this._texture = null;\n\n    this._setSizeFromImage(image);\n  }\n\n  getImageData() {\n    // Make sure to handle potentially non-loaded textures\n    if (!this._image.complete) return null;\n\n    if (!this._imageData) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = this._image.naturalWidth || this._image.width;\n      canvas.height = this._image.naturalHeight || this._image.height;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(this._image, 0, 0);\n      // Cache image data so we can reuse it\n      this._imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    return this._imageData;\n  }\n\n  getTexture() {\n    // Make sure to handle potentially non-loaded textures\n    const image = this._image;\n    if (!image.complete) return null;\n\n    if (this._texture === null) {\n      // Use nearest-neighbor (i.e. blocky) texture filtering for bitmaps\n      this._texture = super._makeTexture(image, this.gl.NEAREST);\n    }\n    return this._texture;\n  }\n\n  destroy() {\n    if (this._texture !== null) this.gl.deleteTexture(this._texture);\n  }\n}\n","const SpriteShader = {};\n\nSpriteShader.vertex = `\nprecision mediump float;\n\nattribute vec2 a_position;\nuniform mat3 u_transform;\nuniform vec2 u_stageSize;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n  v_texCoord = vec2(a_position.x, 1.0 - a_position.y);\n  gl_Position = vec4((u_transform * vec3(a_position, 1.0)) / vec3(u_stageSize * 0.5, 1.0), 1.0);\n}\n`;\n\nSpriteShader.fragment = `\nprecision mediump float;\n\nconst float epsilon = 1e-3;\n\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\n\n#ifdef EFFECT_color\nuniform float u_color;\n#endif\n\n#ifdef EFFECT_fisheye\nuniform float u_fisheye;\n#endif\n\n#ifdef EFFECT_whirl\nuniform float u_whirl;\n#endif\n\n#ifdef EFFECT_pixelate\nuniform float u_pixelate;\nuniform vec2 u_skinSize;\n#endif\n\n#ifdef EFFECT_mosaic\nuniform float u_mosaic;\n#endif\n\n#ifdef EFFECT_brightness\nuniform float u_brightness;\n#endif\n\n#ifdef EFFECT_ghost\nuniform float u_ghost;\n#endif\n\n#if defined(EFFECT_whirl) || defined(EFFECT_fisheye) || defined(EFFECT_pixelate)\nconst vec2 CENTER = vec2(0.5, 0.5);\n#endif\n\n#ifdef DRAW_MODE_COLOR_MASK\nuniform vec4 u_colorMask;\n\n// TODO: Scratch 2.0 and Scratch 3.0's CPU path check if the top 6 bits match,\n// which a tolerance of 3/255 should be equivalent to,\n// but Scratch's GPU path has a tolerance of 2/255.\nconst vec3 COLOR_MASK_TOLERANCE = vec3(3.0 / 255.0);\n#endif\n\n#ifdef DRAW_MODE_SPRITE_ID\nuniform vec3 u_spriteId;\n#endif\n\n#ifdef EFFECT_color\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n#endif\n\nvoid main() {\n  vec2 coord = v_texCoord;\n\n  #ifdef EFFECT_mosaic\n  {\n    float mosaicFactor = clamp(floor(abs(u_mosaic + 10.0) / 10.0 + 0.5), 1.0, 512.0);\n    coord = fract(coord * mosaicFactor);\n  }\n  #endif\n\n  #ifdef EFFECT_pixelate\n    vec2 pixSize = u_skinSize / (abs(u_pixelate) * 0.1);\n    coord = (floor(coord * pixSize) + CENTER) / pixSize;\n  #endif\n\n  #ifdef EFFECT_whirl\n  {\n    const float PI_OVER_180 = 0.017453292519943295;\n    vec2 offset = coord - CENTER;\n    float whirlFactor = max(1.0 - (length(offset) * 2.0), 0.0);\n    float whirl = (-u_whirl * PI_OVER_180) * whirlFactor * whirlFactor;\n    float s = sin(whirl);\n    float c = cos(whirl);\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n    coord = rotationMatrix * offset + CENTER;\n  }\n  #endif\n\n  #ifdef EFFECT_fisheye\n  {\n    vec2 vec = (coord - CENTER) / CENTER;\n    float len = length(vec) + epsilon;\n    float factor = max(0.0, (u_fisheye + 100.0) / 100.0);\n    float r = pow(min(len, 1.0), factor) * max(1.0, len);\n    vec2 unit = vec / len;\n    coord = CENTER + (r * unit * CENTER);\n  }\n  #endif\n\n  vec4 color = texture2D(u_texture, coord);\n\n  #if defined(EFFECT_color) || defined(EFFECT_brightness)\n  // Un-premultiply color values by alpha channel\n  vec3 unmul = color.rgb / color.a;\n\n  #ifdef EFFECT_color\n  {\n    vec3 hsv = rgb2hsv(unmul);\n    const float minLightness = 0.11 / 2.0;\n    const float minSaturation = 0.09;\n\n    hsv.z = max(minLightness, hsv.z);\n    hsv.y = max(minSaturation, hsv.y);\n\n    hsv.x = mod(hsv.x + (u_color / 200.0), 1.0);\n\n    unmul = hsv2rgb(hsv);\n  }\n  #endif\n\n  #ifdef EFFECT_brightness\n  {\n    unmul = clamp(unmul + clamp(u_brightness * 0.01, -1.0, 1.0), 0.0, 1.0);\n  }\n  #endif\n\n  color = vec4(unmul * color.a, color.a);\n\n  #endif // defined(defined(EFFECT_color) || defined(EFFECT_brightness))\n\n  #ifdef DRAW_MODE_COLOR_MASK\n  vec3 diff = abs(u_colorMask.rgb - color.rgb);\n  if (any(greaterThan(diff, COLOR_MASK_TOLERANCE))) {\n    discard;\n  }\n  #endif\n\n  #ifdef EFFECT_ghost\n  color *= (1.0 - clamp(u_ghost * 0.01, 0.0, 1.0));\n  #endif\n\n  #ifdef DRAW_MODE_SILHOUETTE\n  if (color.a == 0.0) {\n    discard;\n  }\n  #endif\n\n  #ifdef DRAW_MODE_SPRITE_ID\n  color = color.a > 0.0 ? vec4(u_spriteId, 1.0) : vec4(0.0, 0.0, 0.0, 0.0);\n  #endif\n\n  gl_FragColor = color;\n}\n`;\n\nconst PenLineShader = {};\n\nPenLineShader.vertex = `\nprecision mediump float;\n\nattribute vec2 a_position;\n// The X and Y components of u_penPoints hold the first pen point. The Z and W components hold the difference between\n// the second pen point and the first. This is done because calculating the difference in the shader leads to floating-\n// point error when both points have large-ish coordinates.\nuniform vec4 u_penPoints;\nuniform vec2 u_penSkinSize;\nuniform float u_penSize;\nuniform float u_lineLength;\n\nvarying vec2 v_texCoord;\n\n// Add this to divisors to prevent division by 0, which results in NaNs propagating through calculations.\n// Smaller values can cause problems on some mobile devices.\nconst float epsilon = 1e-3;\n\nvoid main() {\n  // Calculate a rotated (\"tight\") bounding box around the two pen points.\n  // Yes, we're doing this 6 times (once per vertex), but on actual GPU hardware,\n  // it's still faster than doing it in JS combined with the cost of uniformMatrix4fv.\n\n  // Expand line bounds by sqrt(2) / 2 each side-- this ensures that all antialiased pixels\n  // fall within the quad, even at a 45-degree diagonal\n  vec2 position = a_position;\n  float expandedRadius = (u_penSize * 0.5) + 1.4142135623730951;\n\n  // The X coordinate increases along the length of the line. It's 0 at the center of the origin point\n  // and is in pixel-space (so at n pixels along the line, its value is n).\n  v_texCoord.x = mix(0.0, u_lineLength + (expandedRadius * 2.0), a_position.x) - expandedRadius;\n  // The Y coordinate is perpendicular to the line. It's also in pixel-space.\n  v_texCoord.y = ((a_position.y - 0.5) * expandedRadius) + 0.5;\n\n  position.x *= u_lineLength + (2.0 * expandedRadius);\n  position.y *= 2.0 * expandedRadius;\n\n  // 1. Center around first pen point\n  position -= expandedRadius;\n\n  // 2. Rotate quad to line angle\n  vec2 pointDiff = u_penPoints.zw;\n  // Ensure line has a nonzero length so it's rendered properly\n  // As long as either component is nonzero, the line length will be nonzero\n  // If the line is zero-length, give it a bit of horizontal length\n  pointDiff.x = (abs(pointDiff.x) < epsilon && abs(pointDiff.y) < epsilon) ? epsilon : pointDiff.x;\n  // The 'normalized' vector holds rotational values equivalent to sine/cosine\n  // We're applying the standard rotation matrix formula to the position to rotate the quad to the line angle\n  // pointDiff can hold large values so we must divide by u_lineLength instead of calling GLSL's normalize function:\n  // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\n  vec2 normalized = pointDiff / max(u_lineLength, epsilon);\n  position = mat2(normalized.x, normalized.y, -normalized.y, normalized.x) * position;\n\n  // 3. Translate quad\n  position += u_penPoints.xy;\n\n  // 4. Apply view transform\n  position *= 2.0 / u_penSkinSize;\n  gl_Position = vec4(position, 0, 1);\n}\n`;\n\nPenLineShader.fragment = `\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_penPoints;\nuniform vec4 u_penColor;\nuniform float u_penSize;\nuniform float u_lineLength;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  // Maaaaagic antialiased-line-with-round-caps shader.\n\n\t// \"along-the-lineness\". This increases parallel to the line.\n\t// It goes from negative before the start point, to 0.5 through the start to the end, then ramps up again\n\t// past the end point.\n\tfloat d = ((v_texCoord.x - clamp(v_texCoord.x, 0.0, u_lineLength)) * 0.5) + 0.5;\n\n\t// Distance from (0.5, 0.5) to (d, the perpendicular coordinate). When we're in the middle of the line,\n\t// d will be 0.5, so the distance will be 0 at points close to the line and will grow at points further from it.\n\t// For the \"caps\", d will ramp down/up, giving us rounding.\n\t// See https://www.youtube.com/watch?v=PMltMdi1Wzg for a rough outline of the technique used to round the lines.\n\tfloat line = distance(vec2(0.5), vec2(d, v_texCoord.y)) * 2.0;\n\t// Expand out the line by its thickness.\n\tline -= ((u_penSize - 1.0) * 0.5);\n\t// Because \"distance to the center of the line\" decreases the closer we get to the line, but we want more opacity\n\t// the closer we are to the line, invert it.\n\tgl_FragColor = u_penColor * clamp(1.0 - line, 0.0, 1.0);\n}\n`;\n\nexport { SpriteShader, PenLineShader };\n","import { SpriteShader, PenLineShader } from \"./Shaders.js\";\nimport { effectNames, effectBitmasks } from \"./effectInfo.js\";\n\n// Everything contained in a shader. It contains both the program, and the locations of the shader inputs.\nclass Shader {\n  constructor(gl, program) {\n    this.gl = gl;\n    this.program = program;\n    this.uniforms = {};\n    this.attribs = {};\n\n    // In order to pass a value into a shader as an attribute or uniform, you need to know its location.\n    // This maps the names of attributes and uniforms to their locations, accessible via the `uniforms` and `attribs`\n    // properties.\n    const numActiveUniforms = gl.getProgramParameter(\n      program,\n      gl.ACTIVE_UNIFORMS\n    );\n    for (let i = 0; i < numActiveUniforms; i++) {\n      const { name } = gl.getActiveUniform(program, i);\n      this.uniforms[name] = gl.getUniformLocation(program, name);\n    }\n\n    const numActiveAttributes = gl.getProgramParameter(\n      program,\n      gl.ACTIVE_ATTRIBUTES\n    );\n    for (let i = 0; i < numActiveAttributes; i++) {\n      const { name } = gl.getActiveAttrib(program, i);\n      this.attribs[name] = gl.getAttribLocation(program, name);\n    }\n  }\n}\n\nclass ShaderManager {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n\n    // We compile shaders on-demand. Create one shader cache per draw mode.\n    this._shaderCache = {};\n    for (const drawMode of Object.keys(ShaderManager.DrawModes)) {\n      this._shaderCache[drawMode] = new Map();\n    }\n  }\n\n  // Creates and compiles a vertex or fragment shader from the given source code.\n  _createShader(source, type) {\n    const gl = this.gl;\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      const info = gl.getShaderInfoLog(shader);\n      throw \"Could not compile WebGL program. \\n\" + info;\n    }\n\n    return shader;\n  }\n\n  getShader(drawMode, effectBitmask = 0) {\n    const gl = this.gl;\n    // Each combination of enabled effects is compiled to a different shader, with only the needed effect code.\n    // Check if we've already compiled the shader with this set of enabled effects.\n    const shaderMap = this._shaderCache[drawMode];\n    if (shaderMap.has(effectBitmask)) {\n      return shaderMap.get(effectBitmask);\n    } else {\n      let shaderCode;\n      switch (drawMode) {\n        case ShaderManager.DrawModes.PEN_LINE: {\n          shaderCode = PenLineShader;\n          break;\n        }\n        default: {\n          shaderCode = SpriteShader;\n          break;\n        }\n      }\n\n      // Use #define statements for conditional compilation in shader code.\n      let define = `#define DRAW_MODE_${drawMode}\\n`;\n\n      // Add #defines for each enabled effect.\n      for (let i = 0; i < effectNames.length; i++) {\n        const effectName = effectNames[i];\n        if ((effectBitmask & effectBitmasks[effectName]) !== 0) {\n          define += `#define EFFECT_${effectName}\\n`;\n        }\n      }\n\n      const vertShader = this._createShader(\n        define + shaderCode.vertex,\n        gl.VERTEX_SHADER\n      );\n      const fragShader = this._createShader(\n        define + shaderCode.fragment,\n        gl.FRAGMENT_SHADER\n      );\n\n      // Combine the vertex and fragment shaders into a single GL program.\n      const program = gl.createProgram();\n      gl.attachShader(program, vertShader);\n      gl.attachShader(program, fragShader);\n      gl.linkProgram(program);\n\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        const info = gl.getProgramInfoLog(program);\n        throw new Error(\"Could not compile WebGL program. \\n\" + info);\n      }\n\n      const shader = new Shader(gl, program);\n      shaderMap.set(effectBitmask, shader);\n      return shader;\n    }\n  }\n}\n\nShaderManager.DrawModes = {\n  // Used for drawing sprites normally\n  DEFAULT: \"DEFAULT\",\n  // Used for \"touching\" tests. Discards transparent pixels.\n  SILHOUETTE: \"SILHOUETTE\",\n  // Used for \"color is touching color\" tests. Only renders sprite colors which are close to the color passed in, and\n  // discards all pixels of a different color.\n  COLOR_MASK: \"COLOR_MASK\",\n  // Used for picking the topmost sprite and identifying which one it is.\n  // Assigns a color to each sprite.\n  SPRITE_ID: \"SPRITE_ID\",\n  // Used for drawing pen lines.\n  PEN_LINE: \"PEN_LINE\"\n};\n\nexport default ShaderManager;\n","import Skin from \"./Skin.js\";\nimport ShaderManager from \"./ShaderManager.js\";\n\nexport default class PenSkin extends Skin {\n  constructor(renderer, width, height) {\n    super(renderer);\n    this.width = width;\n    this.height = height;\n\n    const framebufferInfo = renderer._createFramebufferInfo(\n      width,\n      height,\n      this.gl.NEAREST\n    );\n    this._framebufferInfo = framebufferInfo;\n\n    this._lastPenState = {\n      size: 0,\n      color: [0, 0, 0, 0]\n    };\n\n    this.clear();\n  }\n\n  destroy() {\n    const gl = this.gl;\n    gl.deleteTexture(this._framebufferInfo.texture);\n    gl.deleteFramebuffer(this._framebufferInfo.framebuffer);\n  }\n\n  getTexture() {\n    return this._framebufferInfo.texture;\n  }\n\n  penLine(pt1, pt2, color, size) {\n    const renderer = this.renderer;\n    renderer._setFramebuffer(this._framebufferInfo);\n\n    const shader = renderer._shaderManager.getShader(\n      ShaderManager.DrawModes.PEN_LINE\n    );\n\n    const gl = this.gl;\n\n    // Set the shader, and check if it actually changed.\n    const shaderChanged = renderer._setShader(shader);\n\n    // These uniforms only need to be set if the shader actually changed.\n    if (shaderChanged) {\n      gl.uniform2f(shader.uniforms.u_penSkinSize, this.width, this.height);\n    }\n\n    // Only set the pen color if it changed or the shader changed.\n    const penColor = color.toRGBANormalized();\n    const oldColor = this._lastPenState.color;\n    if (\n      shaderChanged ||\n      penColor[0] !== oldColor[0] ||\n      penColor[1] !== oldColor[1] ||\n      penColor[2] !== oldColor[2] ||\n      penColor[3] !== oldColor[3]\n    ) {\n      this._lastPenState.color = penColor;\n      gl.uniform4f(\n        shader.uniforms.u_penColor,\n        penColor[0] * penColor[3],\n        penColor[1] * penColor[3],\n        penColor[2] * penColor[3],\n        penColor[3]\n      );\n    }\n\n    // Only set the pen size if it changed or the shader changed.\n    if (shaderChanged || this._lastPenState.size !== size) {\n      this._lastPenState.size = size;\n      gl.uniform1f(shader.uniforms.u_penSize, size);\n    }\n\n    const lineDiffX = pt2.x - pt1.x;\n    const lineDiffY = pt2.y - pt1.y;\n\n    // Offset pen lines of size 1 and 3 so they lie on integer coords.\n    // https://github.com/LLK/scratch-render/blob/791b2750cef140e714b002fd275b5f8434e6df9b/src/PenSkin.js#L167-L170\n    const offset = size === 1 || size === 3 ? 0.5 : 0;\n\n    gl.uniform4f(\n      shader.uniforms.u_penPoints,\n      pt1.x + offset,\n      pt1.y + offset,\n      lineDiffX,\n      lineDiffY\n    );\n\n    // Fun fact: Doing this calculation in the shader has the potential to overflow the floating-point range.\n    // 'mediump' precision is only required to have a range up to 2^14 (16384), so any lines longer than 2^7 (128)\n    // can overflow that, because you're squaring the operands, and they could end up as \"infinity\".\n    // Even GLSL's `length` function won't save us here:\n    // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\n    const lineLength = Math.sqrt(lineDiffX * lineDiffX + lineDiffY * lineDiffY);\n    gl.uniform1f(shader.uniforms.u_lineLength, lineLength);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  clear() {\n    this.renderer._setFramebuffer(this._framebufferInfo);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n  }\n}\n","import Skin from \"./Skin.js\";\n\nconst bubbleStyle = {\n  maxLineWidth: 170,\n  minWidth: 50,\n  strokeWidth: 4,\n  padding: 12,\n  tailHeight: 12\n};\n\n// TODO: multiline speech bubbles\nexport default class SpeechBubbleSkin extends Skin {\n  constructor(renderer, bubble) {\n    super(renderer);\n\n    this._canvas = document.createElement(\"canvas\");\n    this._texture = this._makeTexture(null, this.gl.LINEAR);\n    this._bubble = bubble;\n    this._flipped = false;\n    this._rendered = false;\n    this._renderedScale = 0;\n\n    this.width = 0;\n    this.height = 0;\n    this.offsetX = -bubbleStyle.strokeWidth / 2;\n    this.offsetY = this.offsetX + bubbleStyle.tailHeight;\n\n    this._renderBubble(this._bubble);\n  }\n\n  // To ensure proper text measurement and drawing, it's necessary to restyle the canvas after resizing it.\n  _restyleCanvas() {\n    const ctx = this._canvas.getContext(\"2d\");\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"hanging\";\n  }\n\n  set flipped(flipped) {\n    this._flipped = flipped;\n    this._rendered = false;\n  }\n\n  _renderBubble(bubble, scale) {\n    const canvas = this._canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    const renderBubbleBackground = (x, y, w, h, r, style) => {\n      if (r > w / 2) r = w / 2;\n      if (r > h / 2) r = h / 2;\n      if (r < 0) return;\n\n      ctx.beginPath();\n      ctx.moveTo(x + r, y);\n      ctx.arcTo(x + w, y, x + w, y + h, r);\n      ctx.arcTo(x + w, y + h, x + r, y + h, r);\n      if (style === \"say\") {\n        ctx.lineTo(Math.min(x + 3 * r, x + w - r), y + h);\n        ctx.lineTo(x + r / 2, y + h + r);\n        ctx.lineTo(x + r, y + h);\n      } else if (style === \"think\") {\n        ctx.ellipse(x + r * 2.25, y + h, (r * 3) / 4, r / 2, 0, 0, Math.PI);\n      }\n      ctx.arcTo(x, y + h, x, y, r);\n      ctx.arcTo(x, y, x + w, y, r);\n      ctx.closePath();\n      ctx.stroke();\n      ctx.fill();\n\n      if (style === \"think\") {\n        ctx.beginPath();\n        ctx.ellipse(\n          x + r,\n          y + h + (r * 3) / 4,\n          r / 3,\n          r / 3,\n          0,\n          0,\n          2 * Math.PI\n        );\n        ctx.stroke();\n        ctx.fill();\n      }\n    };\n\n    this._restyleCanvas();\n\n    const { text, style } = bubble;\n    const textWidth = ctx.measureText(text).width;\n\n    const maxWidth = bubbleStyle.maxLineWidth;\n    const padding = bubbleStyle.padding;\n\n    const width = Math.ceil(Math.min(textWidth, maxWidth) + 2 * padding);\n    const height = 10 + 2 * padding;\n\n    this.width = width + bubbleStyle.strokeWidth;\n    this.height = height + bubbleStyle.tailHeight + bubbleStyle.strokeWidth;\n\n    canvas.width = this.width * scale;\n    canvas.height = this.height * scale;\n\n    this._restyleCanvas();\n\n    const x = bubbleStyle.strokeWidth / 2;\n    const y = x;\n\n    ctx.setTransform(scale, 0, 0, scale, 0, 0);\n\n    ctx.fillStyle = \"#fff\";\n    ctx.strokeStyle = \"#ccc\";\n    ctx.lineWidth = bubbleStyle.strokeWidth;\n    ctx.save();\n    if (this._flipped) {\n      ctx.scale(-1, 1);\n      ctx.translate(-this.width, 0);\n    }\n    renderBubbleBackground(x, y, width, height, bubbleStyle.tailHeight, style);\n    ctx.restore();\n\n    ctx.fillStyle = \"#444\";\n    ctx.fillText(text, x + padding, y + padding, maxWidth);\n\n    this._rendered = true;\n    this._renderedScale = scale;\n  }\n\n  getTexture(scale) {\n    if (!this._rendered || this._renderedScale !== scale) {\n      this._renderBubble(this._bubble, scale);\n      const gl = this.gl;\n      gl.bindTexture(gl.TEXTURE_2D, this._texture);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        this._canvas\n      );\n    }\n\n    return this._texture;\n  }\n\n  destroy() {\n    this.gl.deleteTexture(this._texture);\n  }\n}\n","import Skin from \"./Skin.js\";\n\n// This means that the smallest mipmap will be 1/(2**4)th the size of the sprite's \"100%\" size.\nconst MIPMAP_OFFSET = 4;\n\nexport default class VectorSkin extends Skin {\n  constructor(renderer, image) {\n    super(renderer);\n\n    this._image = image;\n    this._canvas = document.createElement(\"canvas\");\n\n    this._imageDataMipLevel = 0;\n    this._imageData = null;\n\n    this._maxTextureSize = renderer.gl.getParameter(\n      renderer.gl.MAX_TEXTURE_SIZE\n    );\n\n    this._setSizeFromImage(image);\n\n    this._mipmaps = new Map();\n  }\n\n  static mipLevelForScale(scale) {\n    return Math.max(Math.ceil(Math.log2(scale)) + MIPMAP_OFFSET, 0);\n  }\n\n  getImageData(scale) {\n    if (!this._image.complete) return null;\n\n    // Round off the scale of the image data drawn to a given power-of-two mip level.\n    const mipLevel = VectorSkin.mipLevelForScale(scale);\n    if (!this._imageData || this._imageDataMipLevel !== mipLevel) {\n      const canvas = this._drawSvgToCanvas(mipLevel);\n      if (canvas === null) return null;\n\n      // Cache image data so we can reuse it\n      this._imageData = canvas\n        .getContext(\"2d\")\n        .getImageData(0, 0, canvas.width, canvas.height);\n      this._imageDataMipLevel = mipLevel;\n    }\n\n    return this._imageData;\n  }\n\n  _drawSvgToCanvas(mipLevel) {\n    const scale = 2 ** (mipLevel - MIPMAP_OFFSET);\n\n    const image = this._image;\n    let width = image.naturalWidth * scale;\n    let height = image.naturalHeight * scale;\n\n    width = Math.round(Math.min(width, this._maxTextureSize));\n    height = Math.round(Math.min(height, this._maxTextureSize));\n\n    // Prevent IndexSizeErrors if the image is too small to render\n    if (width === 0 || height === 0) {\n      return null;\n    }\n\n    // Instead of uploading the image to WebGL as a texture, render the image to a canvas and upload the canvas.\n    const canvas = this._canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    canvas.width = width;\n    canvas.height = height;\n\n    ctx.drawImage(image, 0, 0, width, height);\n    return this._canvas;\n  }\n\n  // TODO: handle proper subpixel positioning when SVG viewbox has non-integer coordinates\n  // This will require rethinking costume + project loading probably\n  _createMipmap(mipLevel) {\n    // Instead of uploading the image to WebGL as a texture, render the image to a canvas and upload the canvas.\n    const canvas = this._drawSvgToCanvas(mipLevel);\n    this._mipmaps.set(\n      mipLevel,\n      // Use linear (i.e. smooth) texture filtering for vectors\n      // If the image is 0x0, we return null. Check for that.\n      canvas === null ? null : this._makeTexture(canvas, this.gl.LINEAR)\n    );\n  }\n\n  getTexture(scale) {\n    if (!this._image.complete) return null;\n\n    // Because WebGL doesn't support vector graphics, substitute a bunch of bitmaps.\n    // This skin contains several renderings of its image at different scales.\n    // We render the SVG at 0.5x scale, 1x scale, 2x scale, 4x scale, etc. and store those as textures,\n    // so we can use the properly-sized texture for whatever scale we're currently rendering at.\n    // Math.ceil(Math.log2(scale)) means we use the \"2x\" texture at 1x-2x scale, the \"4x\" texture at 2x-4x scale, etc.\n    // This means that one texture pixel will always be between 0.5x and 1x the size of one rendered pixel,\n    // but never bigger than one rendered pixel--this prevents blurriness from blowing up the texture too much.\n    const mipLevel = VectorSkin.mipLevelForScale(scale);\n    if (!this._mipmaps.has(mipLevel)) this._createMipmap(mipLevel);\n\n    return this._mipmaps.get(mipLevel);\n  }\n\n  destroy() {\n    for (const mip of this._mipmaps.values()) {\n      this.gl.deleteTexture(mip);\n    }\n  }\n}\n","export default class Costume {\n  constructor(name, url, center = { x: 0, y: 0 }) {\n    this.name = name;\n    this.url = url;\n\n    this.img = new Image();\n    this.img.crossOrigin = \"Anonymous\";\n    this.img.src = this.url;\n\n    // TODO: this is super janky, but fixing this fully requires restructuring costume loading\n    this.isBitmap = !this.url.match(/\\.svg/);\n    this.resolution = this.isBitmap ? 2 : 1;\n\n    this.center = center;\n  }\n\n  get width() {\n    return this.img.naturalWidth;\n  }\n\n  get height() {\n    return this.img.naturalHeight;\n  }\n}\n","import Matrix from \"./renderer/Matrix.js\";\nimport Drawable from \"./renderer/Drawable.js\";\nimport BitmapSkin from \"./renderer/BitmapSkin.js\";\nimport PenSkin from \"./renderer/PenSkin.js\";\nimport SpeechBubbleSkin from \"./renderer/SpeechBubbleSkin.js\";\nimport VectorSkin from \"./renderer/VectorSkin.js\";\nimport Rectangle from \"./renderer/Rectangle.js\";\nimport ShaderManager from \"./renderer/ShaderManager.js\";\nimport { effectNames, effectBitmasks } from \"./renderer/effectInfo.js\";\n\nimport Costume from \"./Costume.js\";\n\n// Rectangle used for checking collision bounds.\n// Rather than create a new one each time, we can just reuse this one.\nconst __collisionBox = new Rectangle();\n\n// Convert a sprite ID/index number to a 24-bit color. The lowest 8 bits are\n// stored in the blue channel, then green, then red.\n// RGB [0, 0, 0] is reserved for \"no sprite here\".\n// This allows for up to 2^24 - 2 different sprites to be rendered at once.\nconst idToColor = id => [\n  (((id + 1) >> 16) & 0xff) / 255,\n  (((id + 1) >> 8) & 0xff) / 255,\n  ((id + 1) & 0xff) / 255\n];\n\n// Convert a 24-bit color back into a sprite ID/index number.\n// -1 means \"no sprite here\".\nconst colorToId = ([r, g, b]) => ((r << 16) | (g << 8) | b) - 1;\n\nexport default class Renderer {\n  constructor(project, renderTarget) {\n    const w = project.stage.width;\n    const h = project.stage.height;\n    this.project = project;\n    this.stage = this.createStage(w, h);\n    this.gl = this.stage.getContext(\"webgl\", { antialias: false });\n\n    if (renderTarget) {\n      this.setRenderTarget(renderTarget);\n    } else {\n      this.renderTarget = null;\n    }\n\n    this._shaderManager = new ShaderManager(this);\n    this._drawables = new WeakMap();\n    this._skins = new WeakMap();\n\n    this._currentShader = null;\n    this._currentFramebuffer = null;\n    this._screenSpaceScale = 1;\n\n    // Initialize a bunch of WebGL state\n    const gl = this.gl;\n\n    // Use premultiplied alpha for proper color blending.\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n    // Initialize vertex buffer. This will draw one 2D quadrilateral.\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n    // These are 6 points which make up 2 triangles which make up 1 quad/rectangle.\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      // Prettier mangles the formatting here but every 2 array values make one (x, y) pair\n      // and every 6 values make one triangle\n      new Float32Array([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]),\n      gl.STATIC_DRAW\n    );\n\n    // Set the active texture unit to 0.\n    gl.activeTexture(gl.TEXTURE0);\n\n    this._penSkin = new PenSkin(this, w, h);\n\n    // This framebuffer is where sprites are drawn for e.g. \"touching\" checks.\n    this._collisionBuffer = this._createFramebufferInfo(\n      w,\n      h,\n      gl.NEAREST,\n      true // stencil\n    );\n  }\n\n  // Retrieve a given object (e.g. costume or speech bubble)'s skin. If it doesn't exist, make one.\n  _getSkin(obj) {\n    if (this._skins.has(obj)) {\n      return this._skins.get(obj);\n    }\n\n    let skin;\n\n    if (obj instanceof Costume) {\n      if (obj.isBitmap) {\n        skin = new BitmapSkin(this, obj.img);\n      } else {\n        skin = new VectorSkin(this, obj.img);\n      }\n    } else {\n      // If it's not a costume, assume it's a speech bubble.\n      skin = new SpeechBubbleSkin(this, obj);\n    }\n    this._skins.set(obj, skin);\n    return skin;\n  }\n\n  // Retrieve the renderer-specific data object for a given sprite or clone. If it doesn't exist, make one.\n  _getDrawable(sprite) {\n    if (this._drawables.has(sprite)) {\n      return this._drawables.get(sprite);\n    }\n    const drawable = new Drawable(this, sprite);\n    this._drawables.set(sprite, drawable);\n    return drawable;\n  }\n\n  // Create a framebuffer info object, which contains the following:\n  // * The framebuffer itself.\n  // * The texture backing the framebuffer.\n  // * The resolution (width and height) of the framebuffer.\n  _createFramebufferInfo(width, height, filtering, stencil = false) {\n    // Create an empty texture with this skin's dimensions.\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      null\n    );\n\n    // Create a framebuffer backed by said texture. This means we can draw onto the framebuffer,\n    // and the results appear in the texture.\n    const framebufferInfo = {\n      texture,\n      width,\n      height,\n      framebuffer: gl.createFramebuffer()\n    };\n    this._setFramebuffer(framebufferInfo);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n\n    // The depth buffer is unnecessary, but WebGL only guarantees\n    // that certain combinations of framebuffer attachments will work, and \"stencil but no depth\" is not among them.\n    if (stencil) {\n      const renderbuffer = gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n      gl.framebufferRenderbuffer(\n        gl.FRAMEBUFFER,\n        gl.DEPTH_STENCIL_ATTACHMENT,\n        gl.RENDERBUFFER,\n        renderbuffer\n      );\n    }\n\n    return framebufferInfo;\n  }\n\n  _setShader(shader) {\n    if (shader !== this._currentShader) {\n      const gl = this.gl;\n      gl.useProgram(shader.program);\n\n      // These attributes and uniforms don't ever change, but must be set whenever a new shader program is used.\n\n      const attribLocation = shader.attribs.a_position;\n      gl.enableVertexAttribArray(attribLocation);\n      // Bind the 'a_position' vertex attribute to the current contents of `gl.ARRAY_BUFFER`, which in this case\n      // is a quadrilateral (as buffered earlier).\n      gl.vertexAttribPointer(\n        attribLocation,\n        2, // every 2 array elements make one vertex.\n        gl.FLOAT, // data type\n        false, // normalized\n        0, // stride (space between attributes)\n        0 // offset (index of the first attribute to start from)\n      );\n\n      this._currentShader = shader;\n      this._updateStageSize();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _setFramebuffer(framebufferInfo) {\n    if (framebufferInfo !== this._currentFramebuffer) {\n      this._currentFramebuffer = framebufferInfo;\n      if (framebufferInfo === null) {\n        // The \"null\" framebuffer means the drawing buffer which we're displaying to the screen.\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n        this._updateStageSize();\n      } else {\n        this.gl.bindFramebuffer(\n          this.gl.FRAMEBUFFER,\n          framebufferInfo.framebuffer\n        );\n        // Make sure to update the drawing viewport to the current framebuffer size.\n        this.gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n      }\n    }\n  }\n\n  setRenderTarget(renderTarget) {\n    if (typeof renderTarget === \"string\") {\n      renderTarget = document.querySelector(renderTarget);\n    }\n    this.renderTarget = renderTarget;\n    this.renderTarget.classList.add(\"leopard__project\");\n    this.renderTarget.style.width = `${this.project.stage.width}px`;\n    this.renderTarget.style.height = `${this.project.stage.height}px`;\n\n    this.renderTarget.append(this.stage);\n  }\n\n  // Handles rendering of all layers (including stage, pen layer, sprites, and all clones) in proper order.\n  _renderLayers(layers, options = {}) {\n    options = Object.assign(\n      {\n        drawMode: ShaderManager.DrawModes.DEFAULT,\n        renderSpeechBubbles: true\n      },\n      options\n    );\n\n    // If we're given a list of layers, filter by that.\n    // If we're given a filter function in the options, filter by that too.\n    // If we're given both, then only include layers which match both.\n    const shouldRestrictLayers = layers instanceof Set;\n    const shouldFilterLayers = typeof options.filter === \"function\";\n    const shouldIncludeLayer = layer =>\n      !(\n        (shouldRestrictLayers && !layers.has(layer)) ||\n        (shouldFilterLayers && !options.filter(layer))\n      );\n\n    // Stage\n    if (shouldIncludeLayer(this.project.stage)) {\n      this.renderSprite(this.project.stage, options);\n    }\n\n    // Pen layer\n    if (shouldIncludeLayer(this._penSkin)) {\n      const penMatrix = Matrix.create();\n      Matrix.scale(\n        penMatrix,\n        penMatrix,\n        this._penSkin.width,\n        -this._penSkin.height\n      );\n      Matrix.translate(penMatrix, penMatrix, -0.5, -0.5);\n\n      this._renderSkin(\n        this._penSkin,\n        options.drawMode,\n        penMatrix,\n        1 /* scale */\n      );\n    }\n\n    // Sprites + clones\n    for (const sprite of this.project.spritesAndClones) {\n      // Stage doesn't have \"visible\" defined, so check if it's strictly false\n      if (shouldIncludeLayer(sprite) && sprite.visible !== false) {\n        this.renderSprite(sprite, options);\n      }\n    }\n  }\n\n  _updateStageSize() {\n    if (this._currentShader) {\n      // The shader is passed things in \"Scratch-space\" (-240, 240) and (-180, 180).\n      // This tells it those dimensions so it can convert them to OpenGL \"clip-space\" (-1, 1).\n      this.gl.uniform2f(\n        this._currentShader.uniforms.u_stageSize,\n        this.project.stage.width,\n        this.project.stage.height\n      );\n    }\n\n    if (this._currentFramebuffer === null) {\n      this.gl.viewport(\n        0,\n        0,\n        this.gl.drawingBufferWidth,\n        this.gl.drawingBufferHeight\n      );\n    }\n  }\n\n  // Keep the canvas size in sync with the CSS size.\n  _resize() {\n    const stageSize = this.stage.getBoundingClientRect();\n    const ratio = window.devicePixelRatio;\n    const adjustedWidth = Math.round(stageSize.width * ratio);\n    const adjustedHeight = Math.round(stageSize.height * ratio);\n    if (\n      this.stage.width !== adjustedWidth ||\n      this.stage.height !== adjustedHeight\n    ) {\n      this.stage.width = adjustedWidth;\n      this.stage.height = adjustedHeight;\n      this._screenSpaceScale = Math.max(\n        adjustedWidth / this.project.stage.width,\n        adjustedHeight / this.project.stage.height\n      );\n\n      this._updateStageSize();\n    }\n  }\n\n  update() {\n    this._resize();\n\n    // Draw to the screen, not to a framebuffer.\n    this._setFramebuffer(null);\n\n    // Clear to opaque white.\n    const gl = this.gl;\n    gl.clearColor(1, 1, 1, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    this._renderLayers();\n  }\n\n  createStage(w, h) {\n    const stage = document.createElement(\"canvas\");\n    stage.width = w;\n    stage.height = h;\n\n    // Size canvas to parent container\n    stage.style.width = stage.style.height = \"100%\";\n\n    // If the container width is a non-integer size, don't blur the canvas.\n    // Chrome:\n    stage.style.imageRendering = \"pixelated\";\n    // Firefox:\n    stage.style.imageRendering = \"crisp-edges\";\n    // Safari + Opera:\n    stage.style.imageRendering = \"-webkit-optimize-contrast\";\n\n    return stage;\n  }\n\n  // Calculate the transform matrix for a speech bubble attached to a sprite.\n  _calculateSpeechBubbleMatrix(spr, speechBubbleSkin) {\n    const sprBounds = this.getBoundingBox(spr);\n    let x;\n    if (\n      speechBubbleSkin.width + sprBounds.right >\n      this.project.stage.width / 2\n    ) {\n      x = sprBounds.left - speechBubbleSkin.width;\n      speechBubbleSkin.flipped = true;\n    } else {\n      x = sprBounds.right;\n      speechBubbleSkin.flipped = false;\n    }\n    x = Math.round(x - speechBubbleSkin.offsetX);\n    const y = Math.round(sprBounds.top - speechBubbleSkin.offsetY);\n\n    const m = Matrix.create();\n    Matrix.translate(m, m, x, y);\n    Matrix.scale(m, m, speechBubbleSkin.width, speechBubbleSkin.height);\n\n    return m;\n  }\n\n  _renderSkin(\n    skin,\n    drawMode,\n    matrix,\n    scale,\n    effects,\n    effectMask,\n    colorMask,\n    spriteColorId\n  ) {\n    const gl = this.gl;\n\n    const skinTexture = skin.getTexture(scale * this._screenSpaceScale);\n    // Skip rendering the skin if it has no texture.\n    if (!skinTexture) return;\n\n    let effectBitmask = effects ? effects._bitmask : 0;\n    if (typeof effectMask === \"number\") effectBitmask &= effectMask;\n    const shader = this._shaderManager.getShader(drawMode, effectBitmask);\n    this._setShader(shader);\n    gl.uniformMatrix3fv(shader.uniforms.u_transform, false, matrix);\n\n    if (effectBitmask !== 0) {\n      for (const effect of effectNames) {\n        const effectVal = effects._effectValues[effect];\n        if (effectVal !== 0)\n          gl.uniform1f(shader.uniforms[`u_${effect}`], effectVal);\n      }\n\n      // Pixelate effect needs the skin size\n      if (effects._effectValues.pixelate !== 0)\n        gl.uniform2f(shader.uniforms.u_skinSize, skin.width, skin.height);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, skinTexture);\n    // All textures are bound to texture unit 0, so that's where the texture sampler should point\n    gl.uniform1i(shader.uniforms.u_texture, 0);\n\n    // Enable color masking mode if set\n    if (Array.isArray(colorMask))\n      this.gl.uniform4fv(this._currentShader.uniforms.u_colorMask, colorMask);\n\n    // Used for mapping drawn sprites back to their indices in a list.\n    // By looking at the color of a given pixel, we can tell which sprite is\n    // the topmost one drawn on that pixel.\n    if (drawMode === ShaderManager.DrawModes.SPRITE_ID) {\n      this.gl.uniform3fv(\n        this._currentShader.uniforms.u_spriteId,\n        idToColor(spriteColorId)\n      );\n    }\n\n    // Actually draw the skin\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n  }\n\n  renderSprite(sprite, options) {\n    const spriteScale = Object.prototype.hasOwnProperty.call(sprite, \"size\")\n      ? sprite.size / 100\n      : 1;\n\n    this._renderSkin(\n      this._getSkin(sprite.costume),\n      options.drawMode,\n      this._getDrawable(sprite).getMatrix(),\n      spriteScale,\n      sprite.effects,\n      options.effectMask,\n      options.colorMask\n    );\n\n    if (\n      options.renderSpeechBubbles &&\n      sprite._speechBubble &&\n      sprite._speechBubble.text !== \"\"\n    ) {\n      const speechBubbleSkin = this._getSkin(sprite._speechBubble);\n\n      this._renderSkin(\n        speechBubbleSkin,\n        options.drawMode,\n        this._calculateSpeechBubbleMatrix(sprite, speechBubbleSkin),\n        1 /* spriteScale */\n      );\n    }\n  }\n\n  getTightBoundingBox(sprite) {\n    return this._getDrawable(sprite).getTightBoundingBox();\n  }\n\n  getBoundingBox(sprite) {\n    return Rectangle.fromMatrix(this._getDrawable(sprite).getMatrix());\n  }\n\n  // Mask drawing in to only areas where this sprite is opaque.\n  _stencilSprite(spr, colorMask) {\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n    // Enable stenciling. This means that:\n    // 1. Only pixels which pass the \"stencil test\" will be drawn.\n    // 2. Anything rendered will also draw to the stencil buffer.\n    gl.enable(gl.STENCIL_TEST);\n    // Pass the stencil test regardless of what's in the stencil buffer.\n    // Note that pixels which the shader has discarded will still fail the stencil test.\n    // 1 is the reference value which we use in the next line.\n    gl.stencilFunc(gl.ALWAYS, 1, 1);\n    // If the stencil test passes (in this case, if the shader hasn't discarded the pixel),\n    // draw a 1 to that pixel in the stencil buffer, replacing whatever's already there.\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n    // Don't draw to the color buffer. Only to the stencil buffer.\n    gl.colorMask(false, false, false, false);\n    // Draw the sprite in the \"silhouette\" mode, which discards transparent pixels.\n    // This, along with the above line, has the effect of not drawing anything to the color buffer, but\n    // creating a \"mask\" in the stencil buffer that masks out all pixels where this sprite is transparent.\n\n    const opts = {\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\n      renderSpeechBubbles: false,\n      // Ignore ghost effect\n      effectMask: ~effectBitmasks.ghost\n    };\n\n    // If we mask in the color (for e.g. \"color is touching color\"),\n    // we need to pass that in as a uniform as well.\n    if (colorMask) {\n      opts.colorMask = colorMask.toRGBANormalized();\n      opts.drawMode = ShaderManager.DrawModes.COLOR_MASK;\n    }\n    this._renderLayers(new Set([spr]), opts);\n\n    // Pass the stencil test if the stencil buffer value equals 1 (e.g. the pixel got masked in above).\n    gl.stencilFunc(gl.EQUAL, 1, 1);\n    // Keep the current stencil buffer values no matter what.\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n    // We can draw to the color buffer again. Note that only pixels which pass the stencil test are drawn.\n    gl.colorMask(true, true, true, true);\n  }\n\n  checkSpriteCollision(spr, targets, fast, sprColor) {\n    if (!spr.visible) return false;\n    if (!(targets instanceof Set)) {\n      if (targets instanceof Array) {\n        targets = new Set(targets);\n      } else {\n        targets = new Set([targets]);\n      }\n    }\n\n    const sprBox = Rectangle.copy(\n      this.getBoundingBox(spr),\n      __collisionBox\n    ).snapToInt();\n\n    // This is an \"impossible rectangle\"-- its left bound is infinitely far to the right,\n    // its right bound is infinitely to the left, and so on. Its size is effectively -Infinity.\n    // Its only purpose is to be the \"identity rectangle\" that starts the rectangle union process.\n    const targetBox = Rectangle.fromBounds(\n      Infinity,\n      -Infinity,\n      Infinity,\n      -Infinity\n    );\n    for (const target of targets) {\n      Rectangle.union(targetBox, this.getBoundingBox(target), targetBox);\n    }\n    targetBox.snapToInt();\n\n    if (!sprBox.intersects(targetBox)) return false;\n    if (fast) return true;\n\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    const collisionBox = Rectangle.intersection(sprBox, targetBox).clamp(\n      -cx,\n      cx,\n      -cy,\n      cy\n    );\n\n    if (collisionBox.width === 0 || collisionBox.height === 0) return false;\n\n    this._setFramebuffer(this._collisionBuffer);\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\n    this._stencilSprite(spr, sprColor);\n\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\n    this._renderLayers(targets, {\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\n      // Ignore ghost effect\n      effectMask: ~effectBitmasks.ghost\n    });\n\n    const gl = this.gl;\n    // Make sure to disable the stencil test so as not to affect other rendering!\n    gl.disable(gl.STENCIL_TEST);\n\n    const pixelData = new Uint8Array(\n      collisionBox.width * collisionBox.height * 4\n    );\n    gl.readPixels(\n      collisionBox.left + cx,\n      collisionBox.bottom + cy,\n      collisionBox.width,\n      collisionBox.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixelData\n    );\n\n    // Any opaque pixel = an overlap between the two sprites.\n    for (let i = 0; i < pixelData.length; i += 4) {\n      if (pixelData[i + 3] !== 0) return true;\n    }\n\n    return false;\n  }\n\n  checkColorCollision(spr, targetsColor, sprColor) {\n    const sprBox = Rectangle.copy(\n      this.getBoundingBox(spr),\n      __collisionBox\n    ).snapToInt();\n\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    sprBox.clamp(-cx, cx, -cy, cy);\n\n    if (sprBox.width === 0 || sprBox.height === 0) return false;\n\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n    this._setFramebuffer(this._collisionBuffer);\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\n    this._stencilSprite(spr, sprColor);\n\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\n    this._renderLayers(null, {\n      filter: layer => layer !== spr\n    });\n\n    // Make sure to disable the stencil test so as not to affect other rendering!\n    gl.disable(gl.STENCIL_TEST);\n\n    const pixelData = new Uint8Array(sprBox.width * sprBox.height * 4);\n    gl.readPixels(\n      sprBox.left + cx,\n      sprBox.bottom + cy,\n      sprBox.width,\n      sprBox.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixelData\n    );\n\n    const color = targetsColor.toRGBA();\n    for (let i = 0; i < pixelData.length; i += 4) {\n      if (\n        // Ensure we're not testing transparent pixels\n        pixelData[i + 3] !== 0 &&\n        // Scratch tests the top 5 bits of the red and green channels,\n        // and the top 4 bits of the blue channel.\n        ((pixelData[i] ^ color[0]) & 0b11111000) === 0 &&\n        ((pixelData[i + 1] ^ color[1]) & 0b11111000) === 0 &&\n        ((pixelData[i + 2] ^ color[2]) & 0b11110000) === 0\n      )\n        return true;\n    }\n\n    return false;\n  }\n\n  // Pick the topmost sprite at the given point (if one exists).\n  pick(sprites, point) {\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    for (let i = 0; i < sprites.length; i++) {\n      const sprite = sprites[i];\n      this._renderSkin(\n        this._getSkin(sprite.costume),\n        ShaderManager.DrawModes.SPRITE_ID,\n        this._getDrawable(sprite).getMatrix(),\n        1 /* scale */,\n        sprite.effects,\n        null,\n        null,\n        i\n      );\n    }\n\n    this._renderLayers(new Set([sprites]), {\n      effectMask: ~effectBitmasks.ghost\n    });\n\n    const hoveredPixel = new Uint8Array(4);\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    gl.readPixels(\n      point.x + cx,\n      point.y + cy,\n      1,\n      1,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      hoveredPixel\n    );\n\n    const index = colorToId(hoveredPixel);\n    if (index === -1) return null;\n    return sprites[index];\n  }\n\n  checkPointCollision(spr, point, fast) {\n    if (!spr.visible) return false;\n\n    const box = this.getBoundingBox(spr);\n    if (!box.containsPoint(point.x, point.y)) return false;\n    if (fast) return true;\n\n    // TODO: would it be faster to enable a scissor rectangle?\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    this._renderLayers(new Set([spr]), { effectMask: ~effectBitmasks.ghost });\n\n    const hoveredPixel = new Uint8Array(4);\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    gl.readPixels(\n      point.x + cx,\n      point.y + cy,\n      1,\n      1,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      hoveredPixel\n    );\n    return hoveredPixel[3] !== 0;\n  }\n\n  penLine(pt1, pt2, color, size) {\n    this._penSkin.penLine(pt1, pt2, color, size);\n  }\n\n  clearPen() {\n    this._penSkin.clear();\n  }\n\n  stamp(spr) {\n    this._setFramebuffer(this._penSkin._framebufferInfo);\n    this._renderLayers(new Set([spr]), { renderSpeechBubbles: false });\n  }\n\n  displayAskBox(question) {\n    const askBox = document.createElement(\"form\");\n    askBox.classList.add(\"leopard__askBox\");\n\n    const askText = document.createElement(\"span\");\n    askText.classList.add(\"leopard__askText\");\n    askText.innerText = question;\n    askBox.append(askText);\n\n    const askInput = document.createElement(\"input\");\n    askInput.type = \"text\";\n    askInput.classList.add(\"leopard__askInput\");\n    askBox.append(askInput);\n\n    const askButton = document.createElement(\"button\");\n    askButton.classList.add(\"leopard__askButton\");\n    askButton.innerText = \"Answer\";\n    askBox.append(askButton);\n\n    this.renderTarget.append(askBox);\n    askInput.focus();\n\n    return new Promise(resolve => {\n      askBox.addEventListener(\"submit\", e => {\n        e.preventDefault();\n        askBox.remove();\n        resolve(askInput.value);\n      });\n    });\n  }\n}\n","export default class Input {\n  constructor(stage, canvas, onKeyDown) {\n    this._stage = stage;\n    this._canvas = canvas;\n\n    // Allow setting focus to canvas\n    if (this._canvas.tabIndex < 0) {\n      this._canvas.tabIndex = 0;\n    }\n\n    this.mouse = { x: 0, y: 0, down: false };\n    this._canvas.addEventListener(\"mousemove\", this._mouseMove.bind(this));\n    this._canvas.addEventListener(\"mousedown\", this._mouseDown.bind(this));\n    this._canvas.addEventListener(\"mouseup\", this._mouseUp.bind(this));\n\n    this._canvas.addEventListener(\"keyup\", this._keyup.bind(this));\n    this._canvas.addEventListener(\"keydown\", this._keydown.bind(this));\n\n    this.keys = [];\n    this._onKeyDown = onKeyDown;\n  }\n\n  _mouseMove(e) {\n    const rect = this._canvas.getBoundingClientRect();\n    const scaleX = this._stage.width / rect.width;\n    const scaleY = this._stage.height / rect.height;\n    const realCoords = {\n      x: (e.clientX - rect.left) * scaleX,\n      y: (e.clientY - rect.top) * scaleY\n    };\n\n    this.mouse = {\n      ...this.mouse,\n      x: realCoords.x - this._stage.width / 2,\n      y: -realCoords.y + this._stage.height / 2\n    };\n  }\n\n  _mouseDown() {\n    this.mouse = {\n      ...this.mouse,\n      down: true\n    };\n  }\n\n  _mouseUp() {\n    this.mouse = {\n      ...this.mouse,\n      down: false\n    };\n  }\n\n  _keyup(e) {\n    const key = this._getKeyName(e);\n    this.keys = this.keys.filter(k => k !== key);\n  }\n\n  _keydown(e) {\n    e.preventDefault();\n\n    const key = this._getKeyName(e);\n    if (this.keys.indexOf(key) === -1) {\n      this.keys.push(key);\n    }\n\n    this._onKeyDown(key);\n  }\n\n  _getKeyName(e) {\n    if (e.key === \"ArrowUp\") return \"up arrow\";\n    if (e.key === \"ArrowDown\") return \"down arrow\";\n    if (e.key === \"ArrowLeft\") return \"left arrow\";\n    if (e.key === \"ArrowRight\") return \"right arrow\";\n    if (e.key === \" \") return \"space\";\n    if (e.code.substring(0, 5) === \"Digit\") return e.code[5];\n\n    return e.key.toLowerCase();\n  }\n\n  keyPressed(name) {\n    if (name === \"any\") return this.keys.length > 0;\n    return this.keys.indexOf(name) > -1;\n  }\n\n  focus() {\n    this._canvas.focus();\n  }\n}\n","import Sound from \"./Sound.js\";\n\nconst IGNORABLE_ERROR = [\"NotAllowedError\", \"NotFoundError\"];\n\n// https://github.com/LLK/scratch-audio/blob/develop/src/Loudness.js\nexport default class LoudnessHandler {\n  constructor() {\n    // TODO: use a TypeScript enum\n    this.connectionState = \"NOT_CONNECTED\";\n  }\n\n  get audioContext() {\n    return Sound.audioContext;\n  }\n\n  async connect() {\n    // If we're in the middle of connecting, or failed to connect,\n    // don't attempt to connect again\n    if (this.connectionState !== \"NOT_CONNECTED\") return;\n    this.connectionState = \"CONNECTING\";\n\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      // Chrome blocks usage of audio until the user interacts with the page.\n      // By calling `resume` here, we will wait until that happens.\n      await Sound.audioContext.resume();\n      this.hasConnected = true;\n      this.audioStream = stream;\n      const mic = this.audioContext.createMediaStreamSource(stream);\n      this.analyser = this.audioContext.createAnalyser();\n      mic.connect(this.analyser);\n      this.micDataArray = new Float32Array(this.analyser.fftSize);\n      this.connectionState = \"CONNECTED\";\n    } catch (e) {\n      this.connectionState = \"ERROR\";\n      if (IGNORABLE_ERROR.includes(e.name)) {\n        console.warn(\"Mic is not available.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  get loudness() {\n    if (this.connectionState !== \"CONNECTED\" || !this.audioStream.active) {\n      return -1;\n    }\n\n    this.analyser.getFloatTimeDomainData(this.micDataArray);\n    let sum = 0;\n    // compute the RMS of the sound\n    for (let i = 0; i < this.micDataArray.length; i++) {\n      sum += Math.pow(this.micDataArray[i], 2);\n    }\n    let rms = Math.sqrt(sum / this.micDataArray.length);\n    // smoothe the value with the last one, if it is descending\n    if (this._lastValue) {\n      rms = Math.max(rms, this._lastValue * 0.6);\n    }\n    this._lastValue = rms;\n\n    // scale the measurement so it's more sensitive to quieter sounds\n    rms *= 1.63;\n    rms = Math.sqrt(rms);\n    rms = Math.round(rms * 100);\n    rms = Math.min(rms, 100);\n    return rms;\n  }\n\n  getLoudness() {\n    this.connect();\n    return this.loudness;\n  }\n}\n","import Trigger from \"./Trigger.js\";\nimport Renderer from \"./Renderer.js\";\nimport Input from \"./Input.js\";\nimport LoudnessHandler from \"./Loudness.js\";\nimport Sound from \"./Sound.js\";\n\nexport default class Project {\n  constructor(stage, sprites = {}, { frameRate = 30 } = {}) {\n    this.stage = stage;\n    this.sprites = sprites;\n\n    Object.freeze(sprites); // Prevent adding/removing sprites while project is running\n\n    for (const sprite of this.spritesAndClones) {\n      sprite._project = this;\n    }\n    this.stage._project = this;\n\n    this.renderer = new Renderer(this);\n    this.input = new Input(this.stage, this.renderer.stage, key => {\n      this.fireTrigger(Trigger.KEY_PRESSED, { key });\n    });\n\n    this.loudnessHandler = new LoudnessHandler();\n    // Only update loudness once per step.\n    this._cachedLoudness = null;\n\n    this.runningTriggers = [];\n    // Used to keep track of what edge-activated trigger predicates evaluted to\n    // on the previous step.\n    this._prevStepTriggerPredicates = new WeakMap();\n\n    this.restartTimer();\n\n    this.answer = null;\n\n    // Run project code at specified framerate\n    setInterval(() => {\n      this.step();\n    }, 1000 / frameRate);\n\n    // Render project as fast as possible\n    this._renderLoop();\n  }\n\n  attach(renderTarget) {\n    this.renderer.setRenderTarget(renderTarget);\n    this.renderer.stage.addEventListener(\"click\", () => {\n      // Chrome requires a user gesture on the page before we can start the\n      // audio context.\n      // When we click the stage, that counts as a user gesture, so try\n      // resuming the audio context.\n      if (Sound.audioContext.state === \"suspended\") {\n        Sound.audioContext.resume();\n      }\n\n      let clickedSprite = this.renderer.pick(this.spritesAndClones, {\n        x: this.input.mouse.x,\n        y: this.input.mouse.y\n      });\n      if (!clickedSprite) {\n        clickedSprite = this.stage;\n      }\n\n      const matchingTriggers = [];\n      for (const trigger of clickedSprite.triggers) {\n        if (trigger.matches(Trigger.CLICKED, {}, clickedSprite)) {\n          matchingTriggers.push({ trigger, target: clickedSprite });\n        }\n      }\n\n      this._startTriggers(matchingTriggers);\n    });\n  }\n\n  greenFlag() {\n    // Chrome requires a user gesture on the page before we can start the\n    // audio context.\n    // When greenFlag is triggered, it's likely that the cause of it was some\n    // kind of button click, so try resuming the audio context.\n    if (Sound.audioContext.state === \"suspended\") {\n      Sound.audioContext.resume();\n    }\n    this.fireTrigger(Trigger.GREEN_FLAG);\n    this.input.focus();\n  }\n\n  // Find triggers which match the given condition\n  _matchingTriggers(triggerMatches) {\n    let matchingTriggers = [];\n    const targets = this.spritesAndStage;\n    for (const target of targets) {\n      const matchingTargetTriggers = target.triggers.filter(tr =>\n        triggerMatches(tr, target)\n      );\n      for (const match of matchingTargetTriggers) {\n        matchingTriggers.push({ trigger: match, target });\n      }\n    }\n    return matchingTriggers;\n  }\n\n  _stepEdgeActivatedTriggers() {\n    const edgeActivated = this._matchingTriggers(tr => tr.isEdgeActivated);\n    const triggersToStart = [];\n    for (const triggerWithTarget of edgeActivated) {\n      const { trigger, target } = triggerWithTarget;\n      let predicate;\n      switch (trigger.trigger) {\n        case Trigger.TIMER_GREATER_THAN:\n          predicate = this.timer > trigger.option(\"VALUE\", target);\n          break;\n        case Trigger.LOUDNESS_GREATER_THAN:\n          predicate = this.loudness > trigger.option(\"VALUE\", target);\n          break;\n        default:\n          throw new Error(`Unimplemented trigger ${trigger.trigger}`);\n      }\n\n      // Default to false\n      const prevPredicate = !!this._prevStepTriggerPredicates.get(trigger);\n      this._prevStepTriggerPredicates.set(trigger, predicate);\n\n      // The predicate evaluated to false last time and true this time\n      // Activate the trigger\n      if (!prevPredicate && predicate) {\n        triggersToStart.push(triggerWithTarget);\n      }\n    }\n    this._startTriggers(triggersToStart);\n  }\n\n  step() {\n    this._cachedLoudness = null;\n    this._stepEdgeActivatedTriggers();\n\n    // Step all triggers\n    const alreadyRunningTriggers = this.runningTriggers;\n    for (let i = 0; i < alreadyRunningTriggers.length; i++) {\n      alreadyRunningTriggers[i].trigger.step();\n    }\n\n    // Remove finished triggers\n    this.runningTriggers = this.runningTriggers.filter(\n      ({ trigger }) => !trigger.done\n    );\n  }\n\n  render() {\n    // Render to canvas\n    this.renderer.update(this.stage, this.spritesAndClones);\n\n    // Update watchers\n    for (const sprite of [...Object.values(this.sprites), this.stage]) {\n      for (const watcher of Object.values(sprite.watchers)) {\n        watcher.updateDOM(this.renderer.renderTarget);\n      }\n    }\n  }\n\n  _renderLoop() {\n    requestAnimationFrame(this._renderLoop.bind(this));\n    this.render();\n  }\n\n  fireTrigger(trigger, options) {\n    // Special trigger behaviors\n    if (trigger === Trigger.GREEN_FLAG) {\n      this.restartTimer();\n      this.stopAllSounds();\n      this.runningTriggers = [];\n\n      for (const spriteName in this.sprites) {\n        const sprite = this.sprites[spriteName];\n        sprite.clones = [];\n      }\n\n      for (const sprite of this.spritesAndStage) {\n        sprite.effects.clear();\n        sprite.audioEffects.clear();\n      }\n    }\n\n    const matchingTriggers = this._matchingTriggers((tr, target) =>\n      tr.matches(trigger, options, target)\n    );\n\n    return this._startTriggers(matchingTriggers);\n  }\n\n  _startTriggers(triggers) {\n    // Only add these triggers to this.runningTriggers if they're not already there.\n    // TODO: if the triggers are already running, they'll be restarted but their execution order is unchanged.\n    // Does that match Scratch's behavior?\n    for (const trigger of triggers) {\n      if (\n        !this.runningTriggers.find(\n          runningTrigger =>\n            trigger.trigger === runningTrigger.trigger &&\n            trigger.target === runningTrigger.target\n        )\n      ) {\n        this.runningTriggers.push(trigger);\n      }\n    }\n    return Promise.all(\n      triggers.map(({ trigger, target }) => {\n        return trigger.start(target);\n      })\n    );\n  }\n\n  get spritesAndClones() {\n    return Object.values(this.sprites)\n      .flatMap(sprite => sprite.andClones())\n      .sort((a, b) => a._layerOrder - b._layerOrder);\n  }\n\n  get spritesAndStage() {\n    return [...this.spritesAndClones, this.stage];\n  }\n\n  changeSpriteLayer(sprite, layerDelta, relativeToSprite = sprite) {\n    let spritesArray = this.spritesAndClones;\n\n    const originalIndex = spritesArray.indexOf(sprite);\n    const relativeToIndex = spritesArray.indexOf(relativeToSprite);\n\n    let newIndex = relativeToIndex + layerDelta;\n    if (newIndex < 0) newIndex = 0;\n    if (newIndex > spritesArray.length - 1) newIndex = spritesArray.length - 1;\n\n    // Remove sprite from originalIndex and insert at newIndex\n    spritesArray.splice(originalIndex, 1);\n    spritesArray.splice(newIndex, 0, sprite);\n\n    // spritesArray is sorted correctly, but to influence\n    // the actual order of the sprites we need to update\n    // each one's _layerOrder property.\n    spritesArray.forEach((sprite, index) => {\n      sprite._layerOrder = index + 1;\n    });\n  }\n\n  stopAllSounds() {\n    for (const target of this.spritesAndStage) {\n      target.stopAllOfMySounds();\n    }\n  }\n\n  get timer() {\n    const ms = new Date() - this.timerStart;\n    return ms / 1000;\n  }\n\n  restartTimer() {\n    this.timerStart = new Date();\n  }\n\n  async askAndWait(question) {\n    this.answer = await this.renderer.displayAskBox(question);\n  }\n\n  get loudness() {\n    if (this._cachedLoudness === null) {\n      this._cachedLoudness = this.loudnessHandler.getLoudness();\n    }\n    return this._cachedLoudness;\n  }\n}\n","import Color from \"./Color\";\n\nexport default class Watcher {\n  constructor({\n    value = () => \"\",\n    setValue = () => {},\n    label,\n    style = \"normal\",\n    visible = true,\n    color = Color.rgb(255, 140, 26),\n    step = 1,\n    x = -240,\n    y = 180,\n    width,\n    height\n  }) {\n    this.initializeDOM();\n\n    this.value = value;\n    this.setValue = setValue;\n    this._previousValue = Symbol(\"NO_PREVIOUS_VALUE\");\n\n    this.label = label;\n    this.style = style;\n    this.visible = visible;\n    this.color = color;\n    this.step = step;\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  initializeDOM() {\n    const node = document.createElement(\"div\");\n    node.classList.add(\"leopard__watcher\");\n\n    const label = document.createElement(\"div\");\n    label.classList.add(\"leopard__watcherLabel\");\n    node.append(label);\n\n    const value = document.createElement(\"div\");\n    value.classList.add(\"leopard__watcherValue\");\n    node.append(value);\n\n    const slider = document.createElement(\"input\");\n    slider.type = \"range\";\n    slider.classList.add(\"leopard__watcherSlider\");\n\n    slider.addEventListener(\"input\", event => {\n      this.setValue(Number(event.target.value));\n    });\n\n    node.append(slider);\n\n    this._dom = { node, label, value, slider };\n  }\n\n  updateDOM(renderTarget) {\n    if (renderTarget && !renderTarget.contains(this._dom.node)) {\n      renderTarget.append(this._dom.node);\n    }\n\n    if (!this.visible) return;\n\n    const value = this.value();\n\n    const isList = Array.isArray(value);\n    this._dom.node.classList.toggle(\"leopard__watcher--list\", isList);\n    if (isList) {\n      // Render like a list\n      if (\n        !Array.isArray(this._previousValue) ||\n        JSON.stringify(value.map(String)) !==\n          JSON.stringify(this._previousValue.map(String))\n      ) {\n        this._dom.value.innerHTML = \"\";\n        for (const [index, item] of value.entries()) {\n          const itemElem = document.createElement(\"div\");\n          itemElem.classList.add(\"leopard__watcherListItem\");\n\n          const indexElem = document.createElement(\"div\");\n          indexElem.classList.add(\"leopard__watcherListItemIndex\");\n          indexElem.innerText = index;\n\n          const contentElem = document.createElement(\"div\");\n          contentElem.classList.add(\"leopard__watcherListItemContent\");\n          contentElem.innerText = item.toString();\n\n          itemElem.append(indexElem);\n          itemElem.append(contentElem);\n          this._dom.value.append(itemElem);\n        }\n      }\n    } else {\n      // Render like a normal variable\n      if (value !== this._previousValue) {\n        this._dom.value.innerText = value.toString();\n      }\n    }\n\n    if (isList) {\n      this._previousValue = [...value];\n    } else {\n      this._previousValue = value;\n    }\n\n    // Set slider value\n    if (this._style === \"slider\") {\n      this._dom.slider.value = value;\n    }\n\n    // Update color\n    // (Needs to happen here rather than a setter because\n    // mutation of color object is possible.)\n    const textColor =\n      this.color.r * 0.299 + this.color.g * 0.587 + this.color.b * 0.114 > 162\n        ? \"#000\"\n        : \"#fff\";\n    this._dom.value.style.setProperty(\"--watcher-color\", this.color.toString());\n    this._dom.value.style.setProperty(\"--watcher-text-color\", textColor);\n  }\n\n  get visible() {\n    return this._visible;\n  }\n  set visible(visible) {\n    this._visible = visible;\n    this._dom.node.style.visibility = visible ? \"visible\" : \"hidden\";\n  }\n\n  get x() {\n    return this._x;\n  }\n  set x(x) {\n    this._x = x;\n    this._dom.node.style.left = `${x - 240}px`;\n  }\n\n  get y() {\n    return this._y;\n  }\n  set y(y) {\n    this._y = y;\n    this._dom.node.style.top = `${180 - y}px`;\n  }\n\n  get width() {\n    return this._width;\n  }\n  set width(width) {\n    this._width = width;\n    if (width) {\n      this._dom.node.style.width = `${width}px`;\n    } else {\n      this._dom.node.style.width = undefined;\n    }\n  }\n\n  get height() {\n    return this._height;\n  }\n  set height(height) {\n    this._height = height;\n    if (height) {\n      this._dom.node.style.height = `${height}px`;\n    } else {\n      this._dom.node.style.height = undefined;\n    }\n  }\n\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    this._style = style;\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--normal\",\n      style === \"normal\"\n    );\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--large\",\n      style === \"large\"\n    );\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--slider\",\n      style === \"slider\"\n    );\n  }\n\n  get min() {\n    return this._min;\n  }\n  set min(min) {\n    this._min = min;\n    this._dom.slider.min = min;\n  }\n\n  get max() {\n    return this._max;\n  }\n  set max(max) {\n    this._max = max;\n    this._dom.slider.max = max;\n  }\n\n  get step() {\n    return this._step;\n  }\n  set step(step) {\n    this._step = step;\n    this._dom.slider.step = step;\n  }\n\n  get label() {\n    return this._label;\n  }\n  set label(label) {\n    this._label = label;\n    this._dom.label.innerText = label;\n  }\n}\n"],"names":["GREEN_FLAG","Symbol","KEY_PRESSED","BROADCAST","CLICKED","CLONE_START","LOUDNESS_GREATER_THAN","TIMER_GREATER_THAN","BACKDROP_CHANGED","Trigger","constructor","trigger","options","script","this","_script","done","stop","isEdgeActivated","option","target","triggerOption","matches","start","boundScript","bind","_runningScript","Promise","resolve","step","next","Matrix","static","matrix","Float32Array","identity","dst","src","x","y","a00","a01","a02","a10","a11","a12","a20","a21","a22","rad","s","Math","sin","c","cos","m","Rectangle","left","Infinity","right","bottom","top","result","xa","xb","absx","abs","sumx","ya","yb","absy","sumy","snapToInt","floor","ceil","intersects","rect","containsPoint","clamp","min","max","rect1","rect2","width","height","effectNames","effectBitmasks","i","length","CENTER","effectTransformPoint","drawable","effects","_sprite","effectBitmask","_bitmask","mosaic","mosaicFactor","pixelate","skin","getCurrentSkin","pixSizeX","pixSizeY","whirl","PI_OVER_180","offsetX","offsetY","offsetLength","sqrt","whirlFactor","fisheye","vecX","vecY","len","factor","r","pow","unitX","unitY","n","rgbToHSV","g","b","delta","h","v","hsvToRGB","Color","a","Number","rgb","_setRGB","_a","_h","_s","_v","toHexString","forceIncludeAlpha","toHexDigits","str","round","toString","hex","map","join","toRGBString","toRGBA","toRGBANormalized","ADPCM_STEPS","ADPCM_INDEX","decodeADPCMAudio","ab","audioContext","dv","DataView","getUint32","reject","Error","blocks","l","byteLength","String","fromCharCode","getUint8","format","getUint16","sampleRate","blockSize","frameCount","fact","buffer","createBuffer","channel","getChannelData","sample","code","index","lastByte","offset","data","j","getInt16","isADPCMData","arrayBuffer","dataView","isWavData","Sound","name","url","audioBuffer","source","playbackRate","downloadMyAudioBuffer","duration","started","isLatestCallToStart","_markDone","playMyAudioBuffer","oldDoneDownloading","_doneDownloading","fromMoreRecentCall","playUntilDone","playing","addEventListener","disconnect","fetch","then","body","catch","error","console","warn","decodeAudioData","createBufferSource","value","connect","currentTime","setPlaybackRate","isConnectedTo","_setupAudioContext","_audioContext","AudioContext","window","webkitAudioContext","EffectChain","config","getNonPatchSoundList","inputNode","createGain","effectNodes","resetToInitial","initials","getInitialEffectValues","effectValues","initialValue","Object","entries","getEffectDescriptor","reset","setEffectValue","updateAudioEffect","descriptor","isPatch","getNextEffectDescriptor","previous","getPreviousEffectDescriptor","output","input","nodes","initial","makeNodes","node","Set","values","set","sound","last","getLastEffectDescriptor","isNaN","clampEffectValue","changeEffectValue","minimum","maximum","getEffectValue","clone","newConfig","newEffectChain","assign","resetOnClone","applyToSound","isTargetOf","effectDescriptors","find","slice","_","decayDuration","decayWait","aCtx","leftGain","rightGain","channelMerger","createChannelMerger","p","leftVal","PI","rightVal","gain","setTargetAtTime","interval","ratio","resetOnStart","linearRampToValueAtTime","AudioEffectMap","effectChain","defineProperty","get","clear","_EffectMap","_effectValues","effectName","val","_clone","keys","SpriteBase","initialConditions","vars","_project","costumeNumber","layerOrder","_costumeNumber","_layerOrder","triggers","watchers","costumes","sounds","getSoundsPlayedByMe","destination","audioEffects","_vars","filter","stage","sprites","number","fireBackdropChanged","costume","findIndex","lower","upper","excluded","possibleOptions","randInt","random","trim","moveAhead","changeSpriteLayer","moveBehind","degToRad","deg","radToDeg","degToScratch","scratchToDeg","scratchDir","radToScratch","scratchToRad","normalizeDeg","warp","procedure","bound","args","inst","wait","secs","endTime","Date","setMilliseconds","getMilliseconds","mouse","keyPressed","timer","restartTimer","startSound","soundName","getSound","playSoundUntilDone","stopAllSounds","stopAllOfMySounds","broadcast","fireTrigger","broadcastAndWait","running","clearPen","renderer","askAndWait","question","_speechBubble","say","answer","loudness","Sprite","super","direction","rotationStyle","size","visible","penDown","penSize","penColor","_x","_y","_direction","RotationStyle","ALL_AROUND","parent","clones","_penDown","_penColor","text","style","timeout","createClone","create","getPrototypeOf","original","push","tr","_startTriggers","deleteThisClone","runningTriggers","andClones","flatMap","dir","goto","penLine","move","dist","moveDir","glide","seconds","interpolate","t","startTime","startX","startY","color","stamp","touching","fast","checkPointCollision","bounds","getTightBoundingBox","stageWidth","stageHeight","checkColorCollision","checkSpriteCollision","colorTouching","clearTimeout","think","sayAndWait","setTimeout","thinkAndWait","freeze","LEFT_RIGHT","DONT_ROTATE","Stage","defineProperties","enumerable","__counter","backdrop","determinant","SpriteTransformDiff","sprite","_unset","update","_lastX","_lastY","_lastRotation","_lastRotationStyle","_lastSize","_lastCostume","_lastCostumeLoaded","img","complete","changed","Drawable","_renderer","_matrix","_matrixDiff","_calculateSpriteMatrix","_convexHullImageData","_convexHullMosaic","_convexHullPixelate","_convexHullWhirl","_convexHullFisheye","_convexHullPoints","_aabb","_tightBoundingBox","_convexHullMatrixDiff","_getSkin","getAABB","fromMatrix","getMatrix","convexHullPoints","_calculateConvexHull","fromBounds","transformedPoint","halfPixelX","halfPixelY","point","transformPoint","imageData","getImageData","leftHull","rightHull","pixelPos","effectPos","currentPoint","pixelX","pixelY","pop","spr","translate","rotate","scale","spriteScale","scalingFactor","resolution","center","Skin","gl","getTexture","_makeTexture","image","filtering","glTexture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","_setSizeFromImage","naturalWidth","naturalHeight","destroy","BitmapSkin","_image","_imageData","_texture","canvas","document","createElement","ctx","getContext","drawImage","NEAREST","deleteTexture","SpriteShader","PenLineShader","Shader","program","uniforms","attribs","numActiveUniforms","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","numActiveAttributes","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","ShaderManager","_shaderCache","drawMode","DrawModes","Map","_createShader","type","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","getShader","shaderMap","has","shaderCode","PEN_LINE","define","vertShader","vertex","VERTEX_SHADER","fragShader","fragment","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","LINK_STATUS","info","getProgramInfoLog","DEFAULT","SILHOUETTE","COLOR_MASK","SPRITE_ID","PenSkin","framebufferInfo","_createFramebufferInfo","_framebufferInfo","_lastPenState","texture","deleteFramebuffer","framebuffer","pt1","pt2","_setFramebuffer","_shaderManager","shaderChanged","_setShader","uniform2f","u_penSkinSize","oldColor","uniform4f","u_penColor","uniform1f","u_penSize","lineDiffX","lineDiffY","u_penPoints","lineLength","u_lineLength","drawArrays","TRIANGLES","clearColor","COLOR_BUFFER_BIT","bubbleStyle","SpeechBubbleSkin","bubble","_canvas","LINEAR","_bubble","_flipped","_rendered","_renderedScale","_renderBubble","_restyleCanvas","font","textBaseline","flipped","textWidth","measureText","maxWidth","padding","setTransform","fillStyle","strokeStyle","lineWidth","save","w","beginPath","moveTo","arcTo","lineTo","ellipse","closePath","stroke","fill","renderBubbleBackground","restore","fillText","VectorSkin","_imageDataMipLevel","_maxTextureSize","getParameter","MAX_TEXTURE_SIZE","_mipmaps","log2","mipLevel","mipLevelForScale","_drawSvgToCanvas","_createMipmap","mip","Costume","Image","crossOrigin","isBitmap","match","__collisionBox","Renderer","project","renderTarget","createStage","antialias","setRenderTarget","_drawables","WeakMap","_skins","_currentShader","_currentFramebuffer","_screenSpaceScale","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","activeTexture","TEXTURE0","_penSkin","_collisionBuffer","obj","_getDrawable","stencil","createFramebuffer","framebufferTexture2D","FRAMEBUFFER","COLOR_ATTACHMENT0","renderbuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","DEPTH_STENCIL","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","useProgram","attribLocation","a_position","enableVertexAttribArray","vertexAttribPointer","FLOAT","_updateStageSize","bindFramebuffer","viewport","querySelector","classList","add","append","_renderLayers","layers","renderSpeechBubbles","shouldRestrictLayers","shouldFilterLayers","shouldIncludeLayer","layer","renderSprite","penMatrix","_renderSkin","spritesAndClones","u_stageSize","drawingBufferWidth","drawingBufferHeight","_resize","stageSize","getBoundingClientRect","devicePixelRatio","adjustedWidth","adjustedHeight","imageRendering","_calculateSpeechBubbleMatrix","speechBubbleSkin","sprBounds","getBoundingBox","effectMask","colorMask","spriteColorId","skinTexture","uniformMatrix3fv","u_transform","effect","effectVal","u_skinSize","id","uniform1i","u_texture","Array","isArray","uniform4fv","u_colorMask","uniform3fv","u_spriteId","prototype","hasOwnProperty","call","_stencilSprite","STENCIL_BUFFER_BIT","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","opts","ghost","EQUAL","targets","sprColor","sprBox","copy","targetBox","union","cx","cy","collisionBox","intersection","disable","pixelData","Uint8Array","readPixels","targetsColor","pick","hoveredPixel","colorToId","displayAskBox","askBox","askText","innerText","askInput","askButton","focus","e","preventDefault","remove","Input","onKeyDown","_stage","tabIndex","down","_mouseMove","_mouseDown","_mouseUp","_keyup","_keydown","_onKeyDown","scaleX","scaleY","realCoords","clientX","clientY","key","_getKeyName","k","indexOf","substring","toLowerCase","IGNORABLE_ERROR","LoudnessHandler","connectionState","async","stream","navigator","mediaDevices","getUserMedia","audio","resume","hasConnected","audioStream","mic","createMediaStreamSource","analyser","createAnalyser","micDataArray","fftSize","includes","active","getFloatTimeDomainData","sum","rms","_lastValue","getLoudness","frameRate","loudnessHandler","_cachedLoudness","_prevStepTriggerPredicates","setInterval","_renderLoop","attach","state","clickedSprite","matchingTriggers","greenFlag","_matchingTriggers","triggerMatches","spritesAndStage","matchingTargetTriggers","_stepEdgeActivatedTriggers","edgeActivated","triggersToStart","triggerWithTarget","predicate","prevPredicate","alreadyRunningTriggers","render","watcher","updateDOM","requestAnimationFrame","spriteName","runningTrigger","all","sort","layerDelta","relativeToSprite","spritesArray","originalIndex","newIndex","splice","forEach","timerStart","setValue","label","initializeDOM","_previousValue","slider","event","_dom","contains","isList","toggle","JSON","stringify","innerHTML","item","itemElem","indexElem","contentElem","_style","textColor","setProperty","_visible","visibility","_width","undefined","_height","_min","_max","_step","_label"],"mappings":"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"}